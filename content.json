{"meta":{"title":"自由の翼小栈","subtitle":"技术&生活分享","description":"1111111111","author":"自由の翼","url":"https://zyzy.info","root":"/"},"pages":[],"posts":[{"title":"bun之初尝试","slug":"【2023-12-09】Bun的初尝试","date":"2023-12-09T02:00:00.000Z","updated":"2023-12-09T23:52:16.009Z","comments":true,"path":"2023/12/09/【2023-12-09】Bun的初尝试/","link":"","permalink":"https://zyzy.info/2023/12/09/%E3%80%902023-12-09%E3%80%91Bun%E7%9A%84%E5%88%9D%E5%B0%9D%E8%AF%95/","excerpt":"本篇是Bun 1.0 推出后的初尝试。Bun是一个集合所有js基础工具的运行时，以迄今为止最快的js 运行时而著称","text":"本篇是Bun 1.0 推出后的初尝试。Bun是一个集合所有js基础工具的运行时，以迄今为止最快的js 运行时而著称 像Node一样，Bun是一个运行时(runtime), 而非什么新的语言。感觉deno的地位有点尴尬了。大家被他的宣传的速度所折服。 安装官网推荐的是运行 1curl -fsSL https://bun.sh/install | bash 但鉴于国内有墙的原因，bun现在有npm包了，所以我更推荐另一种安装方法，更快更直接： 1npm i -g bun 用以下命令检查是否安装成功： 12(base) ➜ ~ bun -v1.0.12 启用项目初始化：123mkdir bun-learncd bun-learnbun init 可以看到 package.json 文件被 bun.lockb 文件替代，比起原来的json文件，这个文件写起来有点类似yml的语法，用了缩进和换行，不用花括号 直接生成了 tsconfig.json 文件, bun原生支持了 ts 跑单个文件，和node用法类似，当然run可以省略： 1bun run index.ts 简单的服务我们在 index.ts 里写上： 12345678const server = Bun.serve(&#123; port: 5678, fetch (req) &#123; return new Response(&quot;hello Bun!&quot;) &#125;&#125;)console.log(`listening on port $&#123;server.port&#125;`) 终端跑 index.ts , 浏览器可以看到 hello Bun! 的字样。当然，直接跑的话我们改 index.ts 要重启项目，可以加上 --watch 参数： 1bun --watch index.ts 进一步优化，创建一个env文件touch .env，将配置写在该文件里， 1PORT &#x3D; 8889 index.ts 文件里 port 参数改： 12--- port: 5678,+++ port: Bun.env.PORT || 5678, 可以见到，以前用node时，我们须安装 process 包，并且引入，才能用 process.env.PORT的，现在直接用Bun，课件Bun 把很多第三方库，如 process 也集成了, 无需二次下载。 处理路由把 fecth 函数改写如下： 123456fetch (req) &#123; const url = new URL(req.url); const &#123; pathname &#125; = url; if (pathname === &#x27;/&#x27;) return new Response(&#x27;home page!&#x27;) if (pathname === &#x27;/blog&#x27;) return new Response(&#x27;blog!&#x27;) return new Response(&quot;404&quot;)&#125; bunx类似 npx 的使用，直接运行二进制码，无须下载安装包，他自带了个 cowsay命令，可以体验 bunx的用法，命令行运行 bunx cowsay Hell Bun 123456789(base) ➜ bun-learn bunx cowsay Hello Bun ___________&lt; Hello Bun &gt; ----------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || 前端脚手架react 官方脚手架，在 Bun中使用如下： 123bun create react-app &lt;yourAppName&gt;# orbunx create-react-app &lt;yourAppName&gt; vite 的脚手架： 123bun create vite &lt;yourAppName&gt; --template vue# orbunx create-vite &lt;yourAppName&gt; --template vue 模块化引入bun 直接支持 es module 和 commonjs 两种模块引入，也不用在 package.json 里做出其他配置，解决了困扰了 node 多年的模块引入问题。 下面是一个简单的demo，新建一个文件 module.ts 1touch module.ts 以下我们用 path 模块举例： 1234567import path from &#x27;path&#x27;;// const path = require(&#x27;path&#x27;); // commonjs also okconst filepath = path.join(&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;img.png&#x27;);const filename = path.basename(filepath);console.log(filename); 跑了后控制台可看到： 12(base) ➜ bun-learn bun module.ts img.png 一些常用模块在Bun中的使用file 模块Bun.write() 写入文件：1touch file-demo.ts 写下： 12const data = &#x27;I love Bun!&#x27;await Bun.write(&#x27;file-demo.txt&#x27;, data); 从以上代码可以看出，Bun 和 deno 一样，支持顶层的 await语法，无须像node一样包装在 async 函数里使用 await Bun.write() 接口可写入文件 跑 bun file-demo.ts 可以看到当前目录下生成了 file-demo.txt 文件，并在文件里写下了 data 的内容。 await Bun.file().text() 读取文件在上面的代码加上： 123const file = Bun.file(&#x27;file-demo.txt&#x27;);console.log(&#x27;file-demo content：&#x27;, await file.text()); 控制台输出 12(base) ➜ bun-learn bun file-demo.tsfile-demo content： I love Bun! 这里值得注意，Bun.file().text() 是异步接口，返回的是 Promise 对象，所以必须用上 await 关键字才能显示出内容 其他几个file的接口： 123console.log(await file.stream())console.log(await file.arrayBuffer());console.log(&#x27;file size:&#x27;, file.size) 测试模块bun集成了jest的测试模块，我们在项目里直接创建测试文件： 1touch index.test.ts 1234567891011import &#123; describe, expect, test, beforeAll &#125; from &quot;bun:test&quot;;beforeAll(() =&gt; &#123; console.log(&#x27;呵呵&#x27;)&#125;);describe(&#x27;math&#x27;, () =&gt; &#123; test(&#x27;addition&#x27;, () =&gt; &#123; expect(2+1).toBe(3); &#125;)&#125;); 可以看出，所有的jest模块都集成在 &quot;bun:test&quot; 原生包里，控制台跑的结果： 1234567891011(base) ➜ bun-learn bun test bun test v1.0.12 (85c99751)index.test.ts:呵呵✓ math &gt; addition [0.19ms] 1 pass 0 fail 1 expect() callsRan 1 tests across 1 files. [11.00ms] bundle 打包我们来试试用Bun 进行普通的bundle打包在项目根目录创建以下文件夹和文件： 123---src |__ githubApi.ts |__ index.ts githubApi.ts文件 前端js代码打包，所以暂时不用顶层 await 语法： 12345678import axios from &quot;axios&quot;;const fetchUser = async (user) =&gt; &#123; const res = await axios.get(`https://api.github.com/users/$&#123;user&#125;`) return res.data&#125;export default fetchUser index.ts文件 123456import fetchUser from &#x27;./githubApi&#x27;;(async () =&gt; &#123; const userData = await fetchUser(&#x27;ys558&#x27;) document.querySelector(&#x27;h1&#x27;).innerHTML = JSON.stringify(userData);&#125;)(); 在命令行里运行： 1bun build ./src/index.ts --outfile=./dist/bundle.js 可以看到dist文件夹下生成了 bundle.js 将该文件放入 HTML的 script标签里则可使用 如果开发时，可以在 bun build 的命令加上 --watch, 则可以热加载模式 1bun build ./src/index.ts --outfile=./dist/bundle.js --watch react 在项目中的应用在我们原来的项目里添加 react 和 react-dom 1bun i react react-dom src 下创建 index.tsx , 写一个简单的计数器： 1234567891011121314151617import React from &#x27;react&#x27;;import &#123; createRoot &#125; from &#x27;react-dom&#x27;;const root = createRoot(document.getElementById(&#x27;root&#x27;));const App = () =&gt; &#123; const [count, setCount] = React.useState(0) return ( &lt;div&gt; &lt;h1&gt;Count: &#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; )&#125;;root.render(&lt;App/&gt;); 在 dist 目录下，创建一个根目录 index.html, 加上一下两行： 12&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./bun.js&quot;&gt;&lt;/script&gt; bash下运行: 1bun build ./src/index.tsx --outfile=./dist/budle.js --watch 打开 index.html 就可以看到该计数器","categories":[],"tags":[{"name":"bun","slug":"bun","permalink":"https://zyzy.info/tags/bun/"}]},{"title":"react-18新特性","slug":"【2023-10-29】react-18新特性","date":"2023-10-29T07:29:26.000Z","updated":"2023-10-29T16:23:18.781Z","comments":true,"path":"2023/10/29/【2023-10-29】react-18新特性/","link":"","permalink":"https://zyzy.info/2023/10/29/%E3%80%902023-10-29%E3%80%91react-18%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"React 18 新特性","text":"React 18 新特性 并发模式（Concurrent Mode）：这种新的渲染模式允许在浏览器下一帧空闲时进行更新，允许多个任务同时进行，提高了渲染性能。体现在代码上就是 Suspense 组件的应用： 12345678910111213import React, &#123; Suspense &#125; from &#x27;react&#x27;; const loadingComponent = () =&gt; &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125;; const App = () =&gt; &#123; return ( &lt;Suspense fallback=&#123;loadingComponent()&#125;&gt; &lt;AsyncComponent /&gt; &lt;/Suspense&gt; ); &#125;; 新的更新调度器（Update Scheduler）：这个新的更新调度器可以更细粒度地调度更新，以优化更新优先级和时间分片。 React 18引入了一个新的更新调度器，它可以更细粒度地调度更新。这个新的调度器允许React根据任务的优先级和时间分片来安排更新。这意味着React可以根据应用程序的状态和用户交互来优化更新顺序，从而提供更好的用户体验。 以下是一个示例，演示了如何使用新的更新调度器： 12345678910111213141516171819202122import React, &#123; useState &#125; from &#x27;react&#x27;; const Timer = () =&gt; &#123; const [time, setTime] = useState(Date.now()); const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const timer = setTimeout(() =&gt; &#123; setTime(Date.now()); setCount(0); &#125;, 1000); return () =&gt; clearTimeout(timer); &#125;, []); return ( &lt;div&gt; &lt;p&gt;Current time: &#123;time&#125;&lt;/p&gt; &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt; &lt;/div&gt; ); &#125;; 在这个示例中，我们使用了useState和useEffect来管理状态和执行副作用。在每一秒钟更新时间戳，并在每次点击按钮时增加计数器的值。由于新的更新调度器的引入，React可以根据优先级和时间分片来安排更新，从而提供更好的用户体验。 新的渲染API：React 18引入了新的渲染API，包括createRoot()函数和Concurrent Mode下的新的渲染函数。支持SSR for Suspense：React 18现在支持服务器端渲染（SSR）和Suspense的集成，以改善首屏加载时间和用户体验。 createRoot api 更新前后对比：用 createRoot 替换 render。这样 12345678910// Beforeimport &#123; render &#125; from &#x27;react-dom&#x27;;const container = document.getElementById(&#x27;app&#x27;);render(&lt;App tab=&quot;home&quot; /&gt;, container);// Afterimport &#123; createRoot &#125; from &#x27;react-dom/client&#x27;;const container = document.getElementById(&#x27;app&#x27;);const root = createRoot(container); // createRoot(container!) if you use TypeScriptroot.render(&lt;App tab=&quot;home&quot; /&gt;); 自动批处理（Automatic Batching）：在React 18中，当setState被调用后，并不会立即触发重新渲染。React会执行全部事件处理函数，然后触发一个单独的re-render，合并所有的更新。这样可以减少程序数据状态存在中间值导致的不稳定性，也可以提高渲染性能。 代码的体现也同样是 Suspence 组件： 1234567891011121314151617181920212223import React, &#123; Suspense &#125; from &#x27;react&#x27;; const loadingComponent = () =&gt; &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125;; const App = () =&gt; &#123; return ( &lt;Suspense fallback=&#123;loadingComponent()&#125;&gt; &#123;async () =&gt; &#123; // 在这里执行一些异步操作，例如数据获取等。 const data = await fetchData(); // 假设fetchData是一个异步操作，返回一些数据。 return ( &lt;div&gt; &#123;data.map((item) =&gt; ( &lt;div key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; ); &#125;&#125; &lt;/Suspense&gt; ); &#125;;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://zyzy.info/tags/react/"},{"name":"react Suspense","slug":"react-Suspense","permalink":"https://zyzy.info/tags/react-Suspense/"}]},{"title":"Rust学习笔记（5）—— 枚举 enum","slug":"【2023-10-08】Rust学习笔记（5）—— 枚举 enum","date":"2023-10-07T16:39:38.000Z","updated":"2023-11-12T06:53:11.148Z","comments":true,"path":"2023/10/08/【2023-10-08】Rust学习笔记（5）—— 枚举 enum/","link":"","permalink":"https://zyzy.info/2023/10/08/%E3%80%902023-10-08%E3%80%91Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%885%EF%BC%89%E2%80%94%E2%80%94%20%E6%9E%9A%E4%B8%BE%20enum/","excerpt":"本文的参考代码在这里","text":"本文的参考代码在这里 枚举 enum基本概念枚举为您提供了一种表示某个值是一组可能的值之一的方法。 下面的代码定义了枚举 enum 类型，IpAddrKind v4和v6 绑定枚举值时，须用 :: 绑定 123456789101112131415161718#[derive(Debug)]enum IpAddrKind &#123; v4, v6&#125;fn main() &#123; // 创建变体实例, 用 :: 绑定值 let four = IpAddrKind::v4; let six = IpAddrKind::v6; route(four); // ip_kind -&gt; v4 route(six); // ip_kind -&gt; v6&#125;fn route(ip_kind: IpAddrKind) &#123; println!(&quot;ip_kind -&gt; &#123;:?&#125;&quot;, ip_kind); &#125; 我们创建一个上一节提到的 struct 结构体，对ip的实际地址用字符串进行存储： 123456789101112131415161718192021222324252627282930#[derive(Debug)]enum IpAddrKind &#123; v4, v6&#125;#[derive(Debug)]struct IpAddr &#123; kind: IpAddrKind, address: String&#125;fn main() &#123; let home = IpAddr &#123; kind: IpAddrKind::v4, address: String::from(&quot;127.0.0.1&quot;), &#125;; let loopback = IpAddr &#123; kind: IpAddrKind::v6, address: String::from(&quot;::1&quot;), &#125;; route(home); // ip_kind -&gt; IpAddr &#123; kind: v4, address: &quot;127.0.0.1&quot; &#125; route(loopback); // ip_kind -&gt; IpAddr &#123; kind: v6, address: &quot;::1&quot; &#125;&#125;fn route(ip_kind: IpAddr) &#123; println!(&quot;ip_kind -&gt; &#123;:?&#125;&quot;, ip_kind);&#125; enum 可独自定义每个成员的数据类型但上面的代码可以让 enum 直接存储类型为 String, 省去更多代码，可以改写如下： 12345678910111213#[derive(Debug)]enum IpAddrKind &#123; v4(String), v6(String)&#125;fn main() &#123; let home = IpAddrKind::v4(String::from(&quot;127.0.0.1&quot;)); let loopback = IpAddrKind::v6(String::from(&quot;::1&quot;)); println!(&quot;home &#123;:?&#125;&quot;, home); // home v4(&quot;127.0.0.1&quot;) println!(&quot;loopback &#123;:?&#125;&quot;, loopback); // loopback v6(&quot;::1&quot;)&#125; 甚至可以再细化, 做到结构体无法完成的任务，例如ipv4一般是4个8 bit的 数值，定义类型时可和ipv6区分开来： 12345678910111213#[derive(Debug)]enum IpAddrKind &#123; v4(u8, u8, u8, u8), v6(String)&#125;fn main() &#123; let home = IpAddrKind::v4(String::from(127, 0, 0, 1)); let loopback = IpAddrKind::v6(String::from(&quot;::1&quot;)); println!(&quot;home &#123;:?&#125;&quot;, home); // home v4(&quot;127.0.0.1&quot;) println!(&quot;loopback &#123;:?&#125;&quot;, loopback); // loopback v6(&quot;::1&quot;)&#125; 其实我们在标准库里，可以看到一个专门定义ip的结构体，可以用来这样表达enum： 123456789101112struct Ipv4Addr &#123; // --snip--&#125;struct Ipv6Addr &#123; // --snip--&#125;enum IpAddr &#123; V4(Ipv4Addr), V6(Ipv6Addr),&#125; rust 里没有 null 值概念，null 的问题在于，如果您尝试将空值用作非空值，则会收到某种错误。所以用 None代替，即无值。他在标准库的定义如下： 1234enum Option&lt;T&gt; &#123; None, Some(T),&#125;","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://zyzy.info/tags/rust/"},{"name":"enum","slug":"enum","permalink":"https://zyzy.info/tags/enum/"}]},{"title":"Rust学习笔记（4）—— 结构体 struct","slug":"【2023-10-02】Rust学习笔记（4）—— 结构体 struct","date":"2023-10-02T02:46:38.000Z","updated":"2023-10-29T16:23:18.781Z","comments":true,"path":"2023/10/02/【2023-10-02】Rust学习笔记（4）—— 结构体 struct/","link":"","permalink":"https://zyzy.info/2023/10/02/%E3%80%902023-10-02%E3%80%91Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%884%EF%BC%89%E2%80%94%E2%80%94%20%E7%BB%93%E6%9E%84%E4%BD%93%20struct/","excerpt":"本文的参考代码在这里","text":"本文的参考代码在这里 定义及实例化结构 Structstruct 关键字，中文可以理解为结构体, 是一种自定义数据类型。 123456789101112131415struct User &#123; username: String, active: bool, email: String, sign_in_count: u64&#125;fn main() &#123; let mut user1 = User &#123; username: String::from(&quot;user1&quot;), email: String::from(&quot;user1@mail.com&quot;), active: true, sign_in_count: 1 &#125;;&#125; 改变实例中的值，可以直接用点 . 进行访问及赋值，如： 123456let name = user1.username;user1.username = String::from(&quot;John123&quot;);println!( &quot;username before: &#123;&#125;, username after: &#123;&#125;&quot;, name, user1.username); // username before: user1, username after: John123 Field Init 简写用函数生成实例：封装一个函数用于生成 User 对象，再生成一个 user2的实例 当生成 user3 时，如果其他属性不想列出，可以直接用 .. 的语法拿取 user2 中的参数直接使用： 1234567891011121314151617181920212223fn main() &#123; let user2 = build_user( String::from(&quot;kyle@mail.com&quot;), String::from(&quot;kyle123&quot;) ); println!(&quot;user2.username =&gt; &#123;&#125;, user3.email after =&gt; &#123;&#125;&quot;, user2.username, user2.email); // user2.username =&gt; kyle123, user3.email after =&gt; kyle@mail.com let user3 = User &#123; email: String::from(&quot;james@mail.com&quot;), username: String::from(&quot;james234&quot;), ..user2 &#125;; println!(&quot;user3.username &#123;&#125;, user3.email &#123;&#125;&quot;, user3.username, user3.email); // user3.username james234, user3.email james@mail.com&#125;fn build_user(email: String, username: String) -&gt; User &#123; User &#123; email, username, active: true, sign_in_count: 1 &#125;&#125; tuple struct 使用元组结构创建不同类型123// tuple structstruct Color(i32, i32, i32);struct Point(i32, i32, i32); 以下的代码是一个普通的计算长方形面积的函数： 12345678910fn main() &#123; let width1 = 30; let height1 = 50; println!(&quot;area of the reactangle is &#123;&#125;&quot;, area(width1, height1)); // area of the reactangle is 1500&#125;fn area(width: u32, height: u32) -&gt; u32 &#123; width * height&#125; 将其传参改为元组，则可以改写成： 12345678fn main() &#123; let rect = (30, 50); println!(&quot;area of the reactangle is &#123;&#125;&quot;, area_by_tuple(rect)); // area of the reactangle is 1500&#125;fn area_by_tuple(dimensions: (u32, u32)) -&gt; u32 &#123; dimensions.0 * dimensions.1&#125; 将元组的部分提炼成 struct, 改写成： 1234567891011121314151617struct Rectangle &#123; width: u32, height: u32&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!(&quot;rect1 &#123;:?&#125;&quot;, rect1); // rect1 Rectangle &#123; width: 30, height: 50 &#125; println!(&quot;the area of the reactangle is &#123;&#125;&quot;, area_by_struct(&amp;rect1)); // the area of the reactangle is 1500&#125;fn area_by_struct(rectangle: &amp;Rectangle) -&gt; u32 &#123; rectangle.width * rectangle.height&#125; tips：在我们定义了 let rect1 后我们是无法直接打印出来的，会报错，这时，我们需要在 struct Rectangle 上加一个修饰符 #[derive(Debug)]，而且打印里的{}也需要加上，才能正确打印出 rect1，如： 123456789101112131415161718#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!(&quot;rect1 &#123;:?&#125;&quot;, rect1); // rect1 Rectangle &#123; width: 30, height: 50 &#125; println!(&quot;rect1 &#123;:#?&#125;&quot;, rect1); // rect1 Rectangle &#123; // width: 30, // height: 50, // &#125;&#125; 以上涉及到 trait 特征的概念，我们后面的章节会讲到 方法 Method Syntax定义方法上面的 struct 由于有固定的公式，即width*height 我们可以把他简化为 impl, 将area的计算公式定义在其内部，少写了一个函数 1234567891011121314151617181920212223242526272829303132333435#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32&#125;impl Rectangle &#123; fn area_by_impl(&amp;self) -&gt; u32 &#123; self.width * self.height &#125; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125;&#125;fn main() &#123; let rect2 = Rectangle &#123; width: 33, height: 55 &#125;; println!(&quot;the area of the reactangle is &#123;&#125;&quot;, rect2.area_by_impl()); // the area of the reactangle is 1815 let rect3 = Rectangle &#123; width: 22, height: 33 &#125;; let rect4 = Rectangle &#123; width: 66, height: 77 &#125;; println!(&quot;rect2 can hold rect3 &#123;&#125;&quot;, rect2.can_hold(&amp;rect3)); // rect2 can hold rect3 true println!(&quot;rect2 can hold rect4 &#123;&#125;&quot;, rect2.can_hold(&amp;rect4)); // rect2 can hold rect4 false &#125; 关联函数尽管官方文档有很多解释，但简单来说就是 impl 能直接像普通函数一样传入参数，我们来看一个例子 1234567891011121314impl Rectangle &#123; fn square(size: u32) -&gt; Self &#123; Self &#123; width: size, height: size &#125; &#125;&#125;fn main() &#123; let rect5 = Rectangle::square(22); println!(&quot;rect5 &#123;:?&#125;&quot;, rect5); // rect5 Rectangle &#123; width: 22, height: 22 &#125;&#125; 需要注意，关联函数需要用 :: 进行函数传值，而不是点。","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://zyzy.info/tags/rust/"},{"name":"struct","slug":"struct","permalink":"https://zyzy.info/tags/struct/"}]},{"title":"Rust学习笔记（3）—— 核心概念：所有权","slug":"【2023-10-01】Rust学习笔记（3）—— 核心概念：所有权","date":"2023-10-01T02:46:38.000Z","updated":"2023-10-29T16:23:18.780Z","comments":true,"path":"2023/10/01/【2023-10-01】Rust学习笔记（3）—— 核心概念：所有权/","link":"","permalink":"https://zyzy.info/2023/10/01/%E3%80%902023-10-01%E3%80%91Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%883%EF%BC%89%E2%80%94%E2%80%94%20%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%EF%BC%9A%E6%89%80%E6%9C%89%E6%9D%83/","excerpt":"本文的参考代码在这里","text":"本文的参考代码在这里 所有权（Ownership）Rust的所有权（Ownership）是一个核心概念，它帮助Rust在没有垃圾回收机制的情况下进行内存管理。在Rust中，每个值都有一个与之关联的变量，这个变量被称为该值的所有者（owner）。 以下是关于Rust所有权的一些关键规则： 一个值在任何时刻只能有一个所有者。 当值的所有者超出其作用域时，该值将被销毁。 这意味着Rust在运行时内存管理方面与许多其他编程语言不同。在某些语言中（如C），开发人员需要显式地分配（allocate）和回收（deallocate）内存。而在其他具有垃圾回收功能的语言（如Java）中，垃圾回收器会在程序运行时不断寻找不再使用的内存。但Rust的所有权系统允许它无需这些额外的机制就能保证内存安全。 垃圾回收器：在其他一些具有垃圾回收机制的语言中，由于垃圾回收器自动管理内存，可能会导致程序运行速度更快但性能表现更加不可预测。此外，大型程序会更大，手动管理内存可能会增加错误处理和管理的成本。然而，Rust没有使用垃圾回收器，因此不会出现这些问题。 内存控制：使用Rust可以更好地控制内存的使用，从而避免内存泄漏或内存溢出等问题。此外，由于没有垃圾回收器，写入时间会更快，但大型程序的大小可能会导致更高的运行时延迟。 所有权模型：Rust拥有所有权模型，这有助于减少内存错误并提高代码的可靠性。然而，这也会导致学习曲线变得更加陡峭，因为需要更多地了解内存管理和内存分配策略。 内存管理：Rust具有更好的内存管理能力，这有助于优化性能。然而，这也会增加错误处理和维护成本。 学习曲线：由于Rust的内存管理和内存控制的复杂性，需要更多的学习和练习才能掌握它们。 所有权代码示例： 123456789101112fn main() &#123; // ------ 所有权规则 -------- // 1. 每个值在Rust中都有一个被称为其所有者的变量。 // 2. 在任何时候，一个值只能有一个所有者。 // 3. 当所有者超出其作用域时，该值将被丢弃（drop）。 &#123; // s 还未被声明。 let s: &amp;str = &quot;hello&quot;; // s 被定义，开始生效 println!(&quot;x value is &#123;&#125;&quot;, x); // 当包含&#x27;s&#x27;的作用域结束时（即大括号 &#x27;&#123;&#125;&#x27; 结束时），&#x27;s&#x27;将不再有效。因为在这个时刻，&#x27;s&#x27;的所有者已经超出了其作用域，所以Rust会安全地删除&#x27;s&#x27;所引用的内存中的数据。 &#125;&#125; 移动（Move）操作的数据交互Rust的移动（Move）概念，类似别的语言里的复制（copy），其原理在引用值复制上有着本质区别，这也是Rust语言独特的地方。 原始值复制这种和其他语言的copy区别不大 1234// 原始值的复制// 将值绑定5到x；然后复制 中的值x并将其绑定到ylet x = 5;let y = x; // copy 引用值复制先看一段rust代码： 12let s1 = String::from(&quot;hello&quot;);let s2 = s1; // 移动（Move），而非浅拷贝（shallow copy） 如果按照其他语言的copy操作 s1被创建后，其指针、长度和容量存在于栈（Stack）中，其值”hello”存在于堆（Heap）中。 s2复制s1，s2创造出一块新的栈（Stack），存储其指针、长度和容量等属性，但共用堆中的”hello” 值。 rust 对以上的操作做了优化，正如前面所说的，当s2被绑定了s1的堆（Heap）引用值后，s1已超出范围（scope），rust认为s1的值不再有效，直接丢弃（drop）了，示例图： 1234let s1 = String::from(&quot;hello&quot;);let s2 = s1;println!(&quot;&#123;&#125;, world!&quot;, s1); // 报错❌ 以上的print会报错如下：因为s1的值已经移动（Move）到s2 12345678910111213141516171819202122$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership)error[E0382]: borrow of moved value: `s1` --&gt; src/main.rs:5:28 |2 | let s1 = String::from(&quot;hello&quot;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait3 | let s2 = s1; | -- value moved here4 |5 | println!(&quot;&#123;&#125;, world!&quot;, s1); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)help: consider cloning the value if the performance cost is acceptable |3 | let s2 = s1.clone(); | ++++++++For more information about this error, try `rustc --explain E0382`.error: could not compile `ownership` due to previous error 按照以上的报错，如果还需要用到s1, rust也保留了copy操作，我们必须用.clone()进行拷贝，代码修改如下： 1234let s1 = String::from(&quot;hello&quot;);--- let s2 = s1;+++ let s2 = s1.clone();println!(&quot;&#123;&#125;&quot;, s1); // hello Move 在函数中的应用1234567891011fn main() &#123; let s3: String = String::from(&quot;xxxxx&quot;); takes_ownership(s3); // println!(&quot;s3 &#123;&#125;&quot;, s3); // 报错❌&#125;fn takes_ownership(some_str: String) &#123; println!(&quot;some_str &#123;&#125;&quot;, some_str); // 变量 some_str 的作用域move到这里为止&#125; 上述代码中， 因s3值已经move 到函数takes_ownership(s3);里，其值已经不存在s3上，而跳到了函数里 函数里的 some_str 传进来后，被限制在函数的作用域里后被销毁（drop） 所以 println!(&quot;s3 &#123;&#125;&quot;, s3); 则会报错，因为 s3的值已被销毁在函数 takes_ownership的作用域里 而原始值则没有这个问题： 123456789fn main() &#123; let x = 5; makes_copy(x); println!(&quot;x -&gt; &#123;&#125;&quot;, x); // x -&gt; 5&#125;fn makes_copy(some_int: i32) &#123; println!(&quot;some_int &#123;&#125;&quot;, some_int); &#125; 回到引用值的移动（move）的问题，如果要避免move后带来的影响，则须将引用值直接放函数里作为返回值即可，如： 123456789fn main() &#123; // 引用值改为可用状态，将引用值放函数里作为返回值即可： let s4 = gives_overship(); println!(&quot;s4 &#123;&#125;&quot;, s4); // s4 hello&#125;fn gives_overship() -&gt; String &#123; String::from(&quot;hello&quot;)&#125; 或如下，变量 ss2 传入函数 takes_and_gives_back 后，仍要使用 ss2，则须再写一个函数 takes_and_gives_back 将其值困 12345678910111213fn main() &#123; let ss1 = gives_overship(); let ss2 = String::from(&quot;ss2 pass in string&quot;); println!(&quot;ss1 = &#123;&#125;, takes_and_gives_back = &#123;&#125;&quot;, ss1, takes_and_gives_back(ss2)); // ss1 = hello, ss3 = ss2 pass in string&#125;fn gives_overship() -&gt; String &#123; String::from(&quot;hello&quot;)&#125;fn takes_and_gives_back(a_string: String) -&gt; String &#123; a_string&#125; &amp; 引用及借用 (References and Borrowing)rust 允许使用 返回元组的解构 例如以下例子，x1传入了函数 calculate_str_length(x1) 里，已经被移动了， 在外面如果要再获取x1，则需返回其原值并将其解构出来，但这样返回值就复杂了，传入的同时还需返回他 12345678910fn main() &#123; let x1 = String::from(&quot;kkkkkk&quot;); let (y, len) = calculate_str_length(x1); println!(&quot;the length of &#123;&#125; is &#123;&#125;&quot;, y, len);&#125;fn calculate_str_length(s: String) -&gt; (String, usize) &#123; let length = s.len(); (s, length)&#125; 如果传进的函数的值 x1 要在外面获取，但又不需要将其传回作为返回值，就需要用到引用： 1234567891011fn main() &#123; let str1 = String::from(&quot;uuuuuuuuu&quot;); let length = str_length(&amp;str1); println!(&quot;the length of &#123;&#125; is &#123;&#125;&quot;, str1, length); // the length of uuuuuuuuu is 9&#125;fn str_length(s: &amp;String) -&gt; usize &#123; // s.push_str(&quot;ooops&quot;); // err ❌ let length = s.len(); length&#125; 上面的代码中，调用str1时，加入了 &amp; 符号，即引用 函数里的引用变量会自行寻找值，而不是获取他的所有权，从而让进入函数的变量，在后续能被继续使用。 同样的，借用的变量 s 则不能进行其他操作，因为仅仅是借用。 可变引用（Mutable References）上面代码解决的办法就是将 str1 定义为可迭代操作 mut，以下是修改后的代码： 1234567891011fn main() &#123; let mut str1 = String::from(&quot;uuuuuuuuu&quot;); let length = str_length(&amp;mut str1); println!(&quot;the length of &#123;&#125; is &#123;&#125;&quot;, str1, length); // the length of uuuuuuuuuooops is 14&#125;fn str_length(s: &amp;mut String) -&gt; usize &#123; s.push_str(&quot;ooops&quot;); let length = s.len(); length&#125; 而引用有严格的限制, 例如以下代码： 12345let mut str2 = String::from(&quot;kkkkkkkk&quot;);let r1 = &amp;str2;let r2 = &amp;str2;// let r3: = &amp;mut str2; // 错误 ❌println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2); 上面定义的 r3 会报错，是因为： r3 前定义的 r1 和 r2 已定义为非 mut变量，他们还未被使用 要解决以上报错，则须将其移动到 print 之后即可，因 r1, r2 定义后已被使用过 修改后： 123456let mut str2 = String::from(&quot;kkkkkkkk&quot;);let r1 = &amp;str2;let r2 = &amp;str2;println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2); let r3 = &amp;mut str2; // 正确 r1, r2定义后已被使用过，out of scopeprintln!(&quot;r3 &#123;&#125;&quot;, r3); // r3 kkkkkkkk 悬空引用（Dangling References）在函数内部，引用值不能作为返回值！这是因为引用值 s 已超出范围, s 值已被丢弃，以下是错误❌代码示范： 1234567fn dangle() -&gt; &amp;String &#123; // dangle returns a reference to a String let s = String::from(&quot;hello&quot;); // s is a new String &amp;s // we return a reference to the String, s&#125; // Here, s goes out of scope, and is dropped. Its memory goes away.// Danger! ❌ 字符串切片类型（The Slice Type）Rust 的切片是一种比较特殊的形式，这里我们单独讨论。以下是官方文档对切片所有权的总结： Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership. 切片允许您引用集合中连续的元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。 让我们看一个切片的例子， 12345let str3: String = String::from(&quot;hello world&quot;);let hello3: &amp;str = &amp;str3[..5];let world3: &amp;str = &amp;str3[6..];println!(&quot;str3 第一个词 &#123;&#125;&quot;, hello); // str3 第一个词 hello 上面的而切片有着一个特殊的类型 &amp;str, 同样的，定义字符串时，也可将其定义为 &amp;str，就像下面的例子： 1234567let str4: &amp;str = &quot;hello rust&quot;;let hello4: &amp;str = &amp;str4[..5];let rust4: &amp;str = &amp;str4[6..];let hello_rust = &amp;str[..];println!(&quot;str4 第一个词 &#123;&#125;&quot;, hello4); // str4 第一个词 helloprintln!(&quot;str4 第二个词 &#123;&#125;&quot;, rust4); // str4 第二个词 rustprintln!(&quot;整个词 &#123;&#125;&quot;, hello_rust); // 整个词 hello rust 封装寻找第一个词的函数： 12345678910111213141516171819fn main() &#123; let str3: String = String::from(&quot;hello world&quot;); let word = first_word(&amp;str3); println!(&quot;word -&gt; &#123;&#125;&quot;, word);&#125;fn first_word (s: &amp;str) -&gt; &amp;str &#123; let bytes = s.as_bytes(); for (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b&#x27; &#x27; &#123; // 如果该句子有空格，则返回第一个元素 return &amp;s[0..i]; &#125; &#125; // 如果没有空格则返回整个句子 &amp;s[..]&#125; 可以看出，我们传入和返回的类型均为 &amp;str","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://zyzy.info/tags/rust/"},{"name":"ownership","slug":"ownership","permalink":"https://zyzy.info/tags/ownership/"}]},{"title":"Rust学习笔记（2）—— 编程基础概念, 变量、数据类型、流程控制","slug":"【2023-09-30】Rust学习笔记（2）—— 编程基础概念, 变量、数据类型、流程控制","date":"2023-09-30T02:46:38.000Z","updated":"2023-10-29T16:23:18.780Z","comments":true,"path":"2023/09/30/【2023-09-30】Rust学习笔记（2）—— 编程基础概念, 变量、数据类型、流程控制/","link":"","permalink":"https://zyzy.info/2023/09/30/%E3%80%902023-09-30%E3%80%91Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%882%EF%BC%89%E2%80%94%E2%80%94%20%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5,%20%E5%8F%98%E9%87%8F%E3%80%81%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/","excerpt":"本文的具体代码在这里","text":"本文的具体代码在这里 编程基础概念在 Rust 中的体现变量 定义变量后，如果赋值后要改变，必须加上 mut 关键字，否则则不能改变其值。同样的，定义了 const 之后的常量，则不能加上 mut 数字较大时，可以用下划线替代千分号分隔数字 12345678// variables and constancelet mut x:i32 = 5;println!(&quot;x value is &#123;&#125;&quot;, x);x = 6;println!(&quot;x value is changed: &#123;&#125;&quot;, x);const COUNT: u32 = 1_000_000;println!(&quot;COUNT value is &#123;&#125;&quot;, COUNT); 变量遮蔽(variable shadowing)，同一个作用域内，允许对同一变量名进行二次定义 这样做的好处是方便，坏处是后期代码量大会使得代码难以维护，所以使用时应谨慎 12345// variable shadowing:let y: u32 = 7;println!(&quot;y value is &#123;&#125;&quot;, y);let y: &amp;str = &quot;eight&quot;;println!(&quot;y value is changed: &#123;&#125;&quot;, y); 数据类型Intergers分为有符号（i）和无符号（u）： Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 其取值范围分别是：2的8、16、32、64、128次方 Signed的数由于有负数的取值范围，所以比 Unsigned 取值范围减半 Type Range i8 -128~127 u8 0~255 i16 -32768~32767 u16 0~65535 i32 -2147483648~2147483647 u32 0~4294967295 i64 -9223372036854775808~9223372036854775807 u64 0~18446744073709551615 i128 -170141183460469231731687303715884105728~170141183460469231731687303715884105727 u128 0~340282366920938463463374607431768211455 进制：| Number literals | Example || :–: | :–: || Decimal | 98_222 || Hex | 0xff || Octal | 0o77 || Binary | 0b1111_0000 || Byte (u8 only) | b’A’ | Floating12let x1 = 2.45; // f64println!(&quot;&#123;&#125;&quot;, x1); Boolean12let t = false;println!(&quot;&#123;&#125;&quot;, t); Charactor (字符型)123456let ch = &#x27;z&#x27;;println!(&quot;char z: &#123;&#125;&quot;, ch); // char z: zlet z_char: char = &#x27;ℤ&#x27;; // with explicit type annotationprintln!(&quot;char z: &#123;&#125;&quot;, z_char); // char z: ℤlet heart_eyed_cat = &#x27;😻&#x27;;println!(&quot;heart_eyed_cat: &#123;&#125;&quot;, heart_eyed_cat); // heart_eyed_cat: 😻 tuple （元组）1let tup0 = (11,22); 123456789// 可对元组里的每个元素单独定义：let tup1: (&amp;str, i32, f32) = (&quot;let&#x27;s get Rusty!&quot;, 1_000_000, 0.45);// 解构：let (channel, sub_count, float_num) = tup;println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, channel, sub_count, float_num); // let&#x27;s get Rusty! 1000000 0.45// 索引：let sub_count: i32 = tup.1;println!(&quot;sub_count: &#123;&#125;&quot;, sub_count); Array1234let arr = [1, 2, 3, 4, 5];// 定义类型：[数据类型，数组长度]let arr1: [i32; 5] = [1, 2, 3, 4, 5]; Funtion 定义与调用： 1234567fn main() &#123; my_function(12, 34);&#125;fn my_function (x: i32, y: i32) -&gt; i32 &#123; println!(&quot;my function: &#123;&#125;, y: &#123;&#125;&quot;, x, y);&#125; 函数返回值，可省 return 关键字，且返回的语句或变量无需加 ; 函数如有返回值，则须用 -&gt; 定义返回值类型 12345678fn main() &#123; let result = my_function(12, 34); println!(&quot;result: &#123;&#125;&quot;, result);&#125;fn my_function (x: i32, y: i32) -&gt; i32 &#123; x + y&#125; Control Flowif-else if-else分支的条件无需套括号 ()12345678let number: i32 = 5;if number &lt; 10 &#123; println!(&quot;1 true&quot;);&#125;else if number &lt; 22 &#123; println!(&quot;2 true&quot;);&#125;else&#123; println!(&quot;false&quot;);&#125; if-else 条件可写在一行：12let condition: bool = true;let num:i32 = if condition &#123; 1 &#125; else &#123; 2 &#125;; while12345678let mut n = 3;while n != 0 &#123; println!(&quot;&#123;&#125;!&quot;, n); n -= 1;&#125;// 3!// 2!// 1! loop和while循环有点类似： 12345678910111213loop &#123; println!(&quot;again!&quot;); break&#125;let mut counter = 0;let loop_result = loop &#123; counter += 1; if counter == 10 &#123; break counter; &#125;&#125;; println!(&quot;loop_result: &#123;&#125;&quot;, counter); // loop_result: 10 for1234567let arr_for = [11,22,33,44,55];for item in arr_for.iter() &#123; println!(&quot;the arr value is: &#123;&#125;&quot;, item);&#125;// the arr value is: 11// the arr value is: 22// the arr value is: 33 类似 python 的 range 和 scala的 Range ，在rust里使用.. 表示数值范围： .. 的取值范围包括开始值，不包括终止值：123456for value in 1..4 &#123; println!(&quot;&#123;&#125;!!&quot;, value);&#125;// 1!!// 2!!// 3!!","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://zyzy.info/tags/rust/"},{"name":"cargo","slug":"cargo","permalink":"https://zyzy.info/tags/cargo/"}]},{"title":"Rust学习笔记（1）—— 安装、cargo、crate","slug":"【2023-09-30】Rust学习笔记（1）—— 安装、cargo、crate","date":"2023-09-30T00:46:38.000Z","updated":"2023-10-29T16:23:18.779Z","comments":true,"path":"2023/09/30/【2023-09-30】Rust学习笔记（1）—— 安装、cargo、crate/","link":"","permalink":"https://zyzy.info/2023/09/30/%E3%80%902023-09-30%E3%80%91Rust%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%881%EF%BC%89%E2%80%94%E2%80%94%20%E5%AE%89%E8%A3%85%E3%80%81cargo%E3%80%81crate/","excerpt":"很久没有更新博客了，最近自学 rust, 这里记录一下。本文参考了Rust Book写的","text":"很久没有更新博客了，最近自学 rust, 这里记录一下。本文参考了Rust Book写的 Rust 语言初探安装见文档，十分简单，这里不赘述 hello worldtouch main.rs 创建文件，并写下： 123fn main() &#123; println!(&quot;Hello world&quot;);&#125; rust是需要静态编译的语言，所以先执行 rustc main.rs 编译为二进制码后再执行，可看到控制台打印 hello world: 12345# mac./main# windows.\\main.exe cargo 的使用rustc 只能试用在一些比较简单的程序，复杂的程序需用到rust自带的项目管理工具 cargo，本仓库使用讲的每个章节均用一个项目的方式, 每个项目均能独立跑起, 下面是几个常用命令： 123456789101112131415# 新建项目：cargo new &lt;ProjectName&gt;# 编译构建项目，构建完成的项目会放在 target/debug 目录cd &lt;ProjectName&gt;cargo build # 为发布的编译，须加上 --release，会对编译的代码进行优化，构建完的项目会放在 target/release 目录cargo build --release# 编译构建并运行项目：cargo run# 检查是否能通过编译：效率比 cargo build 快很多cargo check 注释1234// 单行注释/*多行注释*/ 变量123456789101112131415fn main() &#123; let x = 88; // 报错： // x = 99; // 如要使其可变，则应加上 mut 关键字，immutable缩写： let mut y = 99; y = 100; println!(&quot;x is &#123;&#125;, y is &#123;&#125;&quot;, x, y) // 定义一个空字符串, // 中间两个冒号:表明String的关联函数，针对类型本身而实现的，而非针对字符串某特定实例实现的 let mut guess = String::new();&#125; crate 库的使用 rust的库叫 crate, 需要用的lib包可在 crate 官网 里找到。这次我们用随机生成数字的库, 在项目目录里添加： 12345...# 前面的 ^ 表示任何与0.8.4兼容的版本均可以下载[dependencies]rand = &quot;^0.3.23&quot; 添加完成后，返回终端，输入 cargo check 或 cargo build，则可以下载该lib包, 如： 1234567891011ziyouzhiyi@zyzy: ~/Documents/code/rust-learn/test-project main ⚡$ cargo check [11:57:13]Updating crates.io indexDownloaded rand v0.4.6Downloaded rand v0.3.23Downloaded 2 crates (87.7 KB) in 1.38sCompiling libc v0.2.126Checking rand v0.4.6Checking rand v0.3.23Checking test-project v0.1.0 (/Users/ziyouzhiyi/Documents/code/rust-learn/test-project)Finished dev [unoptimized + debuginfo] target(s) in 5.74s Cargo.lock 文件：当第一次安装lib包成功后，会将该包 rand v0.3.23 所依赖包所有lib包版本号放入 Cargo.lock 文件中，以后每次重新构建，均会按照里面列举的版本进行安装，除非自己手动进行 rand v0.8.4 版本升级。 cargo update 命令：如要更新b版本以上的版本，须手动在 toml 文件里重新写上版本号再执行update命令，此时，cargo 会忽略 Cargo.lock 文件直接更新","categories":[],"tags":[{"name":"rust","slug":"rust","permalink":"https://zyzy.info/tags/rust/"},{"name":"cargo","slug":"cargo","permalink":"https://zyzy.info/tags/cargo/"}]},{"title":"【2022-05-15】typescript泛型的应用","slug":"【2022-05-15】typescript泛型的应用","date":"2022-05-15T06:09:38.000Z","updated":"2023-10-29T16:23:18.779Z","comments":true,"path":"2022/05/15/【2022-05-15】typescript泛型的应用/","link":"","permalink":"https://zyzy.info/2022/05/15/%E3%80%902022-05-15%E3%80%91typescript%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"本文介绍泛型一些基础用法。","text":"本文介绍泛型一些基础用法。 泛型数组里泛型的运用如下代码，如果传入的数值为string，则须把number改为any, 但这样一来就失去了类型检查的意义。此时泛型（generics）排上用场 123456const last = (arr: Array&lt;number&gt;) =&gt; &#123; return arr[arr.length - 1]&#125;const l = last([1,2,3,4])const l1 = last([&#x27;1&#x27;, 2]) // 错误 last 函数须改为 123456789101112const last = &lt;T&gt;(arr: Array&lt;T&gt;): T =&gt; &#123; return arr[arr.length - 1]&#125;// orconst last = &lt;T&gt;(arr: T[]): T =&gt; &#123; return arr[arr.length - 1]&#125;// 调用的地方类型检验也可写上，当然不写也行：const l = last([1,2,3,4])const l1 = last&lt;string | number&gt;([&#x27;1&#x27;, 2]) // 错误 当然，也可定义于多个参数 12345678const makeArr = &lt;X, Y&gt;(x: X, y: Y): [X, Y] =&gt; &#123; return [x, y]&#125;const v = makeArr(5, 6)const v1 = makeArr(&#x27;a&#x27;,&#x27;b&#x27;)// 调用时也写上类型，也可省略const v2 = makeArr&lt;string, number&gt;(&#x27;a&#x27;, 5) 以上代码还有骚操作写法： 123456789// 类似es6的默认值写法：Y泛型指定了泛型默认值，const makeArr = &lt;X, Y = number&gt;(x: X, y: Y): [X, Y] =&gt; &#123; return [x, y]&#125;// 调用时的第二个泛型可省略：const v3 = makeArr&lt;string | null&gt;(null, 5)// 当然，和es6的默认值语法一样，虽指定了默认值为number，但要传入string也一样可以，这时则不能再指定类型，否则报错：const v4 = makeArr(null, &#x27;5&#x27;) 对象里泛型的应用如下，指定了{}的两个属性，如果有多个属性一起传入，则会报错： 12345678const fullName = (obj: &#123; firstName: string, lastName: string&#125;) =&gt; &#123; return &#123; ...obj, fullName: obj.firstName + &#x27; &#x27; + obj.lastName &#125;&#125;const v4 = fullName(&#123; firstName: &#x27;bob&#x27;, lastName: &#x27;junior&#x27;, age: 15&#125;) 此时可以用泛型的 extends 关键字，扩展了原有obj，改写如下： 1234567const fullName = &lt;T extends &#123; firstName: string, lastName: string &#125;&gt; (obj: T): T =&gt; &#123; return &#123; ...obj, fullName: obj.firstName + &#x27; &#x27; + obj.lastName &#125;&#125; 接口中泛型的应用如下例子，可在 interface 里直接传入一个泛型 T，定义时利用 type 类型定义传入类型 12345678interface Tab&lt;T&gt; &#123; id: string position: number date: T&#125;type NumberTab = Tab&lt;number&gt;type StringTab = Tab&lt;string&gt;","categories":[],"tags":[{"name":"type script","slug":"type-script","permalink":"https://zyzy.info/tags/type-script/"}]},{"title":"umijs-qiankun微前端实践","slug":"【2022-03-27】umijs-qiankun微前端实践","date":"2022-03-27T06:18:15.000Z","updated":"2023-10-29T16:23:18.779Z","comments":true,"path":"2022/03/27/【2022-03-27】umijs-qiankun微前端实践/","link":"","permalink":"https://zyzy.info/2022/03/27/%E3%80%902022-03-27%E3%80%91umijs-qiankun%E5%BE%AE%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/","excerpt":"umijs推出的微前端框架qiankun，是国内比较流行的微前端方案，其官方文档有配置的方法，但是说的比较模糊，这里亲自实践一下","text":"umijs推出的微前端框架qiankun，是国内比较流行的微前端方案，其官方文档有配置的方法，但是说的比较模糊，这里亲自实践一下 创建项目微前端分位主应用和若干个微应用，分别独立运行。所以分别创建以下目录解构： 1234&lt;project root&gt; |__main |__app1 |__app2 根据umijs文档，分别在每个项目里生成对应的umijs项目，并都安装umijs乾坤插件 @umijs/plugin-qiankun 1234npm i yarn tyarn -gtyarn create @umijs/umi-apptyarn add @umijs/plugin-qiankuntyarn 修改.umirc配置这个是文档没说清楚的地方，所有umijs的配置，均要在.umirc里修改，在main项目添加以下配置： 12345678910111213141516171819202122232425262728293031 routes: [ &#123; path: &#x27;/&#x27;, component: &#x27;@/pages/index&#x27;, routes: [ &#123; path: &#x27;/app1&#x27;, microApp: &#x27;app1&#x27;, &#125;, &#123; path: &#x27;/app2&#x27;, microApp: &#x27;app2&#x27;, &#125;, ], &#125;,],qiankun: &#123; master: &#123; // 注册子应用信息 apps: [ &#123; name: &#x27;app1&#x27;, // 唯一 id entry: &#x27;//localhost:7701&#x27;, // html entry &#125;, &#123; name: &#x27;app2&#x27;, // 唯一 id entry: &#x27;//localhost:7702&#x27;, // html entry &#125;, ], &#125;,&#125;, 在 app1 和 app2 的 .umirc 分别写： 123qiankun: &#123; slave: &#123;&#125;,&#125;, 在 app1 和 app2 的 package.json 分别指定app名字，否则qiankun插件认不出来： 12345// app1 package.json &quot;name&quot;: &quot;app1&quot;// app2 package.json &quot;name&quot;: &quot;app2&quot; 这里注意，微服务要跑在不同端口，根据在.env文件中定义，我们可在 main app1 app2 下分别创建 .env 文件并写下端口号，如： 12345678# mainPORT=7700# app1PORT=7701# app2PORT=7702 这样，当每个项目各自跑的时候，就能按要求跑在指定的端口号 子项目配置 app.ts 文件这个是关键一步，每个子项目都要配置对应的子项目生命周期函数，否则报错： 12345678910111213141516171819202122232425262728293031// app1/src/app.tsexport const qiankun = &#123; // 应用加载之前 async bootstrap(props: any) &#123; console.log(&#x27;app1 bootstrap&#x27;, props); &#125;, // 应用 render 之前触发 async mount(props: any) &#123; console.log(&#x27;app1 mount&#x27;, props); &#125;, // 应用卸载之后触发 async unmount(props: any) &#123; console.log(&#x27;app1 unmount&#x27;, props); &#125;,&#125;;// app2/src/app.tsexport const qiankun = &#123; // 应用加载之前 async bootstrap(props: any) &#123; console.log(&#x27;app2 bootstrap&#x27;, props); &#125;, // 应用 render 之前触发 async mount(props: any) &#123; console.log(&#x27;app2 mount&#x27;, props); &#125;, // 应用卸载之后触发 async unmount(props: any) &#123; console.log(&#x27;app2 unmount&#x27;, props); &#125;,&#125;; 更改界面走到这一步, app1 和 app2 均会配置到主应用 main 的props.children里了，我们将主应用界面更改如下： 12345678910111213&#x2F;&#x2F; main&#x2F;src&#x2F;pages&#x2F;index.tsximport styles from &#39;.&#x2F;index.less&#39;;export default function IndexPage(props) &#123; console.log(&#39;props-----&gt;&#39;, props.children.props.children); return ( &lt;div&gt; &lt;h1 className&#x3D;&#123;styles.title&#125;&gt;Main App&lt;&#x2F;h1&gt; &lt;div&gt;&#123;props.children&#125;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; );&#125; 最终效果如下，通过/app1 可达 app1 应用，/app2可达 app2 应用：","categories":[],"tags":[{"name":"umijs","slug":"umijs","permalink":"https://zyzy.info/tags/umijs/"},{"name":"qiankun","slug":"qiankun","permalink":"https://zyzy.info/tags/qiankun/"}]},{"title":"用esbuild创建自己的js类库npm包","slug":"【2022-03-20】用esbuild创建自己的js类库npm包","date":"2022-03-20T01:46:15.000Z","updated":"2023-12-09T23:42:12.175Z","comments":true,"path":"2022/03/20/【2022-03-20】用esbuild创建自己的js类库npm包/","link":"","permalink":"https://zyzy.info/2022/03/20/%E3%80%902022-03-20%E3%80%91%E7%94%A8esbuild%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84js%E7%B1%BB%E5%BA%93npm%E5%8C%85/","excerpt":"很久没有更新, 这次趁着周末有空, 赶紧把工作中碰到的问题进行一次总结. 并记录下来.最近碰到需要创建npm包的需求, 这里把他形成文档记录下来.","text":"很久没有更新, 这次趁着周末有空, 赶紧把工作中碰到的问题进行一次总结. 并记录下来.最近碰到需要创建npm包的需求, 这里把他形成文档记录下来. 前端的变化实在是快, 1年多前仍是babel的天下, 现在杀出个 esbuild , babel用js编写, 而 esbuild用更快的go语音编写, 他俩在webpack中均有对应的插件关于新的打包工具 esbuild, 他支持最原生的es module语法.在我的这篇文章里已有将其配置于CRA热更新的操作, 大家可以做参考.写这篇文章的目的在于结合esbuild官网, 走一遍自己的配置的过程, 顺便把webpack的配置进一下对比. 最基础的webpack及esbuild配置 从最基础的配置开始, yarn init 生成 package.json 文件, 并安装 yarn add esbuild webpack webpack-cli 两个工具. 将包名改为mylib, 加上 script , 配置 &quot;type&quot;: &quot;module&quot;为可以用esm语法 1234567891011121314151617&#123; &quot;name&quot;: &quot;mylib&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;author&quot;: &quot;ys558&quot;, &quot;scripts&quot;: &#123; &quot;wp-build&quot;: &quot;webpack --mode=production&quot;, &quot;es-build&quot;: &quot;esbuild --bundle src/index.js --outfile=dist/myLib.esbuild.bundle.js --minify&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;esbuild&quot;: &quot;^0.14.27&quot;, &quot;webpack&quot;: &quot;^5.70.0&quot;, &quot;webpack-cli&quot;: &quot;^4.9.2&quot; &#125;, &quot;type&quot;: &quot;module&quot;&#125; 新建 scr/index.js 和 src/moduleA.js, 随便写下一些东西, 用上esm语法: 123// src/moduleA.jsconst moduleA = &#x27;module A&#x27;export default moduleA 1234567891011121314151617181920// src/index.jsimport moduleA from &quot;./moduleA.js&quot;;const valueA = &quot;function A&quot;, valueB = &quot;function B&quot;;export function functionA() &#123; return valueA;&#125;class ClassA &#123; constructor(param)&#123; this.param = param; &#125;&#125;const A = new ClassA(&#x27;a&#x27;);console.log(functionA())console.log(moduleA)console.log(&#x27;param of classA&#x27;, A.param) 分别跑 yarn run wp-build 和 yarn run es-build, 可看到打包出来dist的两个文件, 123dist |__main.js |__myLib.esbuild.bundle.js 无论webpack还是esbuild, 均默认生成dist/main.js . 所以两个命令分别运行, 会覆盖掉原来的dist/main.js文件 myLib.esbuild.bundle.js 文件由我们指定的es script生成的, 而webpack的配置是要写在 webpack.config.js 里去配置. 配置 webpack.config.js 文件如下: 1234567891011121314151617181920// path 和 url 均属于node的内置模块, 均是 commonJS 模块, 所以 这里里不支持直接解构导入: // import &#123; fileURLToPath &#125; from &#x27;url&#x27;; &lt;-- 错误// 只能写成以下形式: 先整体导入再解构:import url from &#x27;url&#x27;;import path from &#x27;path&#x27;;const &#123; fileURLToPath &#125; = urlconst &#123; dirname &#125; = pathconst __filename = fileURLToPath(import.meta.url);const __dirname = dirname(__filename);const webpackConfig = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;myLib.webpack.bundle.js&#x27;, &#125;,&#125;;export default webpackConfig 再跑 yarn run wp-build 可发现打包出了两个文件: 123dist |__myLib.webpack.bundle.js |__myLib.esbuild.bundle.js","categories":[],"tags":[{"name":"esbuild","slug":"esbuild","permalink":"https://zyzy.info/tags/esbuild/"},{"name":"webpack","slug":"webpack","permalink":"https://zyzy.info/tags/webpack/"}]},{"title":"Mono Repo 简介及实现方法","slug":"【2021-11-09】MonoRepo简介及实现方法","date":"2021-11-09T03:23:15.000Z","updated":"2023-10-29T16:23:18.778Z","comments":true,"path":"2021/11/09/【2021-11-09】MonoRepo简介及实现方法/","link":"","permalink":"https://zyzy.info/2021/11/09/%E3%80%902021-11-09%E3%80%91MonoRepo%E7%AE%80%E4%BB%8B%E5%8F%8A%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/","excerpt":"本文介绍私有仓库包的管理模式 mono repo","text":"本文介绍私有仓库包的管理模式 mono repo mono repo的好处mono repo的好处来源于这篇文章，我用自己直白点的话总结了以下几点： 多个内部模块可以集中管理 只需在根目录安装 node_modules 即可，无须所有模块都安装 例如，一个有多端的项目，而且每个端都饮用了共有的模块，我们可以把所有项目或包放到一个packages中集中管理 例如我们平时熟悉的react，babel等库的源码，都是采用mono repo进行仓库管理。 我们需要用到两个库，yarn workspace 和 lerna， 以下的项目示例里，前者用于依赖管理，后者用于处理发布问题，在版本发布这块，使用lerna更方便，可用于替代一部分的git的功能。 当然 lerna 也可以直接替代 yarn workspace 的功能。 yarn workspace 管理依赖123mkdir common servercd common &amp;&amp; yarn init -y &amp;&amp; touch index.jscd ../server/ &amp;&amp; yarn init -y &amp;&amp; touch index.js package.json 配置 workspacespackage.json，将 common, server 两个文件夹视为两个package包 1234&#123; &quot;private&quot;: true, &quot;workspaces&quot;: [ &quot;packages/*&quot; ]&#125; 建一个简单的目录结构如下： 1234567root |__package.json |__packages |__common |__package.json |__server |__package.json 假设在common包里安装react和react-dom，则直接执行： 1yarn workspace common add react react-dom --dev yarn workspace 的具体用法，可以看官方文档 自己写的包要相互引用的方法我们把上面的目录结构 common 包和 server 各自添加index.js，如下： 123456789root |__package.json |__packages |__common |__index.js |__package.json |__server |__index.js |__package.json packages\\common\\index.js 里写点简单的东西： 1module.exports = () =&gt; console.log(&#x27;hello fr common&#x27;) packages\\server\\index.js 12// 这里的 &quot;common&quot; 对应 common\\package.json 里的 &quot;name&quot;，即直接引用common作为依赖包const commonFn = require(&quot;@mono-repo-by-yarn-lerna/common&quot;); common\\package.json 里，社区里的习惯性做法是加上前缀@项目名称/，如： 123456789&#123; &quot;name&quot;: &quot;@mono-repo-by-yarn-lerna/common&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;@mono-repo-by-yarn-lerna/common&quot;: &quot;1.0.0&quot; &#125;&#125; server\\package.json 运行 yarn install，会看到以下，证明在server文件夹成功安装common文件夹作为依赖 12345678$ yarnyarn install v1.22.10[1/4] Resolving packages...[2/4] Fetching packages...[3/4] Linking dependencies...[4/4] Building fresh packages...success Saved lockfile.Done in 0.16s. 返回根目录运行 ls node_modules/ 可以看到多了 ‘@mono-repo-by-yarn-lerna’ / 为项目的东西 12$ ls node_modules/&#x27;@mono-repo-by-yarn-lerna&#x27;/ 运行 node server/index.js 可以看到运行的结果： 12$ node packages/server/index.js hello fr common 如果此时我们再在 server 文件夹里添加其他模块，例如 babel，运行 yarn add babel， 会发现 server 文件夹里的 node_modules 只放了 babel 的一些执行文件，其余 babel 的核心文件全部被移动到根目录里的 node_modules，以此达到集中管理依赖的目的 Lerna A tool for managing JavaScript projects with multiple packages. Lerna 是希腊神话里一多头怪物，估计作者想他多头处理多个包 在我们上面项目的基础上，根目录添加lerna，yarn add -D -W lerna，-W表示跟在本项目的 workspace 里直接安装，即根目录 npx lerna init packages\\common\\package.json 和 packages\\server\\package.json 均加上test命令 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo testing server with version: $npm_package_version&quot;&#125; 12345678&#123; &quot;packages&quot;: [ &quot;packages/*&quot; ], &quot;version&quot;: &quot;0.0.0&quot;, + &quot;npmClient&quot;: &quot;yarn&quot;, + &quot;useWorkspaces&quot;: true&#125; 如果要执行单个 package.json 里的命令，则需加上 --scope=@包名，如 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;lerna run test --scope=@mono-repo-by-yarn-lerna/common&quot;&#125; 如指定多个模块，只需放在&#123;&#125;里，如： 123&quot;scripts&quot;: &#123; &quot;test-since&quot;: &quot;lerna run test --scope=&#123;@mono-repo-by-yarn-lerna/common,@mono-repo-by-yarn-lerna/server&#125;&quot;&#125; lerna version 发布版本接上面，用 new-version 命令进行发版，执行的是 lerna version。后面的参数 convential commits 是一个用于优化 git commit 内容的库，可以添加commits标题正文注脚什么的，挺有趣，vs code 里也有同名的插件 test 脚本加上 --since 参数可以看到提交版本的历史： 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;lerna run test --since&quot;&#125;","categories":[],"tags":[{"name":"mono repo","slug":"mono-repo","permalink":"https://zyzy.info/tags/mono-repo/"},{"name":"yarn","slug":"yarn","permalink":"https://zyzy.info/tags/yarn/"},{"name":"lerna","slug":"lerna","permalink":"https://zyzy.info/tags/lerna/"},{"name":"conventional commit","slug":"conventional-commit","permalink":"https://zyzy.info/tags/conventional-commit/"}]},{"title":"esbuil用于create-react-app项目的热更新开发","slug":"【2021-10-28】用esbuil创建React项目","date":"2021-10-28T06:53:06.000Z","updated":"2023-10-29T16:23:18.778Z","comments":true,"path":"2021/10/28/【2021-10-28】用esbuil创建React项目/","link":"","permalink":"https://zyzy.info/2021/10/28/%E3%80%902021-10-28%E3%80%91%E7%94%A8esbuil%E5%88%9B%E5%BB%BAReact%E9%A1%B9%E7%9B%AE/","excerpt":"webpack 用于大型项目中，特别是开发时候的热更新，速度太慢，原因是webpack 采用了整个项目所有文件一起打包的方案。 自从 vite 推出以来，打包这块做到了性能上的超越。vite 的原理是在SPA项目中，基于入口文件打包的，由于只打包一个文件，所以速度就上来了。 而无论是 vite 和 webpack 均是基于 esbuild 开发的。所以研究一下 esbuild 的配置是比较有价值的。 本项目是基于 create-react-app 创建项目，再用 es-build 作为开发热更新打包。","text":"webpack 用于大型项目中，特别是开发时候的热更新，速度太慢，原因是webpack 采用了整个项目所有文件一起打包的方案。 自从 vite 推出以来，打包这块做到了性能上的超越。vite 的原理是在SPA项目中，基于入口文件打包的，由于只打包一个文件，所以速度就上来了。 而无论是 vite 和 webpack 均是基于 esbuild 开发的。所以研究一下 esbuild 的配置是比较有价值的。 本项目是基于 create-react-app 创建项目，再用 es-build 作为开发热更新打包。 不改动CRA生成的基础结构下的改动用 create-react-app 生成项目后，然后对原来的项目作了如下改动： 生成 devBuild.js 文件，进行如下改动： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import browserSync from &quot;browser-sync&quot;;import chalk from &quot;chalk&quot;;import commandLineArgs from &quot;command-line-args&quot;;import del from &quot;del&quot;;import esbuild from &quot;esbuild&quot;;import getPort from &quot;get-port&quot;;import svgrPlugin from &quot;esbuild-plugin-svgr&quot;;// 创建服务器。const bs = browserSync.create();// 解构环境变量const &#123; dev &#125; = commandLineArgs(&#123; name: &quot;dev&quot;, type: Boolean &#125;);// 删除文件夹 public 中的打包文件夹del.sync(&quot;./public/dist&quot;);// 开始 esbuild 打包(async () =&gt; &#123; const buildResult = await esbuild .build(&#123; format: &quot;esm&quot;, // 设置生成的 JavaScript 文件的输出格式。 target: &quot;es2017&quot;, // 编译转化版本 entryPoints: [&quot;./src/index.jsx&quot;], // 打包入口 outdir: &quot;./public/dist&quot;, // 输出目录 chunkNames: &quot;chunks/[name].[hash]&quot;, // 打包出来的文件名 incremental: dev, // 因为我们监听文件的改变重新打包，而且我们要开发环境使用esbuild 所以 dev 为 true loader: &#123; // 此选项更改给定输入文件的解释方式。 &quot;.svg&quot;: &quot;text&quot;, &quot;.png&quot;: &quot;dataurl&quot;, &#125;, bundle: true, // 捆绑文件意味着将任何导入的依赖项内联到文件本身中。 splitting: true, // 代码拆分目前仅适用于esm输出格式。 plugins: [svgrPlugin()], inject: [&quot;./public/react-shim.js&quot;], // 将 React 作为全局变量导入esbuild &#125;) .catch((err) =&gt; &#123; console.error(chalk.red(err)); process.exit(1); &#125;); console.log(chalk.green(&quot;The build has finished! 📦\\n&quot;)); // 获取可以使用的端口号 const port = await getPort(&#123; port: getPort.makeRange(4000, 4999), &#125;); console.log( chalk.cyan( `Launching the Shoelace dev server at http://localhost:$&#123;port&#125;! 🥾\\n` ) ); // 服务器初始化 bs.init(&#123; startPath: &quot;/&quot;, // 初始路径 port, // 端口号 logLevel: &quot;silent&quot;, // 日志级别 logFileChanges: true, // 日志文件更改 notify: true, // 浏览器中的小弹出通知 single: true, // 提供单独的 index.html server: &#123; baseDir: &quot;public&quot;, // 基础文件夹 index: &quot;index.html&quot;, // 设置服务器的入口文件 &#125;, files: &quot;src/&quot;, // 监听 src 下的文件 &#125;); // 监听 src 文件夹下的更改 bs.watch([&quot;src/&quot;]).on(&quot;change&quot;, async (filename) =&gt; &#123; console.log(`Source file changed - $&#123;filename&#125;`); // 重新打包 buildResult.rebuild(); &#125;);&#125;)(); 依赖安装： 核心: esbuild,esbuild-plugin-svgr用于创建服务渲染打包文件： browser-sync解析命令行参数: command-line-args打包文件删除：del获取当前可用端口：get-port美化：chalk package.json 的 script 增加了 dev 命令，为跑 devBuild.js 文件 package.json 增加了 &#123;&quot;type&quot;: &quot;module&quot;&#125; 让 node 可以编译 esm 语法 将 public/index.html 文件增加如下： 123456...&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./dist/index.css&quot; /&gt;...&lt;script type=&quot;module&quot;&gt; import &#x27;./dist/index.js&#x27;&lt;/script&gt; 增加 public/react-shim.js 文件，并在 devBuild.js写入相应配置，在src中就不用到处引入React了： 12import * as React from &#x27;react&#x27;export &#123; React &#125; 源码在这里","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zyzy.info/tags/React/"},{"name":"esbuild","slug":"esbuild","permalink":"https://zyzy.info/tags/esbuild/"},{"name":"webpack","slug":"webpack","permalink":"https://zyzy.info/tags/webpack/"}]},{"title":"Web性能优化（最后更新时间：2021-10-26）","slug":"【2021-05-30】Web性能优化（持续更新）","date":"2021-10-26T09:38:14.000Z","updated":"2023-10-29T16:23:18.776Z","comments":true,"path":"2021/10/26/【2021-05-30】Web性能优化（持续更新）/","link":"","permalink":"https://zyzy.info/2021/10/26/%E3%80%902021-05-30%E3%80%91Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%EF%BC%89/","excerpt":"本文根据这篇文章：Best Practices for Speeding Up Your Web Site，被称作”雅虎35条军规”，虽里面有的东西虽说也已经过时，但可以由此窥探前端发展的历程，一些过时的建议会略去解释。","text":"本文根据这篇文章：Best Practices for Speeding Up Your Web Site，被称作”雅虎35条军规”，虽里面有的东西虽说也已经过时，但可以由此窥探前端发展的历程，一些过时的建议会略去解释。 一道面试题引发的前端性能优化思考相信大家都碰过这道经典面试题：在浏览器输入url到看到页面的展示，这中间发生了什么？ 总体答案是这样： 浏览器输入域名（Domain） ——&gt; DNS服务器解析成IP地址 （如：12.220.12.123） 通过局域网 ——&gt; 交换机 ——&gt; 路由器 ——&gt; 主干网 ——&gt; 服务端 建立TCP连接 服务器接收请求，查库，读文件等， 拼接好response，即返回的HTTP响应 浏览器收到首屏html页面，开始渲染 解析 html 为 DOM-tree 解析 CSS 为 CSS-tree DOM-tree + CSS-tree 生成 render-tree 绘图 根据页面节点的改变，样式的改变等，发生重绘与回流 所谓的性能优化，就是上面的步骤加在一起，时间尽可能短，所以在这个过程种3点关键的优化因素： 减少http请求，缩小http请求大小 减少静态文件大小 减少渲染 大概优化点，实际工作种还要结合场景才能做出优化： DNS 通过缓存减少DNS查询时间 网络请求过程走最近的网络环境 相同静态资源是否可缓存 减小http请求大小 减少http请求 服务的渲染 网页性能检测工具首先应明确检测网页所需的工具，这里列举了3种方法： 谷歌推出的性能检测网站web.dev从三个指标对网站性能进行评估 Largest Contentful Paint (LCP) ：最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的2.5 秒内发生。 First Input Delay (FID) ：首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为100 毫秒或更短。 Cumulative Layout Shift (CLS) ：累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1. 或更少。 该网站可以输入网址后进行测试，给出一份详细的 lighthouse 报告 Navigator.sendBeacon() 埋点传输数据给服务器记录时间依据google以上3原则，可以在前端进行埋点，进行统计 12345678910import &#123; getCLS, getFID, getLCP &#125; from &#x27;web-vitals&#x27;function sendToAnalytics(metric) &#123; const body = JSON.stringify(metric); navigator.sendBeacon(&#x27;/analytics&#x27;, body))&#125;getCLS(sendToAnalytics);getFID(sendToAnalytics);getLCP(sendToAnalytics); window.performance打开任意网页，控制台输入以下代码，可以看到 window.performance 所获取到的东西，我们主要看他的timing属性，用开始时间减去结束时间得出各种资源加载的时间。以下的数值都算是比较粗略的数值 12345678const t = window.performance.timing;console.log(&#123; &quot;DNS&quot;: t.domainLookupEnd - t.domainLookupStart, &quot;TCP&quot;: t.connectEnd - t.connectStart, &quot;获得首字节耗费时间，TTFB&quot;: t.responseStart - t.navigationStart, &quot;domReady时间&quot;: t.domContentLoadedEventStart - t.navigationStart, &quot;DOM资源下载&quot;: t.responseEnd - t.responseStart&#125;) 第一字节响应时间（TTFB）= 从发送请求到WEB服务器的时间 + WEB服务器处理请求并生成响应花费的时间 + WEB服务器生成响应到浏览器花费的时间 第一字节响应时间（TTFB）要考虑的问题：步骤1：从发送请求到WEB服务器的时，即向站点地址提交首次请求 DNS 响应时间（终端用户侧解析 DNS 请求有多块） 网站服务器到终端用户的距离，越短越好 网络稳定性 步骤2：WEB服务器处理请求并生成响应花费的时间，即由 web 服务器解析本次请求 物理硬件响应时间 （web 服务器解析请求有多快） 既有的服务器操作负载 数据中心任何网络相关的延迟 步骤3：WEB服务器生成响应到浏览器花费的时间， 即向客户端发送首个响应的时间 终端用户的网速 连接稳定性 Chrome自带的performance检测工具自动化检测利器—— lighthouse —— 自动生成网页性能报告，并有优化建议符合谷歌的 PWA 标准的检测，关于PWA的概念，点击这里 方法一，直接安装 npm 库 1npm i -g lighthouse 使用起来超级简单 1lighthouse &lt;需要测试的网页链接&gt; 方法二，浏览器也自带 lighthouse 功能，以下是 Edge 浏览器 浏览器的重绘与回流资源合并与压缩：现代化的前端跑不掉资源压缩这一步，平时工程化用的 webpack 就是一款压缩工具 HTML压缩原理：将HTML里的空格，换行符，制表符等去掉 方法： node作为构建工具，提供了 html-minifier 工具，webpack的 HTMLMinifierWebpackPlugin 中内置了该构建工具 后端模板引擎渲染压缩，如ejs模板，express 的 renderFile() CSS压缩原理： 除了像HTML一样删除空格，换行符等之外 删除无效代码 css语义合并 方法： html-minifier 可以对html中的内联css样式进行压缩，需配置其中的选项 clean-css 对 css 的压缩 Webpack 的 CssMinimizerWebpackPlugin JS压缩与混乱原理： 删除无效字符 删除注释 代码语义化的缩减和优化 代码保护 方法： html-minifier 可以对html中的js进行压缩，需配置其中的选项 uglifyjs3 JS文件合并如果不合并请求会有以下影响 但合并请求也不是万能的，其缺点体现在： 首屏渲染的问题现在的前端都用类似react或者vue等前端框架，如果使用vue或者react没有进行服务端渲染的操作，而且服务端合并请求的JS文件又比较大，那么请求回来的JS加载完成后，才会执行react或vue的框架代码在客户端加载渲染，那么首屏白屏的时间就会比较久 缓存失效的问题现在的打包用webpack都会加上md5戳，用于标识单个js文件是否发生改变，如果JS合并了，就会使原先的md5戳失效，就得重新加载 针对合并带来的负面效果，应遵循以下原则： 公共库合并公共库代码比较少做频繁变动，应单独打包为一个js文件，和业务代码的js文件分开，避免公共库的缓存失效 不同页面的合并这种发生在vue或react的单页面应用，通常我们打包出来的单页应用只有一个js文件，但这种方法在效率提升来说有阻碍，最好的方法是每个页面打包为一个js文件，当某页面被路由到加载到时，才去加载对应页面的js文件，这种方式在webpack中有相应的解决方案，就是 loadable 异步加载组件 传输方面：CDN缓存http2充分利用HTTP缓存压缩html，js，css文件体积，用gzip/brotli对 JS、CSS、HTML 等文本资源均有效，但是对图片效果不大。 gzip 通过 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。 brotli 通过变种的 LZ77 算法、Huffman 编码及二阶文本建模来压缩文件，更先进的压缩算法，比 gzip 有更高的性能及压缩率 可在浏览器的 Content-Encoding 响应头查看该网站是否开启了压缩算法，目前知乎、掘金等已全面开启了 brotli 压缩。 12345678# Request HeaderAccept-Encoding: gzip, deflate, br# gzipContent-Encoding: gzip# gzipContent-Encoding: br 压缩混淆工具 terser swc html-minifier-terser JS压缩 上述提到的 gzip/brotli 和 terser webpack 打包 webpack-bundle-ananlyze分析打包体积 使用一些更小体积的库，如 moment -&gt; dayjs 一些库进行按需加载，如 import lodash -&gt; import lodash-es 雅虎35条的链接， 从中挑出一些点来讲，如下：Image *之所以把图片放在最前，因为优化图片的效率是比较大的 Optimize Images * 图片优化 各种图片格式的应用场景： 1.1 png 大部分需要使用透明的场景 pngcrush 或其他工具压缩png。在线压缩工具 https:/ tinypng.com/ 1.2 jpg 大部分不需要透明的场景 jpegtran或其它工具压缩jpeg，大图用jpg 1.3 SVG矢量图，类似XML语法，内嵌在html里的代码图片（用来绘制地图，股票K线图等），可使用 阿里的iconfont 解决icon问题 SVG的教程 例如画一个长方形： 1234567&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,255);stroke-width:1; stroke:rgb(0,0,0)&quot; /&gt;&lt;/svg&gt; 1.4 Webp 可全用 google在2010年开发的一种全能的图片，但safari浏览器 和 webview 的兼容性不太好 1.5 png ——&gt; Webp 格式网站：智图 webp 比 jpeg/png 更小，而 avif 又比 webp 小一个级别 为了无缝兼容，可选择 picture/source 进行回退处理 12345&lt;picture&gt; &lt;source srcset=&quot;img/photo.avif&quot; type=&quot;image/avif&quot;&gt; &lt;source srcset=&quot;img/photo.webp&quot; type=&quot;image/webp&quot;&gt; &lt;img src=&quot;img/photo.jpg&quot; width=&quot;360&quot; height=&quot;240&quot;&gt;&lt;/picture&gt; Image inline，即将图片内容内嵌到html里，减少网站的HTTP请求数量，多用于移动端和小图标： 如何将图片转换为base64编码内嵌到html中，有一个在线转换网站，在html文件图片所在的src=””中添加data:image/jpg;base64,（注：这里是jpg格式，你可以改写成你编码图片的类型），将你编码的Base64代码复制到image/jpg;base64, 的后面，然后用浏览器运行即可。 当然还可以像taobao主页一样，嵌入到css的属性中使用： Optimize CSS Sprites实际上，随着带宽的普遍提高，现在不少网站都不用雪碧图了，特别是PC端，移动端用的还相对比PC端多些。但仍有网站在使用他。而雪碧图在应用上也有缺点，如果过多图标集合在一个图的话，则会出现如果该图片请求后读取不出，所有应用到该图片的图标全部会失效 Arranging the images in the sprite horizontally as opposed to vertically usually results in a smaller file size. Combining similar colors in a sprite helps you keep the color count low, ideally under 256 colors so to fit in a PNG8. “Be mobile-friendly” and don’t leave big gaps between the images in a sprite. This doesn’t affect the file size as much but requires less memory for the user agent to decompress the image into a pixel map. 100x100 image is 10 thousand pixels, where 1000x1000 is 1 million pixels 雪碧图最好竖放，避免横放，达到最小尺寸 相似图片合并，颜色相近的合并，颜色数会更少 移动端的雪碧图减少空隙 雪碧图的生成，用这个网站 选择器性能内联样式 (style=””) &gt; ID 选择器 (id) &gt; 类选择器 (class) = 属性选择器 ( a[href], input[type=”text”] 等 ) = 伪类选择器 (nth-child(n), :hover, :active 等) &gt; 元素（类型）选择器 = 伪元素选择器 Do Not Scale Images in HTML If you need &lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt;then your image (mycat.jpg) should be 100x100px rather than a scaled down 500x500px image. 不要在HTML中缩放图片，如果你需要 &lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 的图片，直接做一张 100*100 的图即可，而不是拿一张 500*500 的图片进行缩放 Make favicon.ico Small and Cacheable使得 favicon.ico 图片可以缓存，如果不进行缓存，不关心他，浏览器还是会请求他 ContentMake Fewer HTTP Requests *减少 HTTP 请求 Reduce DNS Lookups减少DNS查询 Avoid Redirects *避免重定向 Postload Components * 懒加载组件图片进入可视区域后再请求图片资源。适用于电商等图片很多，页面很长的业务场景减少无效资源的加载并发加载的资源过多会阻塞js的加载，影响网站正常使用 案例可以看我的另一篇文章，关于JS IntersectionObserver Api，可以这个将这个api用于懒加载 下面结合react 写一个懒加载案例 123456789101112131415161718192021222324252627282930313233343536373839import React from &#x27;react&#x27;import &#x27;./Lazyload.css&#x27;import &#123; v4 as uuidv4 &#125; from &#x27;uuid&#x27;/* 总体思路：1. 先创建图片占位符2. 创建 IntersectionObserver 对象监听这些图片占位符*/const refs = [] // 图片的 ref（操作dom时用）const images = []for (let i=0; i&lt;4; i++) &#123; const ref = React.createRef() refs.push(ref) images.push(&lt;div className=&#x27;image-box&#x27; key=&#123;uuidv4()&#125;&gt; &lt;img ref=&#123; ref &#125; data-src=&#123;`https://pschina.github.io/src/assets/images/$&#123;i&#125;.jpg`&#125; /&gt; &lt;/div&gt;)&#125;const LazyLoadPage = ()=&gt;&#123; const io = new IntersectionObserver( entries =&gt;&#123; entries.forEach((item)=&gt;&#123; if (item.intersectionRatio &lt;= 0 ) return // intersectionRatio 是可见度 如果当前元素不可见就结束该函数。 item.target.src = item.target.dataset.src &#125;) // [0.01] 这是触发时机 0.01代表出现 1%的面积出现在可视区触发一次回掉函数 // threshold = [0, 0.25, 0.5, 0.75] 表示分别在0% 25% 50% 75% 时触发回掉函数 &#125;, [0.01] ); const onload = ()=&gt; refs.forEach( i =&gt; io.observe(i.current) ) return &lt;div className=&#x27;box&#x27;&gt; &#123;images&#125; &lt;img onError=&#123;onload&#125; src=&quot;&quot; /&gt; &lt;/div&gt;&#125;export default LazyLoadPage Preload Components * 预加载组件方法一，加载时另 display 为 none 1&lt;img src=&quot;http://xxx.xxx&quot; style=&quot;display: none&quot; /&gt; 方法二，利用 new Image() 12var img = new Image()img.src = &#x27;http://xxx.xxx/&#x27; 方法三，XHLHttpRequest 对象，这种方法有跨域问题 12345678910111213141516171819var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callbackxmlhttprequest.onprogress = progressCallbackxmlhttprequest.open(&#x27;GET&#x27;, &#x27;http://image.baidu.com/mouse.jpg&#x27;, true)xmlhttprequest.send()function callback () &#123; if (xmlhttprequest.readyState == 4 &amp;&amp; xmlhttprequest.status == 200 ) &#123; var reponseText = xmlhttprequest.responseText &#125;else&#123; console.log(&#x27;Request was unsuccessful:&#x27; + xmlhttprequest.status) &#125;&#125;function progressCallback (e) &#123; e = e || event if ( e.lengthComputable) console.log(`Receievd $&#123;e.loaded&#125; of $&#123;e.total&#125; bytes`)&#125; 方法四，使用库 PreloadJS 进行预加载 12345678910111213var queue = new createjs.LoadQueue(false)queue.on(&#x27;complete&#x27;, handleComplete, this)queue.loadManifest([ &#123;id: &#x27;myImg&#x27;, src:&#x27;http://pic26.nipic.com/20121213/6168183_004444903000_2.jpg&#x27;&#125;, &#123;id: &#x27;myImg2&#x27;, src:&#x27;http://pic9.nipic.com/20100814/2839526_193147158170_2.jpg&#x27;&#125;,])function handleComplete () &#123; var img = queue.getResult(&#x27;myImg&#x27;) document.body.appendChild(img)&#125; Server 服务端优化Use a Content Delivery Network (CDN) *CDN，内容分发网络，用于静态资源的加载，选择离用户近的服务器节点，节省物理上的距离，让资源到达用户的物理距离缩短 那么请求CDN内容时，如果请求头携带cookie是没用的，所以请求CDN时，cookie最好去掉，CDN的域名如果和主站域名一样，就会携带Cookie过去，所以找CDN时最好不要和主站的域名一样 例如淘宝的页面，直接在头部加DNS script标签即可。 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//g.alicdn.com&quot; /&gt; Add Expires or Cache-Control Header * There are two aspects to this rule: For static components: implement “Never expire” policy by setting far future Expires &gt; header For dynamic components: use an appropriate Cache-Control header to help the browser &gt; with conditional requests 雅虎建议将 Expires 字段用于所有组件，不单止于图片： Expires headers are most often used with images, but they should be used on all components including scripts, stylesheets, and Flash components. 静态文件，请求头可以设置永不过期或者把时间设置的长一些 1234expires: never# orExpires: Thu, 15 Apr 2099 20:00:00 GMT 对于动态组件，利用请求头的Cache-Control 控制，例如 1cache-control: max-age&#x3D;2592000 Cache-Control的值有以下几种情况： no-cache 直接要服务的新内容，不拿缓存的no-store 不缓存请求或响应的任何内容max-age 响应的最大Age值min-fresh 期望在指定时间内的响应扔有效only-if-chache 从缓存获取资源max-stale 接收已过期响应min-fresh 期望在指定时间内的响应仍有效no-transform 代理不可更改媒体类型cache-extension 新指令标记（token） 其中，最常用的是 no-cache，no-store，max-age 3个值 Gzip Components *网页中重复的内容，会用Gzip压缩，显著减少文件大小，在 Nginx 里有Nigix配置Gzip的介绍 请求头中添加： 1Accept-Encoding: gzip, deflate 相应头中添加： 1Content-Encoding: gzip Configure ETags Entity tags (ETags) are a mechanism that web servers and browsers use to determine whether the component in the browser’s cache matches the one on the origin server. ETags 是一种机制，用来确定浏览器的缓存内容和服务器的是否匹配，如匹配，则用浏览器的内容，如不匹配，则请求服务器新的内容 请求时的头部字段： 12Last-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot; 响应的头部字段： 123If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified Browser Storage * 浏览器存储优化Reduce Cookie Size * Eliminate unnecessary cookiesKeep cookie sizes as low as possible to minimize the impact on the user response &gt; timeBe mindful of setting cookies at the appropriate domain level so other &gt; sub-domains are not affectedSet an Expires date appropriately. An earlier Expires date or none removes the cookie sooner, improving the user response time Cookie是请求头的一个字段，如果存储的信息过多过大，必然会影响性能，减少Cookie体积大小，只存储用户id等简单信息 设置合适的 expire 字段让cookie过期 设置cookie时，应注意设置头部字段 Set-Cookie：httponly，只允许http通信，这样才不会被js篡改 cookie由于是种在域名下的，请求头的一个字段，所以单独带在域名中会造成CDN的流量产生不必要的损耗，解决方法是 CDN域名和主站域名独立开来 LocalStorage * HTML5专门设计出来用于浏览器存储的 大小为5Mb左右，比cookie的4kb大很多 不进行通信 接口封装相较于cookie较好 浏览器本地缓存方案 SessionStorage * 会话级别的浏览器存储 大小5M左右 不进行通信 接口封装相 对于表单信息的维护，关闭浏览器的标签页，SessionStorage会自动清空优化点： 例如用户注册页面，需要填写很多东西，如果用户还没提交但刷新了该页面，用户体验会不好 而此时可将用户所填的信息存储到SessionStorage里，用户刷新页面时，所填写的东西也不会清空。 IndexDB 是一种低级API，用于客户端存储大量结构化数据。说白了，就是浏览器的数据库 使用的网站较少 Service Worker * Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。 使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 有拦截和处理网络请求的能力，所以必须使用 HTTPS 协议来保障安全。 简单点说，就是缓存js文件到浏览器里，让客户端有大量处理js的能力。 例如，现在的Three.js 或 WebGL可以用于3D的渲染，但3D图的js脚本及数据占用资源比较多，一个脚本可达几Mb，可以用Service Worker将其缓存起来执行。 利用拦截和处理网络请求的能力，可以实现离线应用功能。 检查工具：在chrome浏览器输入chrome://serviceworker-internals/ 检查所有 service worker chrome://inspect/#service-workers 检查正在运行的 service worker Progressive Web Apps 渐进式 Web 应用 PWA 标准由 谷歌提出的移动端的标准。例如，在移动端的弱网环境下，你站点的加载速度。离线环境下，能不能有基本的页面访问 可靠：在没有网络环境中也能提供基本的页面访问 快速：因为Web App是一个增量加载的过程，不同于iOS或者安卓的原生开发，Web App加载必受到网络条件的制约 融入（Engaging）：将其能力对标原生APP，应用可以被添加到手机桌面，并和普通应用一样有全屏，推送等特性 CSSCSS是存在CSS阻塞的， css 如果在 head 中以 link 方式引入会阻塞页面的渲染 css 阻塞js的执行 但 css 不阻塞外部脚本的加载 Put Stylesheets at Top * While researching performance at Yahoo!, we discovered that moving stylesheets to the document HEAD makes pages appear to be loading faster. This is because putting stylesheets in the HEAD allows the page to render progressively. 将样式表放在头部，可以让页面逐步呈现 Choose &lt;link&gt; Over @import In IE @import behaves the same as using at the bottom of the page, so it’s best not to use it. 在IE浏览器中 @import 和 &lt;link&gt; 是一样的，位于底部执行，这和我们推荐的CSS放在HEAD中执行背道而驰，所以少用 @import JavaScriptJS 阻塞 直接引入js阻塞页面的渲染，所以才有后面 js不阻塞资源加载 js按顺序执行，阻塞后续js逻辑执行 Put Scripts at Bottom * The problem caused by scripts is that they block parallel downloads. While a script is downloading, however, the browser won’t start any other downloads, even on different hostnames. JS的加载本身就是一种阻塞，所以尽量让HTML+CSS先把页面渲染出来，再执行 底部的&lt;script&gt;&lt;/script&gt; 标签 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Make JavaScript and CSS External if the JavaScript and CSS are in external files cached by the browser, the size of the HTML document is reduced without increasing the number of HTTP requests. (除了主页) 使用CSS或JS的外部链接，浏览器会缓存 JavaScript 和 CSS 文件，而不会增加 HTTP 请求数。 12&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/xxx.min.css&quot;&gt;&lt;script nonce=&quot;b3/zKeoFCfru0lTFQr8Dyg==&quot; src=&quot;https://s.yimg.com/ss/rapid-3.41.3.js&quot;&gt;&lt;/script&gt; Minify JavaScript and CSS * Minification is the practice of removing unnecessary characters from code to reduce its size thereby improving load times. 最小化 JS 和 CSS，现在我们多用 webpack等打包工具来做到这一步 Minimize DOM Access * Accessing DOM elements with JavaScript is slow so in order to have a more responsive page, you should: Cache references to accessed elements Update nodes “offline” and then add them to the tree Avoid fixing layout with JavaScript 最小化DOM访问，尽可能少的进行DOM操作，这点可以从现在的React Vue等MVVM框架体现出来 渲染优化preload/prefetch dns-prefetchpreload/prefetch 可控制 HTTP 优先级，从而达到关键请求更快响应的目的。 如当页面出现 Link，可 prefetch 当前 Link 的路由资源。 12&lt;link rel=&quot;prefetch&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt; 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//shanyue.tech&quot;&gt; 防抖与节流 防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。代码实现重在清零 clearTimeout。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。 节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。代码实现重在开锁关锁 timer=timeout; timer=null。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。 无论是防抖还是节流都可以大幅度减少渲染次数，在 React 中还可以使用 use-debounce 之类的 hooks 避免重新渲染。 123456789101112131415161718192021import React, &#123; useState &#125; from &#x27;react&#x27;;import &#123; useDebounce &#125; from &#x27;use-debounce&#x27;;export default function Input() &#123; const [text, setText] = useState(&#x27;Hello&#x27;); // 一秒钟渲染一次，大大降低了重新渲染的频率 const [value] = useDebounce(text, 1000); return ( &lt;div&gt; &lt;input defaultValue=&#123;&#x27;Hello&#x27;&#125; onChange=&#123;(e) =&gt; &#123; setText(e.target.value); &#125;&#125; /&gt; &lt;p&gt;Actual value: &#123;text&#125;&lt;/p&gt; &lt;p&gt;Debounce value: &#123;value&#125;&lt;/p&gt; &lt;/div&gt; );&#125; 虚拟列表优化这又是一个老生常谈的话题，一般在视口内维护一个虚拟列表(仅渲染十几条条数据左右)，监听视口位置变化，从而对视口内的虚拟列表进行控制。 在 React中可以用下列库 react-virtualized react-window","categories":[],"tags":[{"name":"面试","slug":"面试","permalink":"https://zyzy.info/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Web性能优化","slug":"Web性能优化","permalink":"https://zyzy.info/tags/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"}]},{"title":"创建自己的node cli","slug":"【2021-10-17】创建自己的node-cli","date":"2021-10-17T14:18:15.000Z","updated":"2023-10-29T16:23:18.778Z","comments":true,"path":"2021/10/17/【2021-10-17】创建自己的node-cli/","link":"","permalink":"https://zyzy.info/2021/10/17/%E3%80%902021-10-17%E3%80%91%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84node-cli/","excerpt":"经常使用create-react-app作为命令行生成项目，总想着自己能配置一个属于自己的命令行工具，很酷炫的样子。最近有时间，终于来实现了","text":"经常使用create-react-app作为命令行生成项目，总想着自己能配置一个属于自己的命令行工具，很酷炫的样子。最近有时间，终于来实现了 初始化项目12mkdir y-cli &amp;&amp; cd y-clinpm init -y 核心步骤 npm link新建一个文件 ./bin/yyt.js，并写一点简单的东西 1234// 这里告诉系统要以node环境执行：#!/usr/bin/env nodeconsole.log(&#x27;hello,node cli!&#x27;) 再在 package.json 里添加 bin 配置，需要指定一个自定义命令，如 y-cli 123&quot;bin&quot;: &#123; &quot;y-cli&quot;: &quot;./bin/yyt.js&quot;&#125; 在命令行里运行： 123npm link# 或者在全局install：npm install . -g 可以看到如下，npm将命令作为软链接连接至对应的js文件 123456789xxx@xxxMBP y-cli % sudo npm linknpm WARN y-cli@1.0.0 No descriptionnpm WARN y-cli@1.0.0 No repository field.up to date in 0.832sfound 0 vulnerabilities/usr/local/bin/yyt -&gt; /usr/local/lib/node_modules/y-cli/bin/yyt.js/usr/local/lib/node_modules/y-cli -&gt; /Users/xxx/Documents/code/y-cli 所用到的库cli需要获取用户的输入，选择并做相应的事情，就需要使用到一些库来帮忙我们更方便的写cli 核心： commander - 处理核心命令 主要模块，在终端输出各种信息全靠这个模块 download-git-repo - 下载git模块 美化： chalk — 美化终端字符显示 figlet — 在终端输出大型字符 inquirer — 命令行参数输入交互 shelljs — 在js文件写命令行 ora - 实行loading效果 让我们来把这些库全部安装一遍 commander根据commander文档的一些参数，我们来编写脚本 yyt.js 12345678#!/usr/bin/env nodeconst program = require(&#x27;commander&#x27;)// 获取package.json中的版本信息program.version(require(&quot;../package.json&quot;).version)// 解析指令，这点很重要 不解析指令则无效program.parse(process.argv) commander自带 -V 和 -h 两个命令，运行 yyt -h可看到： 123456xxx@xxxdeMacBook-Pro y-cli % yyt -hUsage: yyt [options]Options: -V, --version output the version number -h, --help display help for command .option() 加入自定义命令 1program.option(&#x27;-d, --description&#x27;, &#x27;yyt 脚手架简介：。。。。&#x27;) 可以发现已经加上该命令： 1234567xxx@xxxdeMacBook-Pro y-cli % yyt -hUsage: yyt [options]Options: -V, --version output the version number -d, --description yyt 脚手架简介：。。。。 -h, --help display help for command .command() 自定义命令， 基础格式： 1program.option(&#39;hello &lt;param1&gt; [param2]&#39;) 值得注意的是，尖括号&lt;&gt;里的参数是必填参数，方括号[]里的参数是可选参数 利用.command()写一个简单的demo，弄清整个基础流程： 123456789program .command(&#x27;hello &lt;param1&gt; [param2]&#x27;) // 命令里利用.usage()参数化，供后面的.action()回调使用： .usage(&#x27;&lt;command&gt; &lt;param1&gt; [param2]&#x27;) // 回调处理： .action((param1, param2)=&gt;&#123; console.log(param1); console.log(param2); &#125;) 12345678ziyouzhiyi@ziyouzhiyideMacBook-Pro y-cli % yyt helloerror: missing required argument &#x27;param1&#x27;ziyouzhiyi@ziyouzhiyideMacBook-Pro y-cli % yyt hello t tundefinedziyouzhiyi@ziyouzhiyideMacBook-Pro y-cli % yyt hello t yty 上面这些参数也可通过.option()来实现，但需要加上-，如-react，如以下的例子，利用参数创建项目： 12345678910111213141516program.command(&#x27;create &lt;projectName&gt;&#x27;) .option(&#x27;-react&#x27;) .option(&#x27;-vue&#x27;) .action((projectName, option) =&gt; &#123; const type = Object.keys(option)[0] switch(type) &#123; case &quot;Vue&quot;: console.log(&quot;创建vue项目&quot;) break; case &quot;React&quot;: console.log(&quot;创建react项目&quot;) break; default: console.log(&quot;未添加参数，不能下载&quot;) &#125; &#125;) 执行命令后可以看到打印： 12ziyouzhiyi@ziyouzhiyideMacBook-Pro y-cli % yyt create test -react创建react项目 download-git-repo下载的步骤把他替换成真的仓库，需要用到 download-git-repo 库 把console.log替换成真实的git仓库 1234567891011121314151617... case &quot;React&quot;: download( // 此处应加上 #main 分支名称，否则控制台会显示报错 &#x27;direct:git@github.com:ys558/yyt-template.git#main&#x27;, projectName, &#123; clone: true &#125;, (err, x) =&gt; &#123; // 错误回调： if (err) console.log(err) console.log(`$&#123;projectName&#125; 项目创建成功`) &#125; ) break; default: console.log(&quot;未添加参数，不能下载&quot;)... inquirer👆的步骤下载的仓库是在命令行下直接完成的，如果要像vue一样能让用户输入生成的，可以用该库，我们把代码改造一下，实际上就是在 .action() 的回调中进行处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const questions = [ &#123; type: &#x27;input&#x27;, name: &#x27;projectName&#x27;, message: &#x27;请输入项目名称&#x27;, &#125;, &#123; type: &#x27;list&#x27;, name: &#x27;frameWork&#x27;, message: &#x27;请选择框架&#x27;, default: &#x27;React&#x27;, choices: [&#x27;React&#x27;,&#x27;Vue&#x27;] &#125;,]program .command(&#x27;create&#x27;) .action(() =&gt; &#123; inquirer.prompt(questions) .then((&#123;projectName, frameWork&#125;) =&gt; &#123; switch (frameWork) &#123; case &#x27;React&#x27;: download( &#x27;direct:git@github.com:ys558/yyt-template.git&#x27;, projectName, &#123; clone: true &#125;, (err) =&gt; &#123; // 错误回调： if (err) &#123; console.log(err) return &#125;else&#123; console.log(`$&#123;projectName&#125; 项目创建成功`) &#125; &#125;) break; case &#x27;Vue&#x27;: download( &#x27;direct:git@github.com:ys558/yyt-template.git&#x27;, projectName, &#123; clone: true &#125;, (err) =&gt; &#123; // 错误回调： if (err) &#123; console.log(err) return &#125;else&#123; console.log(`$&#123;projectName&#125; 项目创建成功`) &#125; &#125;) break; default: break; &#125; &#125;) &#125;) 美化chalk，figlet美化终端字体，如 chalk: 123456if (err) &#123; console.log(chalk.bgYellow(err)) return&#125;else&#123; console.log(`$&#123;chalk.bgGrey(projectName)&#125; $&#123;chalk.greenBright(&#x27;项目创建成功&#x27;)&#125;`)&#125; figlet: 1234figlet.defaults(&#123;font: &#x27;Standard&#x27;&#125;)function logo()&#123; console.log(figlet.textSync(&#x27;hi yyt!&#x27;))&#125; ora这是一个比较麻烦的模块，他是 es module 类型的import导入模块，而 node 用的是commonjs 的 require 导入模块，而且须在 package.json 里添加 &#123; &quot;type&quot; : &quot;module&quot; &#125; 才能正常加载，下面贴上相关代码： 123456const spinner = ora(&quot;下载初始化模板中...&quot;)spinner.start()spinner.succeed(`$&#123;chalk.bgGrey(projectName)&#125; $&#123;chalk.greenBright(&#x27;项目创建成功&#x27;)&#125;`)spinner.stop() 完整代码仓库","categories":[],"tags":[{"name":"node cli","slug":"node-cli","permalink":"https://zyzy.info/tags/node-cli/"}]},{"title":"react-ssr服务端渲染","slug":"【2021-08-27】react-ssr服务端渲染","date":"2021-08-27T14:02:07.000Z","updated":"2023-10-29T16:23:18.778Z","comments":true,"path":"2021/08/27/【2021-08-27】react-ssr服务端渲染/","link":"","permalink":"https://zyzy.info/2021/08/27/%E3%80%902021-08-27%E3%80%91react-ssr%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%B8%B2%E6%9F%93/","excerpt":"服务端渲染能解决首屏加载过慢的问题，近年来这是一个趋势，这里写一个react的demo，以免忘了。","text":"服务端渲染能解决首屏加载过慢的问题，近年来这是一个趋势，这里写一个react的demo，以免忘了。 本文涉及的 react api如下： ReactDOM.hydrate(&lt;App /&gt;,document.getElementById(&#39;root&#39;) ReactDOMServer.renderToString(&lt;App/&gt;) 用脚手架初始化项目这部分不解释，用脚手架快速生成一个app ！注意: create-react-app 新版本生成的 App.js 已经没有 import React from &#39;react&#39;，我们必须把它加回来，否则服务端渲染会报错： 123456789101112131415+ import React from &#x27;react&#x27;import &#123; useState &#125; from &#x27;react&#x27;;import &#x27;./App.css&#x27;;function App() &#123; const [count, setCount] = useState(0) return &lt;div className=&quot;App&quot;&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt; setCount(count + 1 )&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;()=&gt; setCount(count-1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt;&#125;export default App; 添加服务端1234yarn add express# 首页须进行打包操作给服务端做渲染：yarn buildmkdir server &amp;&amp; cd server &amp;&amp; touch server.js server\\server.js 1234567891011121314151617181920212223242526272829import express from &#x27;express&#x27;import fs from &#x27;fs&#x27;import path from &#x27;path&#x27;import React from &#x27;react&#x27;import ReactDOMServer from &#x27;react-dom/server&#x27;import App from &#x27;../src/App&#x27;const app = express()app.use(&#x27;^/$&#x27;, (req, res, next) =&gt;&#123; fs.readFile(path.resolve(&#x27;../build/index.html&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.log(err) return res.status(500).send(&#x27;smoe error happened&#x27;) &#125; return res.send(data.replace( &#x27;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#x27;, `&lt;div id=&quot;root&quot;&gt;$&#123;ReactDOMServer.renderToString(&lt;App/&gt;)&#125;&lt;/div&gt;` )) &#125; )&#125;)app.use(express.static(path.resolve(__dirname, &#x27;..&#x27;, &#x27;build&#x27;)))const PORT = 8888app.listen(PORT, ()=&gt;console.log(`listen on PORT $&#123;PORT&#125;`)) 把 express 跑起来 src\\index.js 改造12- ReactDOM.render(&lt;App /&gt;,document.getElementById(&#x27;root&#x27;))+ ReactDOM.hydrate(&lt;App /&gt;,document.getElementById(&#x27;root&#x27;) 添加 babel 让node认识jsx语法1yarn add @babel/preset-env @babel/preset-react @babel/register ignore-styles 在 server 文件夹添加运行 babel 机制执行touch server/index.js node原生的必须用 require 的写法导入模块，如下： 12345678require(&#x27;ignore-styles&#x27;)require(&#x27;@babel/register&#x27;)(&#123; ignore: [/(node_module)/], presets: [&#x27;@babel/preset-env&#x27;, &#x27;@babel/preset-react&#x27;]&#125;)require(&#x27;./server&#x27;) 添加 package.json 里的脚本后再运行 yarn ssr 1&quot;ssr&quot;: &quot;node server/index.js&quot; 我们会发现顺利解析了 jsx 语法： 12345yuyi@home-pc MINGW64 /e/study/code/react-ssr-demo (main)$ yarn ssryarn run v1.22.10$ node server/index.jslisten on PORT 8888","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://zyzy.info/tags/react/"},{"name":"ssr","slug":"ssr","permalink":"https://zyzy.info/tags/ssr/"}]},{"title":"node处理ES6模块及动态模块导入","slug":"【2021-08-14】node处理ES6模块及动态模块导入","date":"2021-08-14T15:08:06.000Z","updated":"2023-10-29T16:23:18.778Z","comments":true,"path":"2021/08/14/【2021-08-14】node处理ES6模块及动态模块导入/","link":"","permalink":"https://zyzy.info/2021/08/14/%E3%80%902021-08-14%E3%80%91node%E5%A4%84%E7%90%86ES6%E6%A8%A1%E5%9D%97%E5%8F%8A%E5%8A%A8%E6%80%81%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5/","excerpt":"本文阐述了两个方面的内容。1. node处理ES6模块，大部分参考了阮一峰老师的文章 2. 动态模块导入","text":"本文阐述了两个方面的内容。1. node处理ES6模块，大部分参考了阮一峰老师的文章 2. 动态模块导入 node（CJS）处理ES6模块（ESM）我们知道node只能通过 require() 加载模块， module.exports输出，是同步操作，这套语法规则称作commonjs，即CJS。 而ES6则是另一套语法规则，ECMA Script Module，简称ESM。通过import加载，export输出，是异步操作。 如果要在node里用上 ESM 语法规则，则得做一些必要的改变： 通过改变文件名。将带有 ESM 语法规则的文件 $\\color{CadetBlue} {后缀名改为 .mjs} $，node则可正常执行。 不改变文件后缀名，$\\color{CadetBlue}在 package.json 里添加 “type”:”module” 。$ 相对的，如果这时想用回 require() 语法，则要把文件后缀名改为cjs。$\\color{red} 但两种语法规则强烈不建议混用。$ CommonJS 模块加载 ES6 模块require() 命令不能加载 ES6 模块，会报错，node里只能使用import()这个方法加载，如 123(async () =&gt; &#123; await import(&#x27;./index.mjs&#x27;)&#125;)() ES6 模块内部可以使用顶层 await命令，导致无法被同步加载。 ES6模块加载 CommonJS 模块import 可以加载CJS模块，不能单独解构加载。这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是module.exports，是一个对象，无法被静态分析，所以只能整体加载。 12345// 正确import packageMain from &#x27;commonjs-package&#x27;;// 报错import &#123; method &#125; from &#x27;commonjs-package&#x27;; 可以改成单一输出项，写成下面这种： 12345678import packageMain from &#x27;commonjs-package&#x27;;const &#123; method &#125; = packageMain;// 或 直接export 时带 &#123; &#125;， node则会认为是一个整体，如：import &#123; method &#125; from &#x27;./other.js&#x27;function method (user) &#123; &#125;export &#123; method &#125; 而 class 则不受 default 关键字限制： 123import DefaultClass from &#x27;./other.js&#x27;export default class DefaultClass &#123; &#125; 两种格式支持模块 如果原始模块是CJS，可以加一个包装层 12import cjsModule from &#x27;./index.js&#x27;export const foo = cjsModle.foo 上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。 你可以把这个文件的后缀名改为.mjs，或者将它放在一个子目录，再在这个子目录里面放一个单独的package.json文件，指明&#123; type: &quot;module&quot; &#125; 另一种做法是在package.json文件的exports字段，指明两种格式模块各自的加载入口。 1234&quot;exports&quot;：&#123; &quot;require&quot;: &quot;./index.js&quot;， &quot;import&quot;: &quot;./esm/wrapper.js&quot; &#125; 上面代码指定require()和import，加载该模块会自动切换到不一样的入口文件。 模块动态导入import 普通同步模块导入：这里开始本篇第二个内容，模块动态导入。这里以ESM写法为例，用node运行在 package.json 文件里加上：&quot;type&quot;: &quot;module&quot; 下面举个简单的翻译的例子来说明， ./tranlate/en-translation.js 12const translations = &#123; HI: &#x27;hello&#x27; &#125;export const enTranslations = translations ./tranlate/sp-translation.js 12const translations = &#123; HI: &#x27;hola&#x27; &#125;export const spTranslations = translations ./locale.js 12345678910111213import &#123;enTranslations&#125; from &#x27;./translate/en-translation.js&#x27;import &#123;spTranslations&#125; from &#x27;./translate/sp-translation.js&#x27;const user = &#123; locale: &#x27;sp&#x27;&#125;let translationsswitch (user.locale) &#123; case &#x27;sp&#x27;: translations = spTranslations break default: translations = enTranslations break&#125;console.log(translations.HI) // hola 运行 node locale.js 可以发现打印出 hola 的内容。 以上是我们平时import的做法，这种是同步的写法，import完后所有的文件会被加载一遍，如果文件一大的话，则会影响效率。 import() 异步模块导入，按需加载，CJS写法：对以上翻译模块的代码进行改动， 由于node里除了 class，函数和{} 均没有 defalut 关键字，所以只能具名进行解构：./locale.js 123456const user = &#123; locale: &#x27;sp&#x27;&#125;import(`./translate/$&#123;user.locale&#125;-translation.js`) .then((&#123; enTranslations=&#123;&#125;, spTranslations=&#123;&#125; &#125;) =&gt; &#123; console.log(spTranslations.HI) &#125;) 此时可以看到控制台打印 hola： 1234567yuyi@home-pc MINGW64 /e/study/code/dynamic-import-module (master)$ npm run l&gt; dynamic-import-module@1.0.0 l E:\\study\\code\\dynamic-import-module&gt; node locale.jshola 我们刚刚改造之前的 switch 函数的 default 分支改写，则用 catch替代：如果传入为找不到的语言，则会默认输出英文的翻译 123456789// 默认只有en和sp，找不到的语言 cn：const user = &#123; locale: &#x27;cn&#x27; &#125; ... // 利用catch替代了switch函数的default分支： .catch(()=&gt; import(&#x27;./translate/en-translation.js&#x27;).then( module =&gt; &#123; console.log(module.enTranslations.HI) // hello &#125;)) import() 的ESM写法：将以上的代码改为在浏览器中的ESM写法，在浏览器中运行，改写如下： locale.html 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 浏览器也得在script标签上仍要规定 type=&quot;module&quot; --&gt; &lt;script type=&quot;module&quot; src=&quot;./loacleEMS.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ./translate/ESM-en-translation.js 12const translations = &#123; HI: &#x27;hello&#x27; &#125;export default translations ./translate/ESM-sp-translation.js 12const translations = &#123; HI: &#x27;hola&#x27; &#125;export default translations ./loacleEMS.js 12345678910111213141516import enTranslations from &#x27;./translate/ESM-en-translation.js&#x27;import spTranslations from &#x27;./translate/ESM-sp-translation.js&#x27;const user = &#123; locale: &#x27;sp&#x27;&#125;let translationsswitch (user.locale) &#123; case &#x27;sp&#x27;: translations = spTranslations break; default: translations = enTranslations break;&#125;console.log(translations.HI) // hola 改写为 import() 方法的 ./loacleEMS.js。值得注意的是，由于ESM export 的关键字属性对所有函数object等都有效，能匿名到处，所以写起来更加简洁 1234567const user = &#123; locale: &#x27;sp&#x27;&#125;import(`./translate/ESM-$&#123;user.locale&#125;-translation.js`) // 可直接解构匿名 default 的值： .then((&#123; default: translations &#125;) =&gt; console.log(translations.HI) // hola ) 这种情况下我们怎么改写 switch-default 分支呢？答案是利用 .catch()，并且我们把 const user = &#123; locale: &#39;sp&#39;&#125; 改写为 const user = &#123; locale: &#39;cn&#39;&#125;，一个文件里没有的语言 12345678910const user = &#123; locale: &#x27;cn&#x27;&#125;import(`./translate/ESM-$&#123;user.locale&#125;-translation.js`)// 将.then() 放置于.catch() 里的回调 import() 之后执行，// 这样，控制台报错找不到 &#x27;cn&#x27;，但程序仍会往下走：.catch(()=&gt; import(&#x27;./translate/ESM-en-translation.js&#x27;) .then( (&#123; default: translations&#125;) =&gt; &#123; console.log(translations.HI) // hello &#125;))","categories":[],"tags":[{"name":"node","slug":"node","permalink":"https://zyzy.info/tags/node/"},{"name":"ES6","slug":"ES6","permalink":"https://zyzy.info/tags/ES6/"},{"name":"ESM","slug":"ESM","permalink":"https://zyzy.info/tags/ESM/"},{"name":"CJS","slug":"CJS","permalink":"https://zyzy.info/tags/CJS/"}]},{"title":"react组件变外控的几种方式：eventEmitter、ref、props_this","slug":"【2021-08-14】react组件变外控的几种方式：eventEmitter、ref、props_this","date":"2021-08-14T14:19:32.000Z","updated":"2023-10-29T16:23:18.778Z","comments":true,"path":"2021/08/14/【2021-08-14】react组件变外控的几种方式：eventEmitter、ref、props_this/","link":"","permalink":"https://zyzy.info/2021/08/14/%E3%80%902021-08-14%E3%80%91react%E7%BB%84%E4%BB%B6%E5%8F%98%E5%A4%96%E6%8E%A7%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F%EF%BC%9AeventEmitter%E3%80%81ref%E3%80%81props_this/","excerpt":"最近很忙，搁了很久没更新了，趁着今天空闲来更新一波。组件外控的好处是能使得React最近解锁了组件传值的新模式，EventEmitter，fb也封装了一个fbemitter的组件，用于fb网站间的传值。用过vue的小伙伴对event emitter肯定不陌生。这里结合react的使用来简单说明一下用法。","text":"最近很忙，搁了很久没更新了，趁着今天空闲来更新一波。组件外控的好处是能使得React最近解锁了组件传值的新模式，EventEmitter，fb也封装了一个fbemitter的组件，用于fb网站间的传值。用过vue的小伙伴对event emitter肯定不陌生。这里结合react的使用来简单说明一下用法。 eventEmitter引入12import &#123; EventEmitter &#125; from &#x27;fbemitter&#x27;;var emitter = new EventEmitter(); 定义事件写两个没有层级关系的组件： 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from &#x27;react&#x27;import &#123; EventEmitter &#125; from &#x27;fbemitter&#x27;export default class EventEmitterDemo extends Component &#123; render() &#123; // 0. 可用于无层级关系组件传值： return &lt;&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;/&gt; &#125;&#125;// 1. 初始化const emitter = new EventEmitter()class Child1 extends Component &#123; state = &#123; show: &#x27;&#x27; &#125; componentDidMount() &#123; // 2. 定义 this.eventEmitter = emitter.addListener( &#x27;event&#x27;, (x,y)=&gt; this.setState(&#123; show: &lt;&gt;&#123;x&#125;,&#123;y&#125;&lt;/&gt; &#125;) ) &#125; render()&#123; return &lt;div&gt; &#123;this.state.show&#125; &lt;/div&gt; &#125;&#125; 发出并触发事件12345678class Child2 extends Component &#123; // 3. 发出事件名称及参数： render()&#123; return &lt;div&gt; &lt;button onClick=&#123;()=&gt; emitter.emit(&#x27;event&#x27;, 12, 22)&#125;&gt;eventEmitter发出，见控制台&lt;/button&gt; &lt;/div&gt; &#125;&#125; 效果 once(eventType, callback)只调用一次的eventEmitter，如： 123456789componentDidMount() &#123; this.eventEmitter = emitter.once( &#x27;event&#x27;, (x,y)=&gt; console.log(x,y) )&#125;emitter.emit(&#x27;event&#x27;, 13); // 10 //再次触发emitter.emit(&#x27;event&#x27;, 12); // 不会输出 remove(eventType) 及 removeAllListeners(eventType)删除事件，一般我们在组件卸载时应该执行remove进行删除，而removeAllListeners则可以一次性删除所有监听事件，如： 123456componentWillUnmount()&#123; // 3. 当组件卸载时要将其删除 this.eventEmitter.remove(); // 或： this.removeAllListeners()&#125; 子组件接收整个父组件this实例，达到子组件控制父组件的目的这种原理类似HOC和装饰器函数，但比HOC写法更简洁明了，直接上代码 12345678910111213141516171819202122export class ByPropsThis extends Component &#123; state = &#123; count: 0&#125; render()&#123; return &lt;&gt; Father count: &#123;this.state.count&#125; &lt;Child thisFrFather=&#123;this&#125; /&gt; &lt;/&gt; &#125;&#125;class Child extends Component &#123; render()&#123; console.log(this.props.thisFrFather.state) return &lt;div&gt; &lt;p&gt;&#123;this.props.count&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt; this.props.thisFrFather.setState((&#123;count&#125;) =&gt; (&#123;count: count + 1&#125;))&#125;&gt; child + &lt;/button&gt; &lt;/div&gt; &#125;&#125; Ref 父控制子的事件1234567891011121314151617181920212223242526272829export class ByRef extends Component &#123; testFunc = null // 自动去寻找 ChildToPlus里的 plus() 函数执行： handleChildPlus = () =&gt; this.testFunc.plus() render()&#123; return &lt;&gt; &lt;button onClick=&#123;this.handleChildPlus&#125;&gt;plus fr father&lt;/button&gt; &#123;/* 整个ChildToPlus都被打上ref标记 */&#125; &lt;ClickToPlus ref=&#123; ref =&gt; this.testFunc = ref &#125; /&gt; &lt;/&gt; &#125;&#125;class ClickToPlus extends Component &#123; constructor(props)&#123; super(props) this.state = &#123;count : 0&#125; &#125; plus = () =&gt; this.setState((&#123; count &#125;) =&gt; (&#123; count: count + 1 &#125;)) render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt; &lt;button onClick=&#123;this.plus&#125;&gt;child +&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://zyzy.info/tags/react/"},{"name":"eventEmitter","slug":"eventEmitter","permalink":"https://zyzy.info/tags/eventEmitter/"}]},{"title":"发布自己的npm-package流程","slug":"【2021-07-07】发布自己的npm-package流程","date":"2021-07-07T01:11:03.000Z","updated":"2023-10-29T16:23:18.777Z","comments":true,"path":"2021/07/07/【2021-07-07】发布自己的npm-package流程/","link":"","permalink":"https://zyzy.info/2021/07/07/%E3%80%902021-07-07%E3%80%91%E5%8F%91%E5%B8%83%E8%87%AA%E5%B7%B1%E7%9A%84npm-package%E6%B5%81%E7%A8%8B/","excerpt":"最近工作需要，需发布自己的npm包，这里写一个简单的demo，做一个简单的记录。","text":"最近工作需要，需发布自己的npm包，这里写一个简单的demo，做一个简单的记录。 1. 注册一个自己的npm账号这个没什么好解释的 2. 建一个github仓库这个没什么好解释的 3. 项目结构12|__&#x2F;package&#x2F;|__&#x2F;test-folder&#x2F; /package 文件夹用于存放我们写的包/test-folder 文件夹用于引用并测试 /package 里的包 编写包 my-package-publish-test 在 /package 里初始化项目 npm init 并写一些关于该 package 的名字，如my-package-publish-test 和描述等东西像写普通文件一样，新建/package/index.js 并写下一些简单功能，如 12const isTest = string =&gt; string === &#x27;test&#x27;module.exports = isTest 4. 通过软链接在本地使用包/package如不上传包到npm，本地使用可以直接使用软链接，可以用于本地调试等工作，方法如下。如要直接上传可跳过该步骤 在当前目录 ./package/ 下运行创建软链接 1npm link 返回 ./test-folder/ 下运行软链接，软链接后的名必须对应 package/package.json 的 &quot;name&quot; 12cd ../test-folder/npm link my-package-publish-test 5. 登录并发布返回 ./package/ 并执行登录，运行 12cd ../package/npm login 输入一些 npmjs.org的用户名密码等，登录npm账号 123456$ npm loginUsername: ys558Password:Email: (this IS public)Email: (this IS public) yuyi.gz@163.comLogged in as ys558 on https://registry.npmjs.org/. ！！如出现以下报错需要登录自己的邮箱是否通过 npmjs.org 的验证邮件 1234567npm ERR! code E403npm ERR! 403 403 Forbidden - PUT http://registry.npmjs.org/my-package-publish-test - Forbiddennpm ERR! 403 In most cases, you or one of your dependencies are requestingnpm ERR! 403 a package version that is forbidden by your security policy.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\yuyi\\AppData\\Roaming\\npm-cache\\_logs\\2021-07-04T12_02_21_879Z-debug.log 最后运行以下命令，即可发布成功属于自己的npm package 1npm publish 发布成功： 1234567891011121314151617$ npm publishnpm notice npm notice package: my-package-publish-test@1.0.0npm notice === Tarball Contents ===npm notice 85B index.jsnpm notice 564B package.jsonnpm notice 21B README.mdnpm notice === Tarball Details ===npm notice name: my-package-publish-testnpm notice version: 1.0.0npm notice package size: 509 Bnpm notice unpacked size: 670 Bnpm notice shasum: 98b90c3ab222a573f0379802cc3d59d43ffcb402npm notice integrity: sha512-Fz/SDMr5vgoAe[...]UD5J4OP0rFtFA==npm notice total files: 3npm notice+ my-package-publish-test@1.0.0 6. 发布具有命名空间的package所谓的命名空间，就是以 @ 开头的包，例如我们熟悉的 @babel/core，一般这种需要创建组织organization，步骤如下： 6.1 在自己的npm页面申请成立一个组织，organization我把几个关键步骤进行了截图，如下 如果有条件可以选择收费的，其实也不贵，一个月也就7美刀，40多软妹币；也可以直接将你的账号转换为组织账号，我这里为了演示，选择免费公开账号第二个选项： 6.2 重新用组织的名进行登录执行 npm login scope=&lt;组织名称&gt; ，用户名也和组织名称一样： 12345$ npm login scope=zyzy-orgUsername: zyzy-orgPassword:Email: (this IS public) yuyi.gz@163.comLogged in as zyzy-org on https://registry.npmjs.org/. 6.3 在发布的包前加上 @组织名将该项目的 package\\package.json 里 &quot;name&quot; 的属性改为如下，前面加个 @zyzy-org/ 123&#123; &quot;name&quot;: &quot;@my-test-package/my-package-publish-test&quot;,&#125; 6.4 运行 npm publish --access=public即可见到发布成功： 1234567891011121314151617$ npm publish --access=publicnpm notice npm notice package: @zyzy-org/my-package-publish-test@1.0.0npm notice === Tarball Contents ===npm notice 69B index.jsnpm notice 574B package.jsonnpm notice 21B README.mdnpm notice === Tarball Details ===npm notice name: @zyzy-org/my-package-publish-testnpm notice version: 1.0.0npm notice package size: 503 Bnpm notice unpacked size: 664 Bnpm notice shasum: ddc493df353964be87f43d14e5f7fd877b7b4c04npm notice integrity: sha512-XFE19u9gFMcI1[...]1/LA3ocSzHZ8Q==npm notice total files: 3npm notice+ @zyzy-org/my-package-publish-test@1.0.0 6.5 新项目初始化时，须运行 npm init scope=zyzy-org7 删除已发布的包1npm unpublish @zyzy-org/my-package-publish-test --force","categories":[],"tags":[{"name":"npm package","slug":"npm-package","permalink":"https://zyzy.info/tags/npm-package/"}]},{"title":"JWT自学笔记","slug":"【2021-06-21】JWT自学笔记","date":"2021-06-21T08:37:49.000Z","updated":"2023-10-29T16:23:18.777Z","comments":true,"path":"2021/06/21/【2021-06-21】JWT自学笔记/","link":"","permalink":"https://zyzy.info/2021/06/21/%E3%80%902021-06-21%E3%80%91JWT%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","excerpt":"JWT是一种跨域鉴权技术，现广泛运用于各大网站，本文结合demo代码简单阐述，本篇的概念部分1到4点搬运了阮大神的这篇文章，第5点结合我自己写的一个Demo来实现具体的JWT业务","text":"JWT是一种跨域鉴权技术，现广泛运用于各大网站，本文结合demo代码简单阐述，本篇的概念部分1到4点搬运了阮大神的这篇文章，第5点结合我自己写的一个Demo来实现具体的JWT业务 1. JWT是什么？JSON Web Token (jwt)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。 简单来说就是用于跨域鉴权。一般来说我们鉴权的过程如下： 1、用户向服务器发送用户名和密码。2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。3、服务器向用户返回一个 session_id，写入用户的 Cookie。4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 上述过程如果单机当然没有问题，如果是集群，或跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。 jwt 就是这种方案的一个代表。 2. JWT的结构我们可以在官网看到他的结构 JWT结构 可以看到分为以下3部分： Header（头部）Payload（负载）Signature（签名） Header 头部1234&#123; &quot;alg&quot;: &quot;PS384&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 以上分别代表 &quot;typ&quot; 表示这个令牌（token）的类型（type） &quot;alg&quot; 表示该token的算法类型，默认为HMAC SHA256（写成 HS256） Payload 负载以下为官方规定的可选字段： iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 注意，这部分是不加密的，是简单的Base64转码过程，所以密文信息不能放在这部分，除非你的文字本身加密过 Signature 签名这部分是对前两部分的签名，防止数据篡改。 需指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 3. JWT使用方法：客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。 1Authorization: Bearer &lt;token&gt; 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。 4. 使用时几个注意点（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 5. Demo 代码 及实际使用场景完整代码可点击标题可见git仓库，下面按照我编写代码的顺序阐述几个注意点， 代码里一些配置的解析 .env 文件中的两个token生成可以按照以下办法，利用node REPL的crypto模块生成： 123456789yuyi@home-pc MINGW64 /e/study/code/2021/jwt-learn (master)$ nodeWelcome to Node.js v14.14.0. Type &quot;.help&quot; for more information.&gt; require(&#x27;crypto&#x27;).randomBytes(64).toString(&#x27;hex&#x27;)&#x27;6dedc49577ebb7c685246241533dc068ee43cba49d01b34d243b6b8924786a69d6637c4335e508343ba4c27a1fec1d2f11ea5eea173bd4af04c0f263a4ee98b5&#x27;&gt; require(&#x27;crypto&#x27;).randomBytes(64).toString(&#x27;hex&#x27;)&#x27;4f3ea9c60d55b2a8a58f559ae76e133353a973708d6575daa10ac4bd28f6314d261a4458703be1333f65eddb29a1b58e21ebe493fede5c198952863f1f97e023&#x27;&gt; 发送请求检测时不需要安装postman，只需在 vs code 上安装神器 REST Client ，不仅可以测普通的接口，最新的 GraphQL 语法也支持，其测试文件以 rest 结尾，如 request.rest dotenv 是个不需要依赖就能读取项目中 .env 文件的配制的库，只需在 文件开始引用即可，如： 12345678910111213// dotenv库引用：require(&#x27;dotenv&#x27;).config()...app.post(&#x27;/login&#x27;, (req,res) =&gt; &#123; // 登录token鉴权 const username = req.body.username const user = &#123; name: username &#125; const accessToken = jwt.sign(user, process.env.ACCESS_TOKEN_SECRET) res.json(&#123; accessToken &#125;)&#125;) 解析及测试主代码 npm run dev-start 把服务跑起后，点击 request.rest 文件的这里下面的位置，这些最基础的功能在 01_base 分支的这些代码就能实现，测试接口返回的正确与否 鉴权部分抽离为单独的中间件函数，02_authenticate_token_modulize 分支的这些代码， 1234567891011function authenticateToken (req, res, next) &#123; const authHeader = req.headers[&#x27;authorization&#x27;] const token = authHeader &amp;&amp; authHeader.split(&#x27; &#x27;)[1] if (token == null) return res.sendStatus(401) jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) =&gt; &#123; if (err) return res.sendStatus(403) req.user = user // 交给下个中间件： next() &#125;)&#125; 将其放入app.get(&#39;/posts&#39;)的第二个参数即可调用： 1234// authenticateToken 为鉴权中间件：app.get(&#x27;/posts&#x27;, authenticateToken, (req, res) =&gt; &#123; res.json(posts.filter(post =&gt; post.username === req.user.name))&#125;) 将鉴权部分，即token的分发，拆分为单独一个模块。集中管理各个路由，包括/login, /logout的token，在后端属于微服务的架构 单独把颁发token这部分内容封装一个单独文件，新建文件 authServer.js 及更新命令 auth 123&quot;scripts&quot;: &#123; &quot;auth-start&quot;: &quot;nodemon authServer.js&quot;&#125;, Refresh Token 上面是正常流程的注册登录所用的token，但实际业务中，Access Token 设置的时间不可能很长，比如说10分钟，而10分钟对于用户体验来说肯定不好，一过期的话就要重新登录，所以大多数业务采用了另一种折中的方案，即多生成一个 Refresh Token，这种的过期时间比较长，例如7天免登录 如果携带 Access Token 访问需要认证的接口时鉴权失败（例如返回 401 错误），则客户端使用 Refresh Token 向刷新接口申请新的 Access Token 如果 Refresh Token 没有过期，服务端向客户端下发新的 Access Token 客户端使用新的 Access Token 访问需要重新认证的接口 下面解析 Refresh Token 的制作过程：authServer.js文件中把生成Token封装成一个函数，并在 app.post(&#39;/login&#39;, (req,res) =&gt; &#123; 里应用 1234567891011121314app.post(&#x27;/login&#x27;, (req,res) =&gt; &#123; const username = req.body.username const user = &#123; name: username &#125; const accessToken = generateAccessToken(user) const refreshToken = jwt.sign(user, process.env.REFRESH_TOKEN_SECRET) refreshTokens.push(refreshToken) res.json(&#123; accessToken: accessToken, refreshToken: refreshToken &#125;)&#125;)function generateAccessToken(user)&#123; return jwt.sign(user, process.env.ACCESS_TOKEN_SECRET, &#123; expiresIn: &#x27;15s&#x27; &#125;)&#125; 再次测试，能看到 Refresh Token 的返回结果，但我们发现直接用/posts 接口请求，会出现 Forbidden 报错： 此时，我们再写多个函数控制 token 更新： 12345678910111213// 这里的 refreshTokenslet refreshTokens = []app.post(&#x27;/token&#x27;, (req, res) =&gt; &#123; const refreshToken = req.body.token if (refreshToken == null) return res.sendStatus(401) if (!refreshTokens.includes(refreshToken)) return res.sendStatus(403) jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET, (err, user) =&gt; &#123; if (err) return res.sendStatus(403) const accessToken = generateAccessToken(&#123; name: user.name &#125;) res.json(&#123; accessToken &#125;) &#125;)&#125;) request.rest 文件添加一个 /token 进行测试，body的 &quot;token&quot; 暂且留空 1234567###POST http:&#x2F;&#x2F;localhost:3001&#x2F;tokenContent-Type: application&#x2F;json&#123; &quot;token&quot;: &quot;&quot;&#125; 进行以下操作，可以看到效果： 但上述的 GET /posts 操作，因 function generateAccessToken(user)&#123; 函数里过期时间只设置了 15秒，所以15秒后，需要 POST /token 重新获得一个 refresh token 才能继续维持登录状态 登出模块 完整代码在这里 1234app.delete(&#x27;/logout&#x27;, (req, res)=&gt;&#123; refreshTokens = refreshTokens.filter( token =&gt; token !== req.body.token) res.sendStatus(204)&#125;) 用 delete 方法，删除 let refreshTokens = [] 里原本存在的 refresh token，再次请求 /posts 时，会发现已经变为 Forbidden 状态","categories":[],"tags":[{"name":"JWT","slug":"JWT","permalink":"https://zyzy.info/tags/JWT/"},{"name":"Token","slug":"Token","permalink":"https://zyzy.info/tags/Token/"}]},{"title":"RenderProps和高阶组件的反向继承","slug":"【2021-06-19】RenderProps和高阶组件的反向继承","date":"2021-06-19T01:53:39.000Z","updated":"2023-10-29T16:23:18.777Z","comments":true,"path":"2021/06/19/【2021-06-19】RenderProps和高阶组件的反向继承/","link":"","permalink":"https://zyzy.info/2021/06/19/%E3%80%902021-06-19%E3%80%91RenderProps%E5%92%8C%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8F%8D%E5%90%91%E7%BB%A7%E6%89%BF/","excerpt":"这两种方法是React里的简单技术，但在具体业务中占有相应的使用场景，十分实用，下面简要的说明一下","text":"这两种方法是React里的简单技术，但在具体业务中占有相应的使用场景，十分实用，下面简要的说明一下 Render Props这是一种简单的技术，官网也有解释，简单理解就是将一个组件里的属性attribute作为jsx语法的实现。如以下代码 1234567891011121314151617181920212223242526272829// 父组件export class RenderPropsDemo extends Component &#123; render()&#123; // 1. render 作为组件 &lt;ToggleRenderProps/&gt; 的属性 // 3. 反向在render的回调函数里解构出子组件的属性出来用 return &lt;ToggleRenderProps render=&#123;(&#123;on, toggle, str&#125;) =&gt; &lt;div&gt; &#123; on &amp;&amp; &lt;h1&gt;Hey zidea&lt;/h1&gt; &#125; &#123; on &amp;&amp; &lt;h2&gt;&#123;str&#125;&lt;/h2&gt; &#125; &lt;button onClick=&#123;toggle&#125;&gt;隐藏/显示&lt;/button&gt; &lt;/div&gt; &#125;/&gt; &#125;&#125;// 子组件：class ToggleRenderProps extends Component &#123; state = &#123; on:false &#125; toggle = () =&gt; this.setState(&#123; on:!this.state.on &#125;) render() &#123; // 2. 在子组件设置render里面的属性： const &#123; render &#125; = this.props; return render(&#123; str: &#x27;hehe&#x27;, on: this.state.on, toggle: this.toggle, &#125;) &#125;&#125; 从上面的例子可以看出，子组件 ToggleRenderProps 仅负责单一的传值和控制值和状态的功能，类似回调函数，把该控制的值回传给父组件 RenderPropsDemo 去使用。 当然属性 render 这词不是固定的 任何被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”. 所以，你可以给属性取任意名字，例如 data 1234567891011121314151617// 父组件export class RenderPropsDemo extends Component &#123; render()&#123; return &lt;ToggleRenderProps data=&#123;(&#123;on, toggle, str&#125;) =&gt; &lt;&gt; ... &lt;/&gt;&#125;/&gt;&#125;&#125;// 子组件：class ToggleRenderProps extends Component &#123; ... render() &#123; return this.props.data(&#123; ... &#125;) &#125;&#125; 父组件还可以写为元素内部的模式，如 123456789export class RenderPropsDemo extends Component &#123; render()&#123; return &lt;ToggleRenderProps&gt; &#123;data=&#123;(&#123;on, toggle, str&#125;) =&gt; &lt;&gt; ... &lt;/&gt;&#125; &lt;/ToggleRenderProps&gt; &#125;&#125; 而子组件调用时，就是另一种概念了，可利用 this.props.children 的react自带api进行回传 123456789101112class ToggleRenderProps extends Component &#123; state = &#123; on:false &#125; toggle = () =&gt; this.setState(&#123; on:!this.state.on &#125;) render() &#123; return this.props.children(&#123; str: &#x27;hehe&#x27;, on: this.state.on, toggle: this.toggle, &#125;) &#125;&#125; 以上两种情况，一种在属性上定义的，类似具名函数，而包裹在元素内部，利用 children 进行调用的，类似匿名函数 Rener Props的应用场景就很广泛了，很多库例如路由库React Router，表单校验formik都用了该方法。 正向代理HOC在说反向代理之前，我们先说说正向代理，正向代理其实就是高阶组件 HOC，我们看看两者的区别：普通HOC，即正向代理，简言之就是把一个组件外面包裹了一层新的组件，使其成为一个新组件关于React的HOC和反向代理也可以参考这篇文章 123456789101112131415161718192021222324// 父组件class AAA extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; num: 111 &#125; &#125; render() &#123; return &lt;div num=&#123;this.state.num&#125;&gt;父组件AAA：&#123; this.state.num &#125;&lt;/div&gt; &#125;&#125;// 子组件// 普通HOC，AAA =&gt; props 这部分，代表了 class AAA及其里面的props属性// 相当于把原来的 AAA 提高了一层状态变成了 HOCconst HOC = function (AAA) &#123; return class extends React.Component &#123; render () &#123; return &lt;div style=&#123;&#123;border: &#x27;solid 1px black&#x27;&#125;&#125;&gt; &lt;AAA &#123;...this.props&#125;/&gt; &lt;/div&gt; &#125; &#125;&#125; 子组件也可改写为函数式写法：12345678// 子组件const HOC = AAA =&gt; props =&gt; &#123; return &lt;div style=&#123;&#123;border: &#x27;solid 1px black&#x27;&#125;&#125;&gt; &lt;AAA &#123;...props&#125;/&gt; &lt;/div&gt;&#125;export const Foo = HOC(AAA) 子组件改为装饰器写法，可以省略一步命名的操作，但实际项目中还需要在babel中单独另行配制装饰器语法12345678910@InheritanceInversionHOCexport const HOC = function (AAA) &#123; return class extends React.Component &#123; render () &#123; return &lt;div style=&#123;&#123;border: &#x27;solid 1px black&#x27;&#125;&#125;&gt; &lt;AAA &#123;...this.props&#125;/&gt; &lt;/div&gt; &#125; &#125;&#125; 反向代理 Inheritance Inversion HOC相对于正向代理，则是继承组件自己本身进行重写将上面的子组件进行重写 1234567891011121314151617181920212223242526272829303132333435363738394041// 父组件，即原来的组件class AAA extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; num: 111 &#125; &#125; componentDidMount() &#123; console.log(&quot;child component Did Mount&quot;) &#125; clickComponent = () =&gt; console.log(&#x27;clickComponent func&#x27;) render() &#123; return &lt;div num=&#123;this.state.num&#125;&gt;父组件AAA：&#123; this.state.num &#125;&lt;/div&gt; &#125;&#125;// 子组件，即反向继承后的组件const IIHOC = AAA =&gt; class extends AAA &#123; constructor(props) &#123; super(props) this.state = &#123; num: 222 &#125; &#125; componentDidMount() &#123; console.log(&#x27;IIHOC componentDidMount&#x27;) this.clickComponent() // 直接调用 this.clickComponent() 即可，无需通过props进行传参 &#125; render()&#123; return &lt;div&gt; &lt;button onClick=&#123;this.clickComponent&#125;&gt;IIHoc点击见控制台，AAA组件的函数clickComponent在控制台执行了&lt;/button&gt; &#123;/* 下面的&lt;AAA /&gt;会显示父组件的num值， 111 */&#125; &lt;div&gt;&lt;AAA /&gt;&lt;/div&gt; &#123;/* 下面的 &#123;super.render()&#125; 为渲染劫持， 会显示本组件里的值，222 */&#125; &lt;h1&gt;&#123;super.render()&#125;&lt;/h1&gt; &lt;/div&gt; &#125;&#125;export const InheritanceInversionHOC = IIHOC(AAA) 反向代理的解析及实际作用 const IIHOC = AAA =&gt; class extends AAA &#123; 中，extends AAA是继承自己 AAA =&gt;本身 当然，AAA =&gt; 的名字AAA是可以任意替换的，如Comp 生命周期函数 componentDidMount() &#123; &#125;，因为是继承于自身，所以无论父子组件的生命周期函数均会执行 子组件里使用父组件的this.clickComponent()，直接使用即可，无需通过 props 进行传参 反向代理这种做法乍一看好像没有具体用途，但实际操作中，我们可用来做一个原来的复杂页面的多人同时开发，在一些在原有代码基础上开发，不能改变原来旧的代码，则可用反向继承实现二次渲染进行开发，能使新的功能独立成一个模块，方便维护","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zyzy.info/tags/React/"},{"name":"HOC","slug":"HOC","permalink":"https://zyzy.info/tags/HOC/"}]},{"title":"Electron配置React或Vue实践（Vue部分待更新）","slug":"【2021-06-08】Electron配置React或Vue实践","date":"2021-06-08T01:28:59.000Z","updated":"2023-10-29T16:23:18.776Z","comments":true,"path":"2021/06/08/【2021-06-08】Electron配置React或Vue实践/","link":"","permalink":"https://zyzy.info/2021/06/08/%E3%80%902021-06-08%E3%80%91Electron%E9%85%8D%E7%BD%AEReact%E6%88%96Vue%E5%AE%9E%E8%B7%B5/","excerpt":"本篇介绍在 Electron 中配置 React 或者 Vue 框架开发，毕竟现在前端多是用框架开发，其实已早有现成的模板配置，自己动手用 Webpack 来搭建能更好的熟悉配置的过程。","text":"本篇介绍在 Electron 中配置 React 或者 Vue 框架开发，毕竟现在前端多是用框架开发，其实已早有现成的模板配置，自己动手用 Webpack 来搭建能更好的熟悉配置的过程。 Electron 基础配置12mkdir &lt;project name&gt; &amp;&amp; cd &lt;project name&gt;npm init -y &amp;&amp; npm install electron@11.1.1 国内直接安装 electron 会比较慢，可以配置淘宝源安装，直接输入： 1npm set registry http://registry.npm.taobao.org 但下载完成后记得改回来npm官方的源，要不然会影响自己 npm 模块的发布： 1npm config set registry https://registry.npmjs.org 可用 npm get registry 查看本地所属的源 项目基础架构package.json 修改改如下： 12345678910111213&#123; &quot;name&quot;: &quot;electron-template&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;Electron + React 配置项目&quot;, &quot;author&quot;: &quot;余翼&quot;, &quot;main&quot;: &quot;./app/main/electron.js&quot;, &quot;scripts&quot;: &#123; &quot;start:main&quot;: &quot;electron ./app/main/electron.js&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;electron&quot;: &quot;^13.1.1&quot; &#125;&#125; 创建目录结构如下： 123456electron-template |__app |__main # 主进程文件夹，即跑起 Electron 的进程，只有一个， 控制浏览器窗口的操作等 |__electron.js |__index.html |__renderer # 渲染进程文件夹，即渲染页面的进程，前端的界面的js文件,可以有多个文件 让我们修改以下两个文件： 用于启动Electron的窗口：app\\main\\electron.js 12345678910111213141516171819const path = require(&#x27;path&#x27;);const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;);const createWindow = () =&gt; &#123; const mainWindow = new BrowserWindow(&#123; width: 1000, height: 600, // 集成node webPreferences: &#123; nodeIntegration: true, &#125;, &#125;) mainWindow.loadFile(&#x27;index.html&#x27;)&#125;app.whenReady().then(() =&gt; &#123; createWindow() app.on(&#x27;activate&#x27;, () =&gt; if (BrowserWindow.getAllWindows().length === 0) createWindow())&#125;) app\\main\\index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Electron template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello world&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 运行 npm run start:main 可以看到界面： React12npm install reactnpm install react-router react-router-dom react-dom 配置 babelbabel 用来编译es6及jsx代码： 123456789# 核心 babel 插件：npm install -S @babel/polyfillnpm install -D @babel/core @babel/cli# 处理 jsxnpm install -D @babel/preset-env @babel/preset-react @babel/preset-typescript # 缩小 @babel/polyfill 引入时的的库，进行按需引入npm install @babel/plugin-transform-runtime --save --dev# 将ES modules转换为 CommonJSnpm install @babel/plugin-transform-modules-commonjs --save --dev 编写 babel.config.js ，babel官网推荐的这种写法替换以前的 .babelrc，api.cache(true);据官网的说法，可缓存传进来的api，效率更高 12345678910111213141516171819202122232425module.exports = function (api) &#123; api.cache(true); const presets = [ &#x27;@babel/preset-env&#x27;, // 允许使用最新的JS语法，而无须考虑环境的影响 &#x27;@babel/preset-react&#x27;, &#x27;@babel/preset-typescript&#x27;, ] const plugins = [ &#x27;@babel/plugin-transform-runtime&#x27;, [ &#x27;@babel/plugin-transform-modules-commonjs&#x27;, &#123; allowTopLevelThis: true, loose: true, lazy: true &#125; ] ] return &#123; presets, plugins &#125;&#125; 配置 webpack！注意，截至到我写该文为止，安装最新的webpack5和webpack-cli4，并不兼容，运行时会报很多莫名其妙的错误，所以必须指定webpack4和webpack-cli3的版本，其他版本我也试过了，只有这两个版本相容较为稳定 1234# 基础npm i -D webpack@4 webpack-cli@3# 热更新npm i -D webpack-dev-server 我们会配置3个webpack文件，分别是 webpack.base.js – 基础配置 webpack.render.js – 主进程配置 webpack.main.js – 渲染进程配置 所以安装这款插件，用于将下面两个个文件引入 webpack.base.js 中，减少webpack配置的代码: 1npm i -D webpack-merge 安装各种loader，plugin 123npm i -D html-webpack-plugin@4 # 用于读取入口HTML文件npm i -D clean-webpack-plugin # 主进程只编译每次打包好的文件，要这个插件可以每次自动清除上次留下来的文件npm i babel-loader 配置 cross-env 插件，用于执行不同环境的脚本： 1npm i cross-env webpack配置文件webpack.base.js123456789101112131415161718const path = require(&#x27;path&#x27;)const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)module.exports = &#123; resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.jsx&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;], alias: &#123; // 路径别名，可将 import A from &#x27;../../../../../A&#x27;这种导入路径，变成 import A from &#x27;@src/A&#x27; &#x27;@src&#x27;: path.join(__dirname, &#x27;../&#x27;, &#x27;app/renderer&#x27;) &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.(jsx?|tsx?)$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;,&#125;&#125;, ] &#125;, plugins: [ new CleanWebpackPlugin(), ],&#125; webpack.main.dev.js123456789101112131415161718192021222324const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)const baseConfig = require(&#x27;./webpack.base.js&#x27;)const webpackMerge = require(&#x27;webpack-merge&#x27;)const mainConfig = &#123; entry: path.resolve(__dirname, &#x27;../app/main/electron.js&#x27;), // 构建出不同运行环境的代码 target: &#x27;electron-main&#x27;, output: &#123; filename: &#x27;electron.js&#x27;, path: path.resolve(__dirname, &#x27;../dist&#x27;), &#125;, devtool: &#x27;inline-source-map&#x27;, mode: &#x27;development&#x27;, plugins: [ // 👇 根据启动命令的 node_env，指定构建变量 new webpack.DefinePlugin(&#123; &#x27;process.env.NODE_ENV&#x27;: &#x27;&quot;development&quot;&#x27; &#125;) ],&#125;module.exports = webpackMerge.merge(baseConfig, mainConfig) webpack.render.dev.js1234567891011121314151617181920212223242526272829303132333435const path = require(&#x27;path&#x27;)const webpackMerge = require(&#x27;webpack-merge&#x27;)const baseConfig = require(&#x27;./webpack.base.js&#x27;)const HtmlWebPackPlugin = require(&#x27;html-webpack-plugin&#x27;)const devConfig = &#123; mode: &#x27;development&#x27;, entry: &#123; // app.jsx 入口文件 index: path.resolve(__dirname, &#x27;../app/renderer/App.jsx&#x27;), &#125;, output: &#123; filename: &#x27;[name].[hash].js&#x27;, path: path.resolve(__dirname, &#x27;../dist&#x27;), &#125;, target: &#x27;electron-renderer&#x27;, devtool: &#x27;inline-source-map&#x27;, devServer: &#123; contentBase: path.join(__dirname, &#x27;../dist&#x27;), compress: true, host: &#x27;127.0.0.1&#x27;, port: 7001, hot: true, &#125;, plugins: [ new HtmlWebPackPlugin(&#123; // 以此为模板，自动生成HTML template: path.resolve(__dirname, &#x27;../app/renderer/index.html&#x27;), filename: path.resolve(__dirname, &#x27;../dist/index.html&#x27;), chunks: [&#x27;index&#x27;], &#125;) ]&#125;module.exports = webpackMerge.merge(baseConfig, devConfig) 重组项目结构由于react是在渲染进程中执行，所以，我们将入口文件 index.html 移动到 .app/render/ 文件夹， 并创建 app.jsx文件作为react的入口文件 12mv ./app/main/index.html ./app/renderer/touch ./app/renderer/App.jsx index.html 更改如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Electron Platform&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; App.jsx 1234567891011121314151617import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import &#123; HashRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;function App() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path=&#x27;/&#x27;&gt; &lt;div&gt;可视化开发平台&lt;/div&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Router&gt; )&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById(&#x27;root&#x27;)) 修改electron主线程配置，配合react做单页面应用既然基础文件结构改了，那么 .app/main/electron.js 也得跟着增加以下配置： 12345678910111213141516...const isDev = () =&gt; &#123; // 对应 webpack.main.dev.js里的 webpack.DefinePlugin的定义 return process.env.NODE_ENV === &#x27;development&#x27;;&#125;...const createWindow = () =&gt; &#123; ... // 利用 if (isDev()) &#123; mainWindow.loadURL(&#x27;http://127.0.0.1:7001&#x27;) &#125; else &#123; mainWindow.loadURL(`file://$&#123;path.join(__dirname, &#x27;./dist/index.html&#x27;)&#125;`) &#125;&#125; package.json 的 script 修改如下 1234&quot;scripts&quot;: &#123; &quot;start:main&quot;: &quot;cross-env NODE_ENV=development webpack --config ./webpack.main.dev.js &amp;&amp; electron ./dist/electron.js&quot;, &quot;start:render&quot;: &quot;webpack-dev-server --config ./webpack.renderer.dev.js&quot;&#125;, 报错处理 如果出现报错：Uncaught ReferenceError: require is not defined，请检查你是否在主进程中添加这行代码，如果添加了，请确保你搭建项目的 Electron 与本应用的版本一致(当前项目的 Electron@^11.1.1) 请自检查一下你的版本是否正确，进入 node_modules，找到 electron，看看 package.json 中的 version 是否是 11.1.1。 Vue现成模板：electron-react-boilerplate 和 electron-vueVue 或 React 均有一个现成的模板可用，这两个该模板共同好处是，只需要一个终端，便可跑起ELectron的主进程和渲染进程，集成度更高，下面我们来看一下这两个模板的配置。 electron-react-boilerplate 两个终端集成原理electron-react-boilerplate 集成两个终端是使用了webpack的一个api webpack deverserve before api，在其源码文件webpack.config.renderer.dev.babel.js里可以看到配置 12345678910111213141516import &#123; spawn, execSync &#125; from &#x27;child_process&#x27;export default merge(baseConfig, &#123; ... before() &#123; console.log(&#x27;Starting Main Process...&#x27;); // 利用node的 spawn api 跑一个 start:main 的子进程 spawn(&#x27;npm&#x27;, [&#x27;run&#x27;, &#x27;start:main&#x27;], &#123; shell: true, env: process.env, stdio: &#x27;inherit&#x27;, &#125;) .on(&#x27;close&#x27;, (code) =&gt; process.exit(code)) .on(&#x27;error&#x27;, (spawnError) =&gt; console.error(spawnError)); &#125;,&#125; 其实很简单，利用了node的child_process api 新开了个进程，让渲染进程跑在该进程之上 webpack.devserver.before api 类似于 webpack 的生命周期函数，还有一个 webpack.devserver.after electron-vue 两个终端集成原理electron-vue 是因为这个的脚本dev-runner.js，利用 Promise.all()，函数进行调用，把两个终端操作融合到一起： 12345678910111213141516...function init () &#123; greeting() // startRender() 利用 Promise.all([startRenderer(), startMain()]) .then(() =&gt; &#123; startElectron() &#125;) .catch(err =&gt; &#123; console.error(err) &#125;)&#125;init()","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zyzy.info/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"https://zyzy.info/tags/Webpack/"},{"name":"Vue","slug":"Vue","permalink":"https://zyzy.info/tags/Vue/"},{"name":"Electron","slug":"Electron","permalink":"https://zyzy.info/tags/Electron/"}]},{"title":"Nginx自学笔记","slug":"【2021-05-28】Nginx自学笔记","date":"2021-05-28T01:36:33.000Z","updated":"2023-10-29T16:23:18.776Z","comments":true,"path":"2021/05/28/【2021-05-28】Nginx自学笔记/","link":"","permalink":"https://zyzy.info/2021/05/28/%E3%80%902021-05-28%E3%80%91Nginx%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0/","excerpt":"Ngix这几年太火了，在不久的将来会超过Apache，由于他的底层用epoll，现在多用于服务器端的反向代理和负载均衡 ，强大的并发性能使其基本上没有项目不用他。本篇把 Ngix 的基础配置撸了一遍，记下来以免以后忘了。","text":"Ngix这几年太火了，在不久的将来会超过Apache，由于他的底层用epoll，现在多用于服务器端的反向代理和负载均衡 ，强大的并发性能使其基本上没有项目不用他。本篇把 Ngix 的基础配置撸了一遍，记下来以免以后忘了。 安装可查看Nginx官网 连接远程服务器1ssh root@8.134.120.206 输入密码后见到登录了 安装些必要的工具12yum -y install gcc gcc-c++ autoconf pcre-devel make automakeyum -y install wget httpd-tools vim 返回家目创建Nginx主要文件夹123cd ~mkdir nginx-learn &amp;&amp; cd nginx-learnmkdir app backup download logs work app: 放程序源码backup: 备份文件download: 下载文件夹logs: 日志work: 放一些项目文档 安装最新版Nginx需查看Nginx的yum源的版本，运行以下命令： 1yum list | grep nginx yum 源的更新配置，复制Nginx官网这里的配置，我把他粘出来 123456789101112131415[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true 1vim /etc/yum.repos.d/nginx.repo 其中 baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ 的 $releasever 我用的是centOS 7的版本，所以我直接改成7，如下： 这次再安装nginx 1234yum install nginxnginx -v# ornginx -V 可以发现更新到最新的nginx版本 查看所有 nginx 目录及配置文件的命令： 1rpm -ql nginx Nginx配置项详解配置项：大部分工作在以下两个文件执行修改：/etc/nginx/nginx.confcd /etc/nginxcat nginx.conf 下面解释一下各配置的作用： 123456789101112131415161718192021222324252627282930313233343536373839user nginx; # 默认用户worker_processes auto; # 进程数，即cpu数error_log /var/log/nginx/error.log notice; # 错误日志pid /var/run/nginx.pid; # 进程events &#123; worker_connections 1024; # 允许最大连接数&#125;http &#123; include /etc/nginx/mime.types; # 文件扩展名的映射表 default_type application/octet-stream; # # 设置日志格式： log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; # 访问日志存放位置 access_log /var/log/nginx/access.log main; # 开启默认传输模式 sendfile on; # 减少网络报文数量 #tcp_nopush on; # 超时时间 keepalive_timeout 65; # 开启压缩 #gzip on; # 子配置项 include /etc/nginx/conf.d/*.conf;&#125; 12cd conf.d/vim default.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243server &#123; listen 80; # 监听端口号 server_name localhost; #access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log main; location &#x2F; &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; index index.html index.htm; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME &#x2F;scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125;&#125; 网站根目录我们改动一点根目录的内容： 1vim /usr/share/nginx/html/index.html 运行Nginx开启1nginx 关闭123456# 正常关停nginx -s quit# 几种强制关停nginx -s stopkillall nginx 重载每次改完配置文件后，需要重载nginx，运行一下命令： 1nginx -s reload Linux通用命令执行开启，关闭和重载当然，也可以用Linux的通用命令进行关停或重启： 12345678# 或 Linux通用命令：systemctl start nginx.service# Linux通用命令关停：systemctl stop nginx.service# 重启：systemctl restart nginx.service 查看进程通过查看nginx所有进程确认其已经运行： 1ps aux | grep nginx 查看所有开启的端口号1netstat -tlnp 配置一个404页面，修改一个配置如下： 1vim /etc/nginx/conf.d/default.conf 增加一行，改成这样： 做一个404页面： 1vim /usr/share/nginx/html/404_error.html 写完页面后，地址栏随便输入一地址会发现出现了404页面： 也可以重定向到其他页面，如： 1vim /etc/nginx/conf.d/default.conf 权限控制禁止某些ip不能访问1vim /etc/nginx/conf.d/default.conf 在default.conf加上 deny 113.65.137.13; ，如下，禁止了我本机不可以访问 如果要禁止某一网段的IP不能访问，则写：deny 113.65.137.13/200; ，表示 13 到 200 的所有IP号都不能访问 allow 允许哪些IP可以访问 注意！！！default.conf 文件是从上往下执行，如 deny all; 写在 allow 113.65.137.13;之前，那么113.65.137.13仍不能访问 再次在页面打开，就会发现不能访问页面，出现403页面： 精确匹配路径访问权限 在 location 配置某些路径允许哪些IP 进行访问，添加如下： 都是正则匹配，除了路径，还可匹配不能访问的文件，如 .php 结尾的文件 123456789location =/img &#123; allow all;&#125;location =/admin &#123; deny all;&#125;location ~\\.php$ &#123; deny all;&#125; 虚拟主机配置虚拟主机的好处，可以省钱，一台物理服务器可划分多个空间，每个独立空间可配置独立的虚拟主机，彼此相互隔离，每个虚拟主机可以独立配置web服务 基于端口号配置虚拟主机在 /etc/nginx/conf.d/ 下新建 8001.conf 文件，用于配置 8001 端口的虚拟主机 1vim /etc/nginx/conf.d/8001.conf 基于改虚拟主机配置一个 index.html 文件： 1touch /usr/share/nginx/html/html8001/index.html 写下 1&lt;h1&gt;welcome to port 8001&lt;/h1&gt; 我这里用的是阿里云做演示，所以返回阿里云界面配置8001端口： 基于IP配置虚拟主机同样是改变 8001.conf 文件的 localhost 项的配置 1vim /etc/nginx/conf.d/8001.conf 如： 123456server&#123; listen 80; server_name 192.168.1.200; root /usr/share/nginx/html/html8001; index index.html;&#125; 基于域名配置虚拟主机在阿里云上申请域名，这里不演示，现在 .top 结尾的域名在做促销，起个稍微长点的域名注册只需9元就能注册一年， 我这里注册了 service-learn.top 花了9元 点击域名解析： 输入ip地址，类型选择A类型： 在nginx 配置 1vim /etc/nginx/conf.d/default.conf 将 server_name localhost; 改为 server_name niginx.service-learn.top; 同样的原来的基于端口的虚拟机8001端口也修改：先去阿里云配置解析 nginx2.service-learn.top 地址 1vim /etc/nginx/conf.d/8001.conf 将 server_name localhost; 改为 server_name nginx2.service-learn.top;，改后如下： 123456server&#123; listen 80; server_name nginx2.service-learn.top; root /usr/share/nginx/html/html8001; index index.html;&#125; 反向代理正向代理（Proxy）为客户端做的代理服务器，最形象的解释就是，我们平时用vpn翻墙上外网， 反向代理（Reverse Proxy)为服务端做的代理服务，反向代理最大的好处是 安全性，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。在遭受网络攻击时，会被停留在反向代理上，攻击不到我们真实的服务器。 功能性，反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡。 Nginx的反向代理实操这里我们用 8001 的配置来做反向代理，设置也很简单，修改 vim /etc/nginx/conf.d/8001.conf 如下 我们要访问 8.134.120.206:8001 端口的网站，反向代理到 我的博客 这个网站上 1234567server&#123; listen 8001; server_name 8.134.120.206; location / &#123; proxy_pass http://zyzy.info; &#125;&#125; 打开浏览器显示如下，反向代理设置成功： 反向代理其他配置参数proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。 Nginx适配移动端这里和前端的调整页面布局的自适应不是一个概念，现在的移动端适配，是由于不同域名的切换，引起的适配，所以Nginx在这块就能发挥作用，这种通过Nginx的适配，体验效果会更好，包括淘宝京东在内的国内大型网站都是采用Nginx的方案 我们可以打开浏览器打开京东看到这种适配： 我们来做类似的功能： 建立pc和移动端两个文件夹 1mkdir /usr/share/nginx/pc /usr/share/nginx/mobile 分别编辑 vim /usr/share/nginx/mobile/pc/index.html 和 vim /usr/share/nginx/mobile/mobile/index.html，随便写点内容 编辑Nginx设置如下即可 1234567891011server&#123; listen 8001; server_name 8.134.120.206; location / &#123; root /usr/share/nginx/pc; if ($http_user_agent ~* &#x27;Android|webOS|iPhone|BlackBerry&#x27;) &#123; root /usr/share/nginx/mobile; &#125; index index.html; &#125;&#125; 打开浏览器看看效果 Gzip压缩网页的一种压缩技术，经过Gzip压缩过后的网页，会缩小到原来30%的大小 查看一个网站是否有gzip压缩在站长工具 里查看，直接输入域名即可，例如我们查询 8.134.120.206还没配置gzip压缩 Nginx的gzip压缩功能非常丰富，配置也很简单 1vim /etc/nginx/nginx.conf 添加两行配置如下： 12gzip on;gzip_types text/plain application/javascript text/css; 改完后重载Nginx服务，再用站长工具查询可看到","categories":[],"tags":[{"name":"后端","slug":"后端","permalink":"https://zyzy.info/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Nginx","slug":"Nginx","permalink":"https://zyzy.info/tags/Nginx/"},{"name":"反向代理","slug":"反向代理","permalink":"https://zyzy.info/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"}]},{"title":"Dart语法自学笔记（二）","slug":"【2021-05-26】Dart语法自学笔记（二）","date":"2021-05-26T09:10:54.000Z","updated":"2023-10-29T16:23:18.775Z","comments":true,"path":"2021/05/26/【2021-05-26】Dart语法自学笔记（二）/","link":"","permalink":"https://zyzy.info/2021/05/26/%E3%80%902021-05-26%E3%80%91Dart%E8%AF%AD%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"本篇介绍Dart的函数，类，抽象类，接口，泛型及库的使用","text":"本篇介绍Dart的函数，类，抽象类，接口，泛型及库的使用 命名函数，匿名函数，箭头函数注意！！箭头函数只能写一个语句 12345678910// void 可省略void func () &#123; print(&#x27;hello world&#x27;);&#125;;// 匿名() &#123; print(123); &#125;;// 箭头func2 () =&gt; print(123); 函数的定义及调用123456789101112int sunNum(int n)&#123; var sum = 0; for (var i =1; i&lt;=n; i++) &#123; sum+=i; &#125; return sum;&#125;void main() &#123; print(sumNum(10)); // 55&#125; 可选参数， 默认参数，命名参数 可选参数，用 [] 括起来，且不能指定类型 默认参数，直接等于一个值就是默认参数，可指定类型 123456789String userInfo (String username, [age, String gender=&#x27;m&#x27;] ) &#123; if (age == null ) return &#x27;$username&#x27;; return &#x27;$username, $age, $gender&#x27;;&#125;void main()&#123; print(userInfo(&#x27;没名字&#x27;, 23)); // 没名字, 23, m&#125; 命名参数，和上面两种类似，如果要指定类型，则必须有默认值 123456789yyy (String username, &#123;age, String gender=&#x27;male&#x27;, job=&#x27;programmer&#x27;&#125;) &#123; if (age == null || job == null) return &#x27;$username, 年龄保密, $gender&#x27;; return &#x27;$username, 年龄保密, $gender, $job&#x27;;&#125;void main () &#123; print(yyy(&#x27;张三&#x27;, age:23, gender: &#x27;female&#x27;)); // 张三, 年龄保密, male programmer&#125; 把函数作为参数传参12345678fn1() =&gt; print(&#x27;fn1&#x27;);fn2(fn)&#123; fn();&#125;void main() &#123; fn2(fn1); // fn1&#125; 类和构造函数 dart为单继承语言 类里的同名方法为构造函数，在构造函数生成之前还能执行其他的操作，写在括号和左花括号之间，如下： 123456789101112131415161718class PersonY &#123; String name; int age; // 且构造函数之前还能进行操作 :name=&#x27;构造函数之前生成的name&#x27;, age=999 .用的少 PersonY(String name, int age): name=&#x27;构造函数之前生成的name&#x27;, age=999 &#123; print(&#x27;构造函数生成之前打印的内容:$&#123;this.name&#125;--$&#123;this.age&#125;&#x27;); this.name=name; this.age=age; &#125;&#125;main() &#123; PersonY p2 = new PersonY(&#x27;李四&#x27;, 45); print(p2.name); // 构造函数生成之前打印的内容:构造函数之前生成的name--999 // 李四&#125; 构造函数可以简写 dart构造函数只有一个，但命名构造函数可以写多个： 123456789101112131415161718class PersonZ &#123; String name; int age; // 简写： PersonZ(this.name, this.age); // 命名构造函数：如果有属性，则一定要传入属性维护起来：例如这里的 this.name 和 this.age PersonZ.named(this.name, this.age) &#123; print(&#x27;这是命名构造函数&#x27;); &#125;&#125;main() &#123; // 调用命名构造函数仍要传参： PersonZ pp = new PersonZ.named(&#x27;xxxx&#x27;, 12); print(pp.name); print(pp.age); &#125; 以上执行输出如下： 这是命名构造函数xxxx12 私有属性dart里并没有 public private protected 等关键字，定义私有属性时，必须： 以 _ 为开头的属性 独立为一个文件，并且 import 到 main 方法里执行，才能达到私有属性的效果 12345678910111213141516171819202122class Pet&#123; // 私有属性前加下划线,并且必须写在独立的文件里: String _name; int age; Pet(this._name, this.age); void printInfo() &#123; // 类里可以直接访问私有属性_name, Pet外部则不能 print(&#x27;$&#123;this._name&#125;====$&#123;this.age&#125;&#x27;); &#125; // 私有方法_run void _run()&#123; print(&#x27;私有方法&#x27;); &#125; // 外部访问私有方法: execRun()&#123; this._run(); &#125;&#125; 调用处： 12345678910111213141516// 1. 必须卸载独立的文件里,私有变量才生效:import &#x27;./08-私有属性/Pet.dart&#x27;;void main() &#123; Pet a = new Pet(&#x27;狗&#x27;, 3); /* // print(a._name); 2. 报错,不能直接访问,_name为私有属性,须要定义方法访问 */ // 非私有属性,可以直接访问: print(a.age); // 3 a.printInfo(); // 狗====3 a.execRun(); //间接调用私有方法&#125; 连缀操作符123456789Person p2 = new Person(&#x27;王五&#x27;, 34);p1..name = &#x27;李四&#x27; ..age = 30 ..printInfo();// 相当于// p1.name = &#x27;李四&#x27;;// p1.age = 30;// p1.printInfo(); 继承可利用 vs code 里的快捷方式进行操作，不用自己写： super 关键字1234567891011121314151617181920212223242526272829303132class Person &#123; String name; num age; Person(this.name, this.age); void printInfo() &#123; print(&#x27;父类的printInfo：$&#123;this.name&#125;---$&#123;this.age&#125;&#x27;); &#125;&#125;class Web extends Person &#123; String gender=&#x27;m&#x27;; Web(String name, num age, // String gender 子类自己的属性： String gender) : // super 可用于继承父类的属性： super(name, age) &#123; // 2. 属于该函数自由的构造函数写这里: this.gender = gender; &#125; run()&#123; // super 可用于继承父类的方法： super.printInfo(); print(&#x27;$&#123;this.name&#125;--$&#123;this.age&#125;--$&#123;this.gender&#125;&#x27;); &#125; // 重写父类存在的方法: @override, 用于标示，可省略 @override void printInfo() &#123; print(&#x27;子类重写的方法：$&#123;this.gender&#125;-$&#123;this.name&#125;&#x27;); &#125;&#125; abstract 抽象类 抽象类： 12345678910abstract class Pet &#123; // 抽象方法，不写方法体： eat(); run(); // 抽象类里的普通方法： printInfo()&#123; print(&#x27;抽象类的普通方法&#x27;); &#125;&#125; 抽象方法被继承时均要重写： 12345678910111213class Dog extends Pet &#123; @override eat() &#123; // TODO: implement eat print(&#x27;小狗吃骨头&#x27;); &#125; @override run() &#123; // TODO: implement run print(&#x27;小狗在跑&#x27;); &#125;&#125; implements 接口 dart里没有接口的概念，用抽象类替代 接口继承时，用关键字 implements 下面的例子举连接数据库的抽象类和实例： 1234567891011121314151617181920212223242526272829303132abstract class Db &#123; String uri=&#x27;&#x27;; //数据库连接地址 add(String data); save(); delete();&#125;class Mysql implements Db &#123; @override String uri; Mysql(this.uri); @override add(String data) &#123; // TODO: implement add print(&#x27;这是mysql的add方法:$&#123;data&#125;&#x27;); &#125; @override delete() &#123; // TODO: implement delete return null; &#125; @override save() &#123; // TODO: implement save return null; &#125; &#125; 一个类可 implements 多个接口： 123456789101112131415abstract class A &#123; printA(); &#125;abstract class B &#123; printB(); &#125;class C implements A, B &#123; @override printA() &#123; // TODO: implement printA return null; &#125; @override printB() &#123; // TODO: implement printB return null; &#125;&#125; mixins 混合 dart 特有的特性，因为dart是单继承，mixins 可让其实现实现类似多继承的特性，一个类可 mixins 多个类 实现该特性用 with 关键字 被 mixins 的父类不能有构造函数，如有构造函数，不能被 mixins 1234567891011// D 和 E 没有构造函数：class D &#123; printD()&#123; print(&#x27;D&#x27;); &#125;&#125;class E &#123; printE()&#123; print(&#x27;E&#x27;); &#125;&#125;class F with D, E &#123;&#125;main() &#123; F f = new F(); f.printD(); // D f.printE(); // E&#125; 有构造函数被 mixins的方法：extends 后再 with, 如下例子: 123456789101112131415161718class Person &#123; String name; int age; // 构造函数: Person(this.name, this.age); void printInfo()&#123; print(&#x27;$&#123;this.name&#125;-$&#123;this.age&#125;&#x27;);&#125;&#125;class G &#123; void printG()&#123;print(&#x27;G&#x27;);&#125; &#125;// P 继承自Person, 且混合G: 因Person中有构造函数Person(this.name, this.age); 故不能直接withclass P extends Person with G &#123; P(String name, int age) : super(name, age);&#125;main() &#123; P p = new P(&#x27;呵呵&#x27;,37); p.printInfo(); // 呵呵-37 p.printG(); // G&#125; 泛型泛型即定义传入和返回类型的校验的一种规范 12345678910// 1. 定义一种泛型，返回的是泛型 T，传入的是类型 &lt;T&gt;，T getData &lt;T&gt; (T value)&#123; print(value);&#125;main() &#123; // 2. 调用泛型方法并指定类型： print(getData &lt;String&gt; (&#x27;你好&#x27;)); // 你好 print(getData &lt;int&gt; (123)); // 123&#125; 泛型用于类 1234567891011121314151617181920// &lt;T&gt; 将检验类型作为参数传入class PrintClass &lt;T&gt; &#123; List list = &lt;T&gt;[]; // T 将检验类型作为参数传入 void add(T value) &#123; this.list.add(value); &#125; void printInfo() &#123; for(var i=0; i&lt;this.list.length; i++) &#123; print(this.list[i]); &#125; &#125;&#125;main() &#123; // 调用时须传入检验的类型 &lt;String&gt; PrintClass p = new PrintClass &lt;String&gt; (); p.add(&#x27;xxxxxxx&#x27;); p.printInfo(); // xxxxxxx&#125; 泛型用于接口 123456789101112131415161718192021abstract class Cache &lt;T&gt; &#123; getByKey(String key); void setByKey(String key, T value);&#125;// 3.1 实现:class FileCache &lt;T&gt; implements Cache &lt;T&gt; &#123; @override getByKey(String key) &#123; return null; &#125; @override void setByKey(String key, T value) &#123; print(&#x27;我是文件缓存, 把key=$&#123;key&#125; value=$&#123;value&#125;的数据写入内存中&#x27;); &#125;&#125;main() &#123; MemoryCache m = new MemoryCache &lt;String&gt; (); m.setByKey(&#x27;index&#x27;, &#x27;123&#x27;); // 我是内存缓存, 把key=index value=123的数据写入内存中&#125; 库的使用 系统内置库，如： 1234567891011121314import &#x27;dart:io&#x27;;import &#x27;dart:convert&#x27;;_getDataFromZhihu() async &#123; var httpClient = new HttpClient(); var uri = new Uri.http(&#x27;news-at.zhihu.com&#x27;, &#x27;/api/3/stories/latest&#x27;); var request = await httpClient.getUrl(uri); var response = await request.close(); return await response.transform(utf8.decoder).join(&#x27; &#x27;);&#125;main(List&lt;String&gt; args) async &#123; var result = await _getDataFromZhihu(); print(result);&#125; 第三方包管理系统pub，官网在这里，功能类似npm的网站，这里举例 http 库的使用 引入，在根目录下写下一个pubspec.yaml 文件，类似 package.json 写下你需要安装的库的版本，如下，可以在这里拷贝其版本号 123456name: xxxdescription: A new flutter module.environment: sdk: &#x27;&gt;=2.10.0 &lt;3.0.0&#x27;dependencies: http: ^0.13.3 执行安装 方法一，在pubspec.yaml 文件写好 dependencies，再执行如下： 1dart pub get 方法二，直接执行以下命令，安装最新版本 1dart pub add http_parser 使用 pub 库是以 package 开头： 1import &#x27;package:http/http.dart&#x27; as http;","categories":[],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://zyzy.info/tags/Dart/"},{"name":"flutter","slug":"flutter","permalink":"https://zyzy.info/tags/flutter/"}]},{"title":"Dart语法自学笔记（一）","slug":"【2021-05-25】Dart语法自学笔记（一）","date":"2021-05-25T00:22:49.000Z","updated":"2023-10-29T16:23:18.775Z","comments":true,"path":"2021/05/25/【2021-05-25】Dart语法自学笔记（一）/","link":"","permalink":"https://zyzy.info/2021/05/25/%E3%80%902021-05-25%E3%80%91Dart%E8%AF%AD%E6%B3%95%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"flutter框架从19年开始就火了，主要用于跨端解决方案，一套代码可以覆盖ios，Android和Web，据说法执行效率很高，因去掉了像React Native那样的转译层，直接作用于底层，那必须学起来。 flutter其framework层面调用的是Dart，一新的静态语言，和js炒鸡像，本文从着重讲解Dart的基础语法，包括基础数据解构，常用api及循环，不罗列所有基础语法点，只挑一些有特点演示。","text":"flutter框架从19年开始就火了，主要用于跨端解决方案，一套代码可以覆盖ios，Android和Web，据说法执行效率很高，因去掉了像React Native那样的转译层，直接作用于底层，那必须学起来。 flutter其framework层面调用的是Dart，一新的静态语言，和js炒鸡像，本文从着重讲解Dart的基础语法，包括基础数据解构，常用api及循环，不罗列所有基础语法点，只挑一些有特点演示。 本文的示例代码，放在这个 仓库，本文阐述了 01-06 的代码 安装 Dart官网上有命令行的安装方法，我用win平台，可以直接从这里下载一个SDK安装包，直接下一步下一步安装完成。 安装完成后可以在命令行检验版本是否安装成功： C:\\WINDOWS\\System32&gt;dart –versionDart SDK version: 2.13.0 (stable) (Wed May 12 12:45:49 2021 +0200) on “windows_x64” 我用 vs code 开发，安装 插件 Dart ，Code Runner hello world先来个 hello world，发现和 go 语言语法有点像， 同样是主入口函数 main()&#123;&#125; 主导着整个文件的执行 一个语句完成须强行加 ; 1234// void 可省略void main()&#123; print(&#x27;hello world&#x27;);&#125; 运行 命令行里直接跑 dart &lt;DartDoc&gt;.dart，就可以看到打印的 hello world E:\\study\\code\\2021\\dart-learn&gt;dart 01-hello-world.darthello world 变量 var 常量 const final dart类似 ts 有类型检查功能， 12345String str1 = &#x27;你好&#x27;;print(str1); // 你好int num1 = 123;print(num1); // 123 但 dart 也可自动推断类型，也可以无须声明直接定义，类似 js ： 12345var str = &#x27;hehe&#x27;;print(str); // heheconst e = 2.14;print(e); // 2.14 dart 有一个惰性常量 final，其和普通常量 const 的区别： final 可以只定义，不赋值；const 则不可以 final 只有在运行时才会初始化 例如定义日期，实时生成的，只能用 final 1234final timeNow;timeNow = new DateTime.now();print(timeNow);// 2021-05-24 12:53:04.819814 数据类型dart不像js，不能进行类型自动转换，需要手动进行转换1234print(&#x27;string&#x27; + 1); // 错误// 报错：// Error: A value of type &#x27;int&#x27; can&#x27;t be assigned to a variable of type &#x27;String&#x27;. bool布尔类型为一种单独类型，不同于js，不能转换为0，1 12bool k = true;print(k); // true int double整数类型和浮点类型，没啥好讲的 String 单行字符串。可以单引号&#39; &#39;或双引号&quot; &quot;定义； 换行的字符串。类似 Python ，需用三单引&#39;&#39;&#39; &#39;&#39;&#39; 或 三双引&quot;&quot;&quot; &quot;&quot;&quot;； 占位符用 $，单行或多行字符串均可使用； 123456789String str = &#x27;1223&#x27;;var str2 = &#x27;&#x27;&#x27;line1: heheline2: haha&#x27;&#x27;&#x27;;print(&#x27;$str + $str2&#x27;);print(&#x27;-------------&#x27;);print(str + str2); 结果： 1223 + line1: hehe line2: haha 1223 line1: hehe line2: haha List定义List123456789List l = [&#x27;aaa&#x27;, 3, true];print(l.length); // 3const l2 = [&#x27;vvv&#x27;, &#x27;xx&#x27;];print(&#x27;$l $l2&#x27;); // [aaa, 2, true] [vvv, 5]// 增加元素 .add() 方法：List l3 = &lt;String&gt;[&#x27;foo&#x27;, &#x27;bar&#x27;];l3.add(&#x27;fee&#x27;); // [foo, bar, fee] 创建固定长度List，List.filled(length, 填充的元素)，不能增加数据使用 add()123// &lt;String&gt; 可省略List l5 = List&lt;String&gt;.filled(3, &#x27;&#x27;);print(l5); // [, , ] 常用List方法:将一个现有List反转 .reversed.toList()12345List a = [&#x27;12&#x27;, &#x27;23&#x27;, &#x27;34&#x27;, &#x27;45&#x27;];print(a.reversed);// (45, 34, 23, 12)print(a.reversed.toList());// [45, 34, 23, 12] 替换元素 fillRange(开始, 结束, 替换的元素) 插入 insert(插入位置，插入元素) insertAll(插入位置，插入多个元素)123456789List l = [&#x27;12&#x27;, &#x27;23&#x27;, &#x27;34&#x27;, &#x27;45&#x27;];l.fillRange(1,3, &#x27;c&#x27;);print(l); // [12, c, c, 45] l.insert(3, &#x27;单个元素&#x27;);print(l); // [12, c, c, 单个元素, 45]l.insertAll(2, [&#x27;元素1&#x27;, &#x27;元素2&#x27;]);print(l); // [12, c, 元素1, 元素2, c, 单个元素, 45] List ——&gt; String： .join()；String ——&gt; List：.split()1234567891011List a = [12, &#x27;CC&#x27;, &#x27;zengjia&#x27;, &#x27;hehe&#x27;, &#x27;haha&#x27;, &#x27;CC&#x27;, 67];var b = a.join(&#x27;-&#x27;);print(b);// 12-CC-zengjia-hehe-haha-CC-67print(b is String);// truevar c = b.split(&#x27;-&#x27;);print(c);// [12, CC, zengjia, hehe, haha, CC, 67]print(c is List);// true Set和 js 的 Set 类似 最主要的功能就是去除数组重复内容 没有顺序且不能重复的集合，所以不能通过索引去获取值 12345List l = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];Set ss = new Set();ss.addAll(l);print(ss); // &#123;a, b, c&#125;print(ss.toList()); // [a, b, c] Map类似 js 的obj，定义Map两种方法： 12345var p = &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;:20&#125;;print(p); // &#123;name: zhangsan, age: 20&#125;var p2 = new Map();print(p2); // &#123;&#125; 注意！Map 不能用点 . 运算，只能用属性选择器 [] 1print(p[&#x27;age&#x27;]); // 20 keys.toList() values.toList() 让键或值变成数组12345678Map p = &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;:20&#125;;print(person.keys.toList()); // [name, age]print(person.values.toList());// [xxx, 20]print(person.entries);// (MapEntry(name: xxx), MapEntry(age: 20)) is 关键字判断类型1234567String str = &#x27;1223&#x27;;if (str is String) print(&#x27;string类型&#x27;);else if(str is int) print(&#x27;int类型&#x27;);else print(&#x27;其他&#x27;);// string类型 可迭代数据的通用方法拼接 .addAll()注意：List 和 Map 拼接可在原来的基础上拼接，其内存指向不变，Set 拼接则需重新 new 一个对象 12345678910111213141516171819// List 拼接：List a = [&#x27;12&#x27;, &#x27;23&#x27;, &#x27;34&#x27;, &#x27;45&#x27;];a.addAll([&#x27;67&#x27;,&#x27;89&#x27;]);print(a);// [12, 23, 34, 45, 67, 89]// Set 拼接：List l = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];Set ss = new Set();ss.addAll(l);print(ss); // &#123;a, b, c&#125;print(ss.toList()); // [a, b, c]// Map 拼接：Map m = &#123;&#x27;name&#x27;:&#x27;Tom&#x27;,&#x27;Id&#x27;:&#x27;E1001&#x27;&#125;;m.addAll(&#123;&#x27;dept&#x27;:&#x27;HR&#x27;,&#x27;email&#x27;:&#x27;tom@xyz.com&#x27;&#125;);print(m);// &#123;name: Tom, Id: E1001, dept: HR, email: tom@xyz.com&#125; 转换为数组 .toList()见上面提过的例子具有涉及: List， Set 转换为字符串 .toString()List，Set，Map均有此功能 两个特殊运算符dart的运算符，除了这里提到的两种符号，其他和 js 一样 ~/ 和 ~/= 取整符号 ~/，很简单： 1234int a = 12;int b = 5;print(a~/b);// 2 另外，和大多数语言一样，dart里没有三等符号，只有两等 == 是否为空赋值 ??=??= 表示，如果值不为空，则赋值为新值；如果不为空，则用原值； 1234567b??=89;print(b);// 5var c = 45;c ??= 8;print(c);// 45 类型转换 String ——&gt; Number ： int.parse() 和 double.parse()123456789String y = &#x27;123&#x27;;var m = int.parse(y);print(m is int);// trueString u = &#x27;23.345&#x27;;var x = double.parse(u);print(x is double);// true isEmpty 和 isNotEmpty 判断字符串是否为空；isNaN 判断数值是否合法1234567891011var er = &#x27;xxx&#x27;;var xu = 0/0;if(er.isEmpty) print(&#x27;str为空&#x27;); else print(&#x27;str不为空&#x27;);// str不为空if(xu.isNaN)&#123; print(&#x27;xu不合法&#x27;);&#125;else&#123; print(&#x27;xu合法&#x27;);&#125;// xu不合法 循环和 js 相似度达到 95% for， for indart没有 for of 循环，for for in和 js 基本一样的写法 123456789// 例：打印1到9之间所有偶数：for (int i=1; i&lt;=9; i++) &#123; if (i%2 == 0) &#123; print(i); &#125;&#125;// p.s. 如果在同一行写可省略花括号 `&#123;&#125;` for (int i in [1,2,3,4,5,6,7,8,9]) if(i%2 == 0) print(i); 以上均输出： 2468 forEach123456789101112131415161718// 循环Listconst l2 = [2,3];l2.forEach((el) &#123; print(el);&#125;);// 2// 3// 循环MapMap m = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;;m.forEach((key, value) &#123; print(&#x27;$key --- $value&#x27;);&#125;);// a --- 1// b --- 2// 或可写为 箭头函数 =&gt;// m.forEach((key, value) =&gt; print(&#x27;$key --- $value&#x27;)); List， Set 的通用方法: where，any，every一个比较有趣的方法，类似条件语句，用于特定元素的查找和 js 的数组方法的 .some() .every()等方法类似 1234567891011121314151617// ListList l3 = [2,3,6,8];var ll = l3.where((item) =&gt; item &gt;3);print(ll); // (6, 8)print(ll.toList()); // [6, 8]print(l3.any((item) =&gt; item &gt;=3)); // trueprint(l3.every((item) =&gt; item % 2 == 0 || item % 3 == 0 )); // truel3.removeWhere((item) =&gt; item &lt; 7 );print(l3); // [8]// SetSet s2 = &#123;2, 3, 4, 2, 8, 9, 8&#125;;bool ss = s2.any((item) =&gt; item &lt; 1);print(ss); // falseprint(s2.where((item) =&gt; item &gt; 3)); // (4, 8, 9)print(s2.every((item) =&gt; item &lt;= 10)); // true","categories":[],"tags":[{"name":"Dart","slug":"Dart","permalink":"https://zyzy.info/tags/Dart/"},{"name":"Flutter","slug":"Flutter","permalink":"https://zyzy.info/tags/Flutter/"},{"name":"跨端","slug":"跨端","permalink":"https://zyzy.info/tags/%E8%B7%A8%E7%AB%AF/"}]},{"title":"【2021-05-04】ts在ReactClass和ReactHooks的应用","slug":"【2021-05-04】TS在ReactClass和ReactHooks中的应用","date":"2021-05-23T00:43:25.000Z","updated":"2023-10-29T16:23:18.774Z","comments":true,"path":"2021/05/23/【2021-05-04】TS在ReactClass和ReactHooks中的应用/","link":"","permalink":"https://zyzy.info/2021/05/23/%E3%80%902021-05-04%E3%80%91TS%E5%9C%A8ReactClass%E5%92%8CReactHooks%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/","excerpt":"对于现行的ES规范，已经具有很好的规范性与可读性，type script虽当下大行其道，其实我觉得意义不算很大，ts最重要的功能就是类型检查，包括 interface, type 等也是一种类型检查，但一不小心就会写成 any script。鉴于将来的项目或者现行的项目可能会用到，这里结合 React Hooks 写个 tsx 版的 demo","text":"对于现行的ES规范，已经具有很好的规范性与可读性，type script虽当下大行其道，其实我觉得意义不算很大，ts最重要的功能就是类型检查，包括 interface, type 等也是一种类型检查，但一不小心就会写成 any script。鉴于将来的项目或者现行的项目可能会用到，这里结合 React Hooks 写个 tsx 版的 demo 自己写的 TypeScript demo，TS基础内容可以翻看该仓库安装新项目，只需带--template typescript参数即可：123create-react-app &lt;app name&gt; --template typescript#or yarn create-react-app &lt;app name&gt; --template typescript 老项目，在原有JSX项目create-react-app基础上增加typescript内容：12345npm install --save typescript @types/node @types/react @types/react-dom @types/jest # or yarn add typescript @types/node @types/react @types/react-dom @types/jest 创建*.d.ts 文件，专门用于各种依赖的声明详细的用法可参考掘金答神这篇文章，我这里简单的说明一下： 外部npm install一个库时: 1declare module &#x27;lodash&#x27; interface 声明 12345interface xxxProps &#123; name: string; age?: number; method(f: string): string;&#125; 初学者的编写利器 —— vs code 中的提示可以利用好 vs code 中自带的提示，例如下面的提示，下面的例子会截图此类提示框： 最外层 index.tsx12345678910111213141516171819import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;// 全局变量，如有：declare global &#123; interface Window &#123; API: any, _store: any &#125;&#125;ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, // HTMLElement 接口： document.getElementById(&#x27;root&#x27;) as HTMLElement); 组件Function 组件1const App: React.FC = () =&gt; null vs code 里的提示： Class 组件123456// 这个没什么好说的，写到烂了export class ClassTS extends React.Component &#123; public render(): React.ReactNode &#123; return null &#125; &#125; propsFunction 组件里的props12345678910111213// 1，直接写：export const TextField: React.FC&lt;&#123; text: string &#125;&gt; = () =&gt; &#123; return &lt;div&gt;&lt;input type=&quot;text&quot;/&gt;&lt;/div&gt;&#125;// 2. 将 &#123; text: string &#125; 独立为接口类：interface Props &#123; text: string&#125;export const TextField: React.FC&lt;Props&gt; = () =&gt; &#123; return &lt;div&gt;&lt;input type=&quot;text&quot;/&gt;&lt;/div&gt;&#125; 其中，接口也可随意扩展及定义子接口，如： 12345678910111213interface Person &#123; firstName: string lastName: string&#125;interface Props &#123; text: string ok?: boolean i?: number fn?: (bob: string) =&gt; string // person: Person&#125; Class 组件里的 props123456789101112131415161718192021// 1，直接写, 两个参数间用逗号或分号隔开均可：export class ClassTS extends React.Component &lt;&#123; text: string, age?: number &#125;&gt; &#123; &#125; // 2. 将props的参数独立为接口类：interface IProps &#123; text: string age?: number&#125;// 3. 顺带一提state，只有interface的写法：interface IState &#123; email: string name: string&#125;export class ClassTS extends React.Component &lt;IProps&gt; &#123; state: IState = &#123; name: &#x27;&#x27;, email: &#x27;&#x27; &#125;&#125; 组件里的函数React特有的类型，React.FormEvent，虚拟DOM把所有原生函数都撸了个遍: 1234handleChange = ( e : React.FormEvent&lt;HTMLInputElement&gt; ) =&gt; &#123; const &#123; name, value &#125; : any = e.target this.setState(&#123; [name]: value &#125;)&#125; 函数组件的 hooksuseState12345678// 或用 | ，不用 ||const [count, setCount] = useState &lt; string | null | &#123; text: string &#125; &gt;(&#123; text: &#x27;hello&#x27; &#125;)// 或 独立为接口：interface TextNode &#123; text: string&#125;const [count, setCount] = useState &lt; number | TextNode &gt;(5) useRef1234// 因为ref的目标是一个input框，所以用 &lt;HTMLInputElement&gt;// 如果打上ref的是&lt;div&gt;&lt;/div&gt;, 则用 &lt;HTMLDivElement&gt;const inputRef = useRef&lt;HTMLInputElement&gt;(null) 另外，handleChange 123456// 如果是Props传过来，并且定义了interface接口，则要注明：interface Props &#123; handleChange: ( event: React.ChangeEvent&lt;HTMLInputElement&gt; ) =&gt; void // 或者如下定义为any，但不建议，因失去了检查的作用： // handleChange: ( event: any ) =&gt; void&#125; useReducer12345678910111213141516171819202122interface Todos &#123; text: string complete: boolean&#125;// type State = Array&lt;Todos&gt;// 或下面这种，更形象化：type State = Todos[]type Actions = &#123; type: &#x27;add&#x27;, text: string &#125; | &#123; type:&#x27;remove&#x27;, idx: number &#125;const TodoReducer = ( state: State, action: Actions ) =&gt; &#123; switch (action.type) &#123; case &#x27;add&#x27;: return [...state, &#123; text: action.text, complete: false &#125;] case &#x27;remove&#x27;: return state.filter((_, i) =&gt; action.idx !== i) default: return state; &#125; &#125;const [todos, dispatch] = useReducer(TodoReducer, []) hooks 的 render props将 hooks 函数 setXXX 作为参数传参，这种props是react独有的，React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt; 123456789101112131415interface Props &#123; children:( count: number, // 将`setCount`作为props进行传参： setCount: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt; // 返回值为React独有的：JSX.Element ) =&gt; JSX.Element | null&#125;export const Counter: React.FC&lt;Props&gt; = (&#123; children &#125;) =&gt; &#123; const [count, setCount] = useState(0) return &lt;div&gt; &#123;children(count, setCount)&#125; &lt;/div&gt;&#125; 另一种，原生的函数在虚拟DOM里的函数： 写的时候 vs code 里的提示：","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zyzy.info/tags/React/"},{"name":"type script","slug":"type-script","permalink":"https://zyzy.info/tags/type-script/"}]},{"title":"Vue2+3自学笔记（一）","slug":"【2021-05-19】Vue2+3自学笔记（一）","date":"2021-05-19T08:20:33.000Z","updated":"2023-10-29T16:23:18.775Z","comments":true,"path":"2021/05/19/【2021-05-19】Vue2+3自学笔记（一）/","link":"","permalink":"https://zyzy.info/2021/05/19/%E3%80%902021-05-19%E3%80%91Vue2+3%E8%87%AA%E5%AD%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"一直以来，做项目都是用React，最近公司的项目接触到 Vue，这里先捡起多年未碰的 Vue ，写一些demo， 重温一下 Vue2 最简单的用法，并结合掘金的这篇文章，看看 Vue3 的新变化","text":"一直以来，做项目都是用React，最近公司的项目接触到 Vue，这里先捡起多年未碰的 Vue ，写一些demo， 重温一下 Vue2 最简单的用法，并结合掘金的这篇文章，看看 Vue3 的新变化 从 Vue2 开始搬砖，自己写了个TODO List，完整代码在这里，配合Vue官方文档内容，进行本文的阐述 脚手架开始项目安装 1yarn global add @vue/cli 脚手架创建项目并运行： 12vue create &lt;AppName&gt; &amp;&amp; cd &lt;AppName&gt;vue run serve import 后仍要声明组件由于vue是经过实例化的，属性都绑定在this上，以this作为中转，所以 import 后仍要在 component 中声明一次，否则报错： 123456789&lt;script&gt;import Header from &#x27;./components/Header&#x27;export default &#123; components: &#123; Header, &#125;,&#125;&lt;/script&gt; props 属性可以声明数组或对象声明对象时类似ts的类型检验 123456789 props: [&#x27;text&#x27;, &#x27;color&#x27;, &#x27;title&#x27;, &#x27;showAddTask&#x27;]// or props: &#123; text: String, color: String, title: String, showAddTask: Boolean &#125;, 插值表达式插值表达式其值可来自自身文件的 data 属性，也可来自 props 属性 12345678910&lt;button :style=&quot;&#123; background: color &#125;&quot; class=&quot;btn&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/button&gt; props: &#123; text: String &#125;, // or data: &#123; text: &#x27;hehe&#x27; &#125; 还有两个特殊的插值表达式 v-text 用于显示字符串： 123&lt;p v-text=&quot;data&quot;&gt;&lt;/p&gt;data: &#123; text: &#x27;我是要显示的信息&#x27; &#125; v-html 用于显示带HTML的文本： 123&lt;div v-html=&quot;data&quot;&gt;&lt;/div&gt;data: `&lt;a&gt;1111111111&lt;/a&gt;` 实际上，v-html 编译后长这样：123&lt;div&gt; &lt;a&gt;1111111111&lt;/a&gt;&lt;/div&gt; 数值绑定 v-bind: 或简写 :用于绑定样式： 123&lt;button v-bind:style=&quot;&#123; background: color &#125;&quot; class=&quot;btn&quot;&gt;x&lt;/button&gt;&lt;!-- 或简写为 --&gt;&lt;button :style=&quot;&#123; background: color &#125;&quot; class=&quot;btn&quot;&gt;x&lt;/button&gt; 事件绑定 v-on: 或简写 @12345678&lt;button @click=&quot;onClick()&quot; &gt;&#123;&#123; text &#125;&#125;&lt;/button&gt;// 需在 `methods` 里定义绑定事件：methods: &#123; onClick() &#123; // ... &#125;&#125; 还有动态参数的缩写(v2.6.0+)，类似属性选择器，eventName 方法名可动态传入，摘自官网： 1&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 循环 v-for 基础打法——用于数组，这里用在了组件 &lt;Task :task=&quot;task&quot; /&gt; 上， 必须绑定key 值， 和 React 一样，由于虚拟DOM Diff算法的原因，key不能用数组下标，必须是不重复的字符串： 123&lt;div v-for=&quot;task in tasks&quot; :key=&quot;task.id&quot;&gt; &lt;Task :task=&quot;task&quot; /&gt;&lt;/div&gt; 还可用于对象obj： 12345678910111213&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;data: &#123; object: &#123; title: &#x27;How to do lists in Vue&#x27;, author: &#x27;Jane Doe&#x27;, publishedAt: &#x27;2016-04-10&#x27; &#125;&#125; 显示为： How to do lists in Vue Jane Doe 2016-04-10 obj也可以用键值对解构显示，他还有第三个参数 index 123&lt;div v-for=&quot;(value, name, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 显示为： 0.title:How to do lists in Vue 1.name:Jane Doe 2.value:2016-04-10 你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法： 1&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt; 事件派发 $emit 与监听 :项目中我们最常用的数据流 子 ——&gt; 父 的方式就是 $emit ——&gt; @ ，如： 发射处，将id也一起发出， $emit(&#39;函数名&#39;, 发射的参数)，其中，发射的参数可以如下，一个简单的id1234&lt;div v-for=&quot;task of tasks&quot; :key=&quot;task.id&quot;&gt; &lt;Task :task=&quot;task&quot; @delete-task=&quot;$emit(&#x27;delete-task&#x27;, task.id)&quot; /&gt;&lt;/div&gt;&lt;script&gt; script 里也要注册该事件：1emits: [&#x27;delete-task&#x27;,], @ 接收该 emit 出来的事件，并命名： 1&lt;Task :task=&quot;task&quot; @delete-task=&quot;$emit(&#x27;delete-task&#x27;, task.id)&quot; /&gt; 在 script 里绑定 deleteTask(id)&#123;&#125; 事件，要注意，这里的 id 即为 $emit 传过来的第二个参数 1234567methods: &#123; deleteTask(id) &#123; if (confirm(&#x27;r u sure?&#x27;)) this.tasks = this.tasks.filter( task =&gt; task.id !== id ) &#125;, ...&#125; 双向数据绑定 v-model 这个是Vue框架的精华所在，抄袭Ng的，在输入处用 v-model 绑定： 123456789&lt;!-- form表单绑定 onSubmit 事件 --&gt;&lt;form class=&quot;add-form&quot; @submit=&quot;onSubmit&quot;&gt; &lt;!-- 搜集输入 --&gt; &lt;input type=&quot;text&quot; name=&quot;text&quot; placeholder=&quot;Add Task&quot; v-model=&quot;text&quot; &gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;Save Task&quot; class=&quot;btn btn-block&quot;&gt;&lt;/form&gt; script 里绑定 onSubmit(e) 事件 12345678910111213141516171819onSubmit(e) &#123; e.preventDefault() if (!this.text) &#123; alert(&#x27;Pls add a task&#x27;) return &#125; const newTask = &#123; id: Math.floor(Math.random() * 100000), text: this.text, day: this.day, reminder: this.reminder &#125; this.$emit(&#x27;add-task&#x27;, newTask) this.text = &#x27;&#x27; this.day = &#x27;&#x27; this.reminder = false&#125;","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://zyzy.info/tags/Vue/"}]},{"title":"标签模板（Tagged Template)——ES知识点补漏系列（2）","slug":"【2021-05-12】标签模板（Tagged-Template-——ES知识点补漏系列（2）","date":"2021-05-12T01:18:46.000Z","updated":"2023-10-29T16:23:18.775Z","comments":true,"path":"2021/05/12/【2021-05-12】标签模板（Tagged-Template-——ES知识点补漏系列（2）/","link":"","permalink":"https://zyzy.info/2021/05/12/%E3%80%902021-05-12%E3%80%91%E6%A0%87%E7%AD%BE%E6%A8%A1%E6%9D%BF%EF%BC%88Tagged-Template-%E2%80%94%E2%80%94ES%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E6%BC%8F%E7%B3%BB%E5%88%97%EF%BC%882%EF%BC%89/","excerpt":"![](https://cdn.jsdelivr.net/gh/ys558/my-blog-imgs@0.31/articles/标签模板（Tagged Template)——ES知识点补漏系列（2）/cover.jpg) 字符串模板相信大家用的挺多了，这里不赘述，今天解锁字符串模板的另一个功能，标签模板（Tagged Template）","text":"![](https://cdn.jsdelivr.net/gh/ys558/my-blog-imgs@0.31/articles/标签模板（Tagged Template)——ES知识点补漏系列（2）/cover.jpg) 字符串模板相信大家用的挺多了，这里不赘述，今天解锁字符串模板的另一个功能，标签模板（Tagged Template） 可作为传参用标签模板可用于传参，就行普通函数一样接收参数，请看示例代码： 12345678910const custom = (strings, ...placeholder) =&gt; &#123; console.log(strings) console.log(placeholder)&#125;const firstName = &#x27;呵呵&#x27;const hobby = &#x27;点赞&#x27;// 调用时改为标签模板传参，不用普通函数的()传参custom`my name is $&#123;firstName&#125;, my hobby is $&#123;hobby&#125;` 直接在控制台执行后，会发现结果如下： 12[ &#x27;my name is &#x27;, &#x27;, my hobby is &#x27;, &#x27;&#x27; ][ &#x27;呵呵&#x27;, &#x27;点赞&#x27; ] 我们发现标签模板实际上是一种特殊函数，接收两个参数 @第一个参数 ： 除了${}以外的部分字符串部分@第二个参数 ： ${}里面的部分，可以用解构…接收所有${}的参数，否则则按形参一个个按顺序传入 实际作用下面，我们就这种特殊函数的实际作用举2个例子 给特定文本添加样式标签模板被发明出来的最主要目的就是拼接HTML字符串的，下面我举2个例子： 用于一段文字中添加HTML样式： 12345const a = (arr, ...placeholder) =&gt; arr.reduce((prev, cur, i) =&gt; prev + `&lt;span class=&quot;addColor&quot;&gt;$&#123;placeholder[i-1]&#125;&lt;/span&gt;`+ cur)console.log(a`my name is $&#123;firstName&#125;, my hobby is $&#123;hobby&#125;`)// my name is &lt;span class=&quot;addColor&quot;&gt;呵呵&lt;/span&gt;, my hobby is &lt;span class=&quot;addColor&quot;&gt;点赞&lt;/span&gt; 用于校验HTML里的字符串，防止用户进行XSS攻击 12345678910111213141516171819202122function filterMsg(data) &#123; let ret = data[0] // 直接利用 function 的 arguments 参数进行拼接： for (let i = 1; i &lt; arguments.length; i++) &#123; const arg = String(arguments[i]) ret += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;) ret += data[i] &#125; return ret&#125;// 用户输入：const userInput = &#x27;&lt;script&gt;alert(&quot;123&quot;)&lt;/script&gt;&#x27;// 调用处：const safeMsg = filterMsg`&lt;div&gt;$&#123;userInput&#125; has been send&lt;/div&gt;`console.log(safeMsg)// 输出：// &lt;div&gt;&amp;lt;script&amp;gt;alert(&quot;123&quot;)&amp;lt;/script&amp;gt; has been send&lt;/div&gt;","categories":[],"tags":[{"name":"ES","slug":"ES","permalink":"https://zyzy.info/tags/ES/"}]},{"title":"Symbol的理解——ES知识点补漏系列（1）","slug":"【2021-05-11】Symbol的理解——ES知识点补漏系列（1）","date":"2021-05-11T01:27:58.000Z","updated":"2023-10-29T16:23:18.775Z","comments":true,"path":"2021/05/11/【2021-05-11】Symbol的理解——ES知识点补漏系列（1）/","link":"","permalink":"https://zyzy.info/2021/05/11/%E3%80%902021-05-11%E3%80%91Symbol%E7%9A%84%E7%90%86%E8%A7%A3%E2%80%94%E2%80%94ES%E7%9F%A5%E8%AF%86%E7%82%B9%E8%A1%A5%E6%BC%8F%E7%B3%BB%E5%88%97%EF%BC%881%EF%BC%89/","excerpt":"对于 Symbol 的理解，一直比较陌生，只知道他是 ES6 的语法规范，具体概念，可参考阮一峰老师的 Symbol 文章。这里我就自己的理解写，不讲概念，写一个容易理解的demo，介绍 Symbol 的作用。","text":"对于 Symbol 的理解，一直比较陌生，只知道他是 ES6 的语法规范，具体概念，可参考阮一峰老师的 Symbol 文章。这里我就自己的理解写，不讲概念，写一个容易理解的demo，介绍 Symbol 的作用。 传统obj key值的痛点一个亿万富豪，有几个儿子和女儿，还有一私生子，如果此时，我们直接这样定义这个亿万富豪： 12345let billionaire = &#123; son: [&#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27;,], daughter: [&#x27;daughter1&#x27;, &#x27;daughter2&#x27;], son: &#x27;bastard&#x27;&#125; 在控制台我们会发现，私生子bastard 会直接覆盖掉前面的son，这显然是不合适的 于是 Symbol 作为ES里原始的数据类型的作用就出现了 利用 Symbol 添加私生子, 解决痛点正确的做法应该如下，先定义了儿子和女儿们： 1234let billionaire = &#123; son: [&#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27;,], daughter: [&#x27;daughter1&#x27;, &#x27;daughter2&#x27;]&#125; 把私生子 son: &#39;bastard&#39; 单独抽出来，用 Symbol 定义，以下有3种定义方法： 1234567891011121314const son = Symbol(&#x27;son&#x27;)// 1.billionaire[son] = &#x27;bastard&#x27;// 2.let billionaire = &#123; son: [&#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27;,], daughter: [&#x27;daughter1&#x27;, &#x27;daughter2&#x27;], [son] : &#x27;bastard&#x27;&#125;// 3. Object.defineProperty(billionaire, son, &#123; value: &#x27;bastard&#x27; &#125;) 至此，Symbol 的作用很明确了， 由于 JS 的 obj key值为字符串，为了避免 JS 的 obj 中属性名字的冲突而产生 私生子身份神秘，普通new，. 等方法对其无效，只有亿万富翁自己知道由于 Symbol 是原始类型，没有构造函数，不能使用 new 关键字 也不能用 . 运算将其点出来： 私生子的身份确认如何得到保障？作为亿万富豪的私生子，只有亿万富豪自己一个人知道其身份，所以，我们用普通方法是找不到这个私生子的： 而私生子有独特的方法能得到确认，Symbol 为我们提供了几种方法 Object.getOwnPropertySymbols()1234const querySon = Object.getOwnPropertySymbols(billionaire)console.log(querySon)// [Symbol(son)] 多个私生子亿万富豪也可能有不止一个私生子，比如和 ‘知己小秘’ 生了一个私生子，和 ‘灵魂伴侣’ 又生了一个私生子，此时我们可以用 Symbol.for() 定义: 123456const bastard1 = Symbol.for(&#x27;知己小秘&#x27;)billionaire[bastard1] = &#x27;知己小秘儿子1&#x27;const bastard2 = Symbol.for(&#x27;灵魂伴侣&#x27;)billionaire[bastard2] = &#x27;灵魂伴侣儿子1&#x27;console.log(billionaire) 123456&#123; son: [ &#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27; ], daughter: [ &#x27;daughter1&#x27;, &#x27;daughter2&#x27; ], [Symbol(知己小秘)]: &#x27;知己小秘儿子1&#x27;, [Symbol(灵魂伴侣)]: &#x27;灵魂伴侣儿子1&#x27;&#125; Symbol key值同名时，其 value 也能被覆盖掉如果 ‘灵魂伴侣’ 又生多了一个私生子 ‘灵魂伴侣儿子2’ ，会出现什么情况？ 1234const bastard3 = Symbol.for(&#x27;灵魂伴侣&#x27;)billionaire[bastard3] = &#x27;灵魂伴侣儿子2&#x27;console.log(billionaire) 直接打印出来，会发现 value 值 ‘灵魂伴侣儿子2’ 覆盖掉了 ‘灵魂伴侣儿子1’ 123456&#123; son: [ &#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27; ], daughter: [ &#x27;daughter1&#x27;, &#x27;daughter2&#x27; ], [Symbol(知己小秘)]: &#x27;知己小秘儿子1&#x27;, [Symbol(灵魂伴侣)]: &#x27;灵魂伴侣儿子2&#x27;&#125; bastard2 和 bastard3 都是Symbol值，它们都是由同样参数的 Symbol.for 方法生成的key，所以实际上是仍是同一个值: 12console.log(bastard2 === bastard3)// true 查询所有儿女，包括私生子的Key值：Reflect.ownKeys()会以一个数组返回所有 Key 值，包括 Symbol Key 12console.log(Reflect.ownKeys(billionaire))// [ &#x27;son&#x27;, &#x27;daughter&#x27;, Symbol(知己小秘), Symbol(灵魂伴侣) ] Symbol.for() 和 Symbol() 生成的Key值有何不同Symbol.for() 会被登记在全局环境中供搜索，而 Symbol() 就不会，我们改动私生子为 Symbol() 生成，如： 12345678910const bastard1 = Symbol.for(&#x27;知己小秘&#x27;)billionaire[bastard1] = &#x27;知己小秘儿子1&#x27;const bastard2 = Symbol(&#x27;灵魂伴侣&#x27;)billionaire[bastard2] = &#x27;灵魂伴侣儿子1&#x27;console.log(bastard1, Symbol.keyFor(bastard1))console.log(bastard2, Symbol.keyFor(bastard2))// Symbol(知己小秘) 知己小秘// Symbol(灵魂伴侣) undefined 换句话说，Symbol.for() 每次生成前，会检查全局环境中是否存在该Key；Symbol() 则不会，每次调用会每次都生成 12345console.log(Symbol.for(&#x27;a&#x27;) === Symbol.for(&#x27;a&#x27;))// trueconsole.log(Symbol(&#x27;a&#x27;) === Symbol(&#x27;a&#x27;))// false","categories":[],"tags":[{"name":"ES","slug":"ES","permalink":"https://zyzy.info/tags/ES/"}]},{"title":"脱离脚手架webpack配制React+typescript项目（二）","slug":"【2021-05-04】脱离脚手架webpack配制React-typescript项目（二）","date":"2021-05-08T06:12:05.000Z","updated":"2023-10-29T16:23:18.775Z","comments":true,"path":"2021/05/08/【2021-05-04】脱离脚手架webpack配制React-typescript项目（二）/","link":"","permalink":"https://zyzy.info/2021/05/08/%E3%80%902021-05-04%E3%80%91%E8%84%B1%E7%A6%BB%E8%84%9A%E6%89%8B%E6%9E%B6webpack%E9%85%8D%E5%88%B6React-typescript%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BA%8C%EF%BC%89/","excerpt":"这节会着重介绍TS的配置，这个是对应的 repo","text":"这节会着重介绍TS的配置，这个是对应的 repo 安装jsx 语法里已支持了 TS, 要先安装以下两个库: 1yarn add @types/react @types/react-dom React TS的三种方案1. awesome-typescript-loader 方案 这种不建议, 因为该插件作者已经很久不更新了, 且有些检查不全面 2. ts-loader + fork-ts-checker-webpack-plugin 方案 webpack 编译会通过本地的 typescript , 所以本地必须安装 typescript, 本地 typescript 会调用 tsconfig.json 文件 每次文件改动时, ts-loader 都会进行转移和类型检查, 当文件多时, 速度会变慢 fork-ts-checker-webpack-plugin, 利用该插件开辟一个单独的线程去执行类型检查, 会提高 webpack 的编译速度. 该插件有最低安装要求: Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0） 先安装上述lib 1yarn add -D typescript ts-loader fork-ts-checker-webpack-plugin tsconfig.json 文件配置最主要是以下两项配置： 123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;jsx&quot;: &quot;preserve&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, // &quot;module&quot;: &quot;ESNEXT&quot;, &quot;target&quot;: &quot;es6&quot;, // &quot;esModuleInterop&quot;: true &#125;,&#125; jsx 参数有3个，分别是&#39;react&#39;，&#39;preserve&#39;，&#39;react-native&#39; &#39;react&#39; 模式下，ts 会将 tsx 编译成 jsx 后再将 jsx 编译成 js &#39;preserve&#39; 和 &#39;react-native&#39; 模式下：TS 会将 tsx 编译成 jsx 后，不再将 jsx 编译成 js，保留 jsx 。保留 jsx 时，就需要在webpack.config.js - module - ts-loader 的前面加上 babel-loader 去处理 jsx语法 &quot;moduleResolution&quot; 须配置为 &quot;node&quot;， 否则会报错如下 webpack.config.js 文件配置1234567891011121314151617181920212223242526272829303132333435const ForkTsCheckerWebpackPlugin = require(&#x27;fork-ts-checker-webpack-plugin&#x27;)module.export = &#123; ... module: &#123; rules: [ &#123; test: /\\.(jsx?)$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27;, options: &#123; cacheDirectory: true, cacheCompression: false &#125; &#125;, &#123; test: /\\.(tsx?)$/, exclude: /node_modules/, use: [ &#x27;babel-loader&#x27;, // 上面的 tsconfig.json 的 compilerOptions.jsx 值为 preserve，这里加上 abel-loader 转译 jsx &#123; loader: &#x27;ts-loader&#x27;, options: &#123; // disable type checker - we will use it in fork plugin transpileOnly: true, &#125;&#125; ]&#125;, ... ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;./src/index.html&quot;, inject: true, &#125;), // fork 一个进程进行检查： new ForkTsCheckerWebpackPlugin() ], &#125; 3. @babel/preset-typescript 方案 比较轻的方案, 直接通过 babel-loader 的插件进行转译, 本地无须安装 typescript , 因此不会去做类型检查 在 tsconfig.json 里配置后在控制台提示语法错误, 但不做强制性检查, 如果写法不严格, 项目也不会编译不通过 这种方案相比起上一种方案少了类型检查, 如果还想做类型检查, 须进行额外本地安装typescript , 且进行额外即配置, 运行 tsc 的命令 1yarn add -D @babel/preset-typescript babel.config.js 里增加该插件: 12345const presets = [ ... &#x27;@babel/preset-typescript&#x27; ... ] webpack.config.js 里相应的 module - rules 要做相应改动: 123rules: [ &#123; test: /\\.(jsx?|tsx?)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125;,] 以上配置, 就能顺利的写出 ts 语法了, 如:app.tsx 123456789101112131415161718192021import React, &#123; Component, FC &#125; from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;interface aProps &#123; data: string&#125;const A: React.FC&lt;aProps&gt; = (&#123;data&#125;) =&gt; &#123; return &lt;div&gt; &#123;data&#125; &lt;/div&gt;&#125;export default class App extends Component &#123; render() &#123; return &lt;div&gt; &lt;A data=&#x27;data from App&#x27; /&gt; &lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 额外多加监测tsc编译 本地应额外安装 typescript 语法功能： 1yarn add -D typescript 直接 tsc --watch 监听运行 也可以 script 里增加一个命令专门用于监听： 123&#123; &quot;ts-chk&quot;: &quot;tsc --watch&quot;&#125; tsconfig.json 12345678910&#123; &quot;compilerOptions&quot;: &#123; // 不生成编译文件，只做类型检查： &quot;noEmit&quot;: true, // js模块导入方式不做ts的检查： &quot;esModuleInterop&quot;: true, // 使其辨认jsx语法，需重启tsc监听： &quot;jsx&quot;: &quot;preserve&quot;, &#125;&#125; 其中，&quot;esModuleInterop&quot;: true 是由于TS的模块导入方式和JS不同，如果去掉会报以下错误： 按照其提示的错误 TS的导入规则，要改成这样，这显然不符合平时的习惯， 12import * as React from &#x27;react&#x27;import * as ReactDOM from &#x27;react-dom&#x27; 关于模块导入方式可以参考知乎的这篇文章","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zyzy.info/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"https://zyzy.info/tags/Webpack/"},{"name":"Babel","slug":"Babel","permalink":"https://zyzy.info/tags/Babel/"},{"name":"type script","slug":"type-script","permalink":"https://zyzy.info/tags/type-script/"}]},{"title":"脱离脚手架webpack配制React+typescript项目（一）","slug":"【2021-05-04】脱离脚手架webpack配制React+typescript项目（一）","date":"2021-05-04T03:11:58.000Z","updated":"2023-10-29T16:23:18.774Z","comments":true,"path":"2021/05/04/【2021-05-04】脱离脚手架webpack配制React+typescript项目（一）/","link":"","permalink":"https://zyzy.info/2021/05/04/%E3%80%902021-05-04%E3%80%91%E8%84%B1%E7%A6%BB%E8%84%9A%E6%89%8B%E6%9E%B6webpack%E9%85%8D%E5%88%B6React+typescript%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%B8%80%EF%BC%89/","excerpt":"如题。以前配过，但没直接支持ts的，这次复习一遍记录下来，webpack 这东西，在项目开始时整一次后经常就很少碰了，更要动手记录下来。","text":"如题。以前配过，但没直接支持ts的，这次复习一遍记录下来，webpack 这东西，在项目开始时整一次后经常就很少碰了，更要动手记录下来。 初始化项目1yarn init -y 基础安装配置 webpack 1yarn add webpack webpack-cli@3* -D babel 用于处理ES6+的代码转换 1yarn add -D @babel/core @babel/preset-env babel-loader 配置 less 、 sass 或 postcss 等样式预处理语言，这里三个都给他配上：autoprefixer 可以自动在样式中添加浏览器厂商前缀，避免手动处理样式兼容问题 123456# lessyarn add -D css-loader less less-loader style-loader# sass# postcss 配置处理 HTML 插件 1yarn add -D html-webpack-plugin 配置热更新插件 1yarn add -D webpack-dev-server 新建 src/app.js， webpack.config.js， src/index.html 1mkdir src &amp;&amp; touch src/app.js &amp;&amp; touch webpack.config.js 支持react的配置基础： 1yarn add react-dom react 支持各种语法：@babel/preset-react —— 支持 jsx 语法@babel/plugin-proposal-class-properties —— 支持 class 语法@babel/plugin-proposal-decorators —— 支持装饰器语法 1yarn add -D @babel/preset-react @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators babel 配置原来的 .babelrc 仅适用于简单单个包的静态配置， babel7+ 版本采用 babel.config.js，可以静态编译 node_modules 我们建议使用babel.config.js格式。babel本身正在使用它。 对于大型项目，babel官方还是建议采用 babel.config.js 文件进行配置，因为 .babelrc 是从每一个文件向上查找配置的，babel.config.js则不会 1touch babel.config.js 编写如下： 1234567891011121314module.exports = function (api) &#123; api.cache(true) const presets = [ [ &#x27;@babel/preset-env&#x27;, &#123; modules: false &#125; ], &#x27;@babel/preset-react&#x27;, ] const plugins = [ [&#x27;@babel/plugin-proposal-decorators&#x27;, &#123; legacy: true &#125;], [&#x27;@babel/plugin-proposal-class-properties&#x27;, &#123; loose: true &#125;] ] return &#123; presets, plugins &#125;&#125; 官方文档 webpack.config.js基础配制配置如下： 12345678910111213141516171819202122232425262728const path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry: &#x27;./src/app.js&#x27;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27;, library: &#x27;ReactByWebpack&#x27;, libraryTarget: &#x27;umd&#x27; &#125;, module: &#123; rules: [ &#123; test: /\\.(jsx?)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125;, &#123; test: /\\.less$/, exclude: /node_modules/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;]&#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;./src/index.html&quot;, &#125;) ], devServer: &#123; contentBase: &#x27;./dist&#x27;, port: 8888, compress: true &#125;&#125; 错误解决 ：webpack4 和 webpack-cli4 发生冲突1234567891011121314151617181920212223242526yarn run v1.22.10$ webpack-dev-serverinternal/modules/cjs/loader.js:883 throw err; ^Error: Cannot find module &#x27;webpack-cli/bin/config-yargs&#x27;Require stack:- E:\\study\\code\\tech-blog-code\\2021\\11-webpack-react-ts-config\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js at Function.Module._resolveFilename (internal/modules/cjs/loader.js:880:15) at Function.Module._load (internal/modules/cjs/loader.js:725:27) at Module.require (internal/modules/cjs/loader.js:952:19) at require (internal/modules/cjs/helpers.js:88:18) at Object.&lt;anonymous&gt; (E:\\study\\code\\tech-blog-code\\2021\\11-webpack-react-ts-config\\node_modules\\webpack-dev-server\\bin\\webpack-dev-server.js:65:1) at Module._compile (internal/modules/cjs/loader.js:1063:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10) at Module.load (internal/modules/cjs/loader.js:928:32) at Function.Module._load (internal/modules/cjs/loader.js:769:14) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12) &#123; code: &#x27;MODULE_NOT_FOUND&#x27;, requireStack: [ &#x27;E:\\\\study\\\\code\\\\tech-blog-code\\\\2021\\\\11-webpack-react-ts-config\\\\node_modules\\\\webpack-dev-server\\\\bin\\\\webpack-dev-server.js&#x27; ]&#125;error Command failed with exit code 1.info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command. 解决办法：从 webpack repo issue #1948 里可以找到答案: If you upgrade webpack to 5. *, and webpack cli to 4. *, an error &gt; will be reported: Error: Cannot find module ‘webpack-cli/bin/config-yargs’ Temporary solution:Back off webpack cli to version 3. * for example: “webpack-cli”: “^ 3.3.12” 须要把 webpack-cli 降回3及以下版本 12yarn remove webpack-cliyarn add -D webpack-cli@3 配置入口文件1mkdir src &amp;&amp; touch src/app.js &amp;&amp; touch src/index.html app.js12345678910111213import React, &#123; Component &#125; from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;const A = () =&gt; 123export default class App extends Component &#123; render() &#123; return &lt;div&gt; &lt;A/&gt; &lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) index.html123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&#x27;root&#x27;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行添加 script 如下 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot;, &quot;build&quot;: &quot;webpack --mode=production&quot;&#125;, 至此，普通的 React 项目已配置成功，可以尽情写 jsx 了，下一节会继续加上TS配置","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zyzy.info/tags/React/"},{"name":"Webpack","slug":"Webpack","permalink":"https://zyzy.info/tags/Webpack/"},{"name":"Babel","slug":"Babel","permalink":"https://zyzy.info/tags/Babel/"}]},{"title":"通过ReactHooks直接操作api神库：ReactQuery","slug":"【2021-04-26】通过ReactHooks直接操作api神库：ReactQuery","date":"2021-04-26T02:17:07.000Z","updated":"2023-10-29T16:23:18.774Z","comments":true,"path":"2021/04/26/【2021-04-26】通过ReactHooks直接操作api神库：ReactQuery/","link":"","permalink":"https://zyzy.info/2021/04/26/%E3%80%902021-04-26%E3%80%91%E9%80%9A%E8%BF%87ReactHooks%E7%9B%B4%E6%8E%A5%E6%93%8D%E4%BD%9Capi%E7%A5%9E%E5%BA%93%EF%BC%9AReactQuery/","excerpt":"React Query 是一个以react hooks为基础进行异步获取，缓存和更改数据的库，react query仓库文档原文描述： Hooks for fetching, caching and updating asynchronous data in React 换言之，是一个异步处理数据的库。这么重要而且好用的库当然要收入囊中，把他学起来，本篇着重介绍整个项目的构建过程。p.s 该篇的后端服务用这篇 配置的服务端","text":"React Query 是一个以react hooks为基础进行异步获取，缓存和更改数据的库，react query仓库文档原文描述： Hooks for fetching, caching and updating asynchronous data in React 换言之，是一个异步处理数据的库。这么重要而且好用的库当然要收入囊中，把他学起来，本篇着重介绍整个项目的构建过程。p.s 该篇的后端服务用这篇 配置的服务端 前端基础服务搭建初始化项目: 1npx create-react-app client &amp;&amp; cd client 安装依赖并运行:其中 react-hook-from @rebass/forms @rebass/preset styled-components react-loader-spinner 均为样式组件 12yarn add react-query react-router-dom react-hook-from @rebass/forms @rebass/preset styled-components react-loader-spinneryarn start 修改src/client.js 文件如下: QueryClientProvider文档 12345678910111213141516171819202122232425262728import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import &quot;react-loader-spinner/dist/loader/css/react-spinner-loader.css&quot;import App from &#x27;./App&#x27;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;import &#123; ThemeProvider &#125; from &quot;styled-components&quot;import preset from &quot;@rebass/preset&quot;// 核心部分: react-queryimport &#123; QueryClientProvider, QueryClient &#125; from &quot;react-query&quot;// 实例化queryClientconst queryClient = new QueryClient()ReactDOM.render( &#123;/* React严格模式，官方文档： https://react.html.cn/docs/strict-mode.html */&#125; &lt;React.StrictMode&gt; &#123;/* QueryClientProvider 可作为全局对象注入，类似 react-redux */&#125; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &#123;/* 样式组件： */&#125; &lt;ThemeProvider theme=&#123;preset&#125;&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/ThemeProvider&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById(&#x27;root&#x27;)) 基础路由模块及基础架构：src/App.js 利用 &#39;react-router-dom&#39; 作为路由的管理器，也是react常见的结构模式： 修改src/App.js文件如下: 12345678910111213141516import &#123; Switch, Route &#125; from &#x27;react-router-dom&#x27;import &#123; BooksList &#125; from &#x27;./BookList&#x27;import &#123; CreateBook &#125; from &#x27;./CreateBook&#x27;import &#123; UpdateBook &#125; from &#x27;./UpdateBook&#x27;function App() &#123; return &lt;&gt; &lt;Switch&gt; &lt;Route path=&#x27;/update-book/:id&#x27;&gt;&lt;UpdateBook/&gt;&lt;/Route&gt; &lt;Route path=&#x27;/create-book&#x27;&gt;&lt;CreateBook /&gt;&lt;/Route&gt; &lt;Route path=&#x27;/&#x27;&gt;&lt;BooksList /&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/&gt;&#125;export default App; 获取所有图书创建 src/BookList/index.js 和 src/BookList/BookList.jsx ： src/BookList/index.js: 1export * from &#x27;./BooksList&#x27; src/BookList/BookList.jsx: 123export const BooksList = () =&gt; &#123; return null&#125; 创建图书创建 src/BookList/index.js 和 src/BookList/BookList.jsx : src/CreateBook/index.js: 1export * from &#x27;./CreateBook&#x27; src/CreateBook/CreateBook.jsx: 12345678910export const CreateBook = () =&gt; &#123; return null&#125;``` ### 更新图书 创建 `src/BookList/index.js` 和 `src/BookList/BookList.jsx` : `src/UpdateBook/index.js`:```jsexport * from &#x27;./UpdateBook&#x27; src/UpdateBook/UpdateBook.jsx: 123export const UpdateBook = () =&gt; &#123; return null&#125; 基本结构：1234567891011src |_App.js |_BookList | |_index.js | |_BookList.jsx |_CreateBook | |_CreateBook.jsx | |_index.js |_UpdateBook |_UpdateBook.jsx |_index.js 添加导航栏样式src/shared/NavBar.jsx: 12345678910111213141516171819202122import &#123; Flex, Box, Link as StyledLink, Image &#125; from &#x27;rebass/styled-components&#x27;import &#123; Link &#125; from &#x27;react-router-dom&#x27;import &#123; Container &#125; from &#x27;./Container&#x27;import logo from &#x27;./logo.svg&#x27;export const NavBar = () =&gt; &#123; return &lt;Flex bg=&quot;black&quot; color=&quot;white&quot; justifyContent=&quot;center&quot;&gt; &lt;Container&gt; &lt;Flex px=&#123;2&#125; width=&#x27;100%&#x27; alignItems=&#x27;center&#x27;&gt; &lt;Image size=&#123;20&#125; src=&#123;logo&#125; /&gt; &lt;Link component=&#123;StyledLink&#125; variant=&#x27;nav&#x27; to=&#x27;/&#x27;&gt; React Query CRUD &lt;/Link&gt; &lt;Box mx=&quot;auto&quot;/&gt; &lt;Link component=&#123;StyledLink&#125; variant=&#x27;nav&#x27; to=&#x27;/create-book&#x27;&gt; + Add new book &lt;/Link&gt; &lt;/Flex&gt; &lt;/Container&gt; &lt;/Flex&gt;&#125; src/shared/Container.jsx : 1234567import &#123; Box &#125; from &#x27;rebass/styled-components&#x27;export const Container = (&#123;children&#125;) =&gt; &#123; return &lt;Box sx=&#123;&#123; width: &quot;100%&quot;, maxWidth: 1024, mx: &quot;auto&quot; &#125;&#125;&gt; &#123;children&#125; &lt;/Box&gt;&#125; 返回 src/App.js 把导航栏加上: 123import &#123; NavBar &#125; from &#x27;./shared/NavBar&#x27;&lt;NavBar/&gt; 创建 api.js 接口文件获取并数据：配制文件 .env路径必须在根目录 1REACT_APP_SERVER &#x3D; http:&#x2F;&#x2F;localhost:4800 src/api.js12345export const getAllBooks = async () =&gt; &#123; const response = await fetch(`$&#123;process.env.REACT_APP_SERVER&#125;/books`) if (!response.ok) throw new Error(&#x27;something wrong&#x27;) return response.json()&#125; 【 useQuery 】 应用 —— src/BookList.jsx 中查询所有图书123456789101112131415161718192021222324252627import &#123; useQuery &#125; from &#x27;react-query&#x27;import &#123; Flex &#125; from &#x27;rebass&#x27;import &#123; getAllBooks &#125; from &#x27;../api&#x27;import &#123; Container &#125; from &#x27;../shared/Container&#x27;import Loader from &#x27;react-loader-spinner&#x27;export const BooksList = () =&gt; &#123; // useQuery已经准备好了各种状态，直接调用即可： const &#123; data, error, isLoading, isError &#125; = useQuery(&#x27;books&#x27;, getAllBooks) if (isLoading) return &lt;Container&gt; &lt;Flex&gt; &lt;Loader type=&#x27;ThreeDots&#x27; color=&#x27;#ccc&#x27; height=&#123;30&#125; /&gt; &lt;/Flex&gt; &lt;/Container&gt; if (isError) return &lt;span&gt; Error: &#123;error.message&#125; &lt;/span&gt; return &lt;Container&gt; &lt;Flex flexDirection=&#x27;column&#x27; alignItems=&#x27;center&#x27;&gt; &#123; data.map((&#123;author, title, id&#125;) =&gt; &lt;div key=&#123;id&#125;&gt; &#123;author&#125; - &#123;title&#125; &lt;/div&gt; )&#125; &lt;/Flex&gt; &lt;/Container&gt;&#125; 此时界面可看到效果： 每条记录单独抽离做模块 src\\BookList\\BookItem.jsx123456789101112131415import &#123; Flex, Text, Button, Link as StyledLink &#125; from &#x27;rebass/styled-components&#x27;import &#123; Link &#125; from &#x27;react-router-dom&#x27;export const BookItem = (&#123; author, title, id &#125;) =&gt; &#123; return &lt;Flex p=&#123;3&#125; width=&quot;100%&quot; alignItems=&#x27;center&#x27;&gt; &lt;Link component=&#123;StyledLink&#125; to=&#123;`/update-book/$&#123;id&#125;`&#125; mr=&quot;auto&quot;&gt; &#123; title &#125; &lt;/Link&gt; &lt;Text&gt;&#123;author&#125;&lt;/Text&gt; &lt;Button ml=&quot;3&quot;&gt; remove &lt;/Button&gt; &lt;/Flex&gt;&#125; 从 src\\BookList\\BookList.jsx 导入并取代具体记录的位置12345import &#123; BookItem &#125; from &#x27;./BookItem&#x27;data.map((&#123;author, title, id&#125;) =&gt; &lt;BookItem author=&#123;author&#125; title=&#123;title&#125; id=&#123;id&#125; key=&#123;id&#125;/&gt;) 看看页面的效果： 【 useMutation 】和【 queryClient 】 的应用 —— 删除图书在 src\\api.js 增加删除接口：1234567export const removeBook = async id =&gt; &#123; const response = await fetch(`$&#123;process.env.REACT_APP_API_SERVER&#125;/books/$&#123;id&#125;`, &#123; method: &#x27;DELETE&#x27; &#125;) if (!response.ok) throw new Error(response.json().message) return true&#125; 为删除图书修改界面并在 src\\BookList\\BookList.jsx 里增加相应的 useMutation 和 queryClient 的写法： 1234567891011121314import &#123; removeBook &#125; from &#x27;../api&#x27;const queryClient = useQueryClient()// 将 removeBook 直接传入 useMutationconst &#123; mutateAsync, isLoading &#125; = useMutation(removeBook)const remove = async () =&gt; &#123; await mutateAsync(id) queryClient.invalidateQueries(&#x27;books&#x27;)&#125;&lt;Button ml=&quot;3&quot; onClick=&#123;remove&#125;&gt; &#123; isLoading ? &lt;Loader type=&#x27;ThreeDots&#x27; color=&#x27;#fff&#x27; height=&#123;10&#125; /&gt;: &#x27;Remove&#x27; &#125;&lt;/Button&gt; queryClient.invalidateQueries() 用于清除缓存并刷新页面： 来自中文官方文档的解释： 可以智能地将查询标记为过时的，并使之可用重新获取数据， 简言之，queryClient.invalidateQueries(&#39;books&#39;) 可清除旧 ‘books’ 的显示缓存，并直接刷新最新的 ‘books’ 接口数据，如果不加，页面就不会刷新，需要手动刷新 变更一本图书信息src\\api.js 增加获取一本书的接口：12345678export const getBook = async (&#123; queryKey &#125;) =&gt; &#123; // useQuery 传过来的参数： const [_key, &#123; id &#125;] = queryKey const response = await fetch(`$&#123;process.env.REACT_APP_API_SERVER&#125;/books/$&#123;id&#125;`) if (!response.ok) throw new Error(response.json().message) return response.json()&#125; src\\api.js 增加 updateBook 接口：123456789101112export const updateBook = async (&#123; id, ...data &#125;) =&gt; &#123; const response = await fetch(`$&#123;process.env.REACT_APP_API_SERVER&#125;/books/$&#123;id&#125;`, &#123; method: &#x27;PUT&#x27;, headers: &#123; &#x27;Content-Type&#x27; : &#x27;application/json&#x27; &#125;, body: JSON.stringify(data) &#125;) if (!response.ok) throw new Error(response.json().message) return response.json()&#125; 新建 src\\shared\\BookForm.jsx 用做更新图书的输入界面：12345678910111213141516171819202122232425import &#123; Box, Button &#125; from &#x27;rebass/styled-components&#x27;import &#123; Label, Input &#125; from &#x27;@rebass/forms&#x27;import &#123; useForm &#125; from &#x27;react-hook-form&#x27;import Loader from &#x27;react-loader-spinner&#x27;export const BookForm = (&#123; defaultValues, onFormSubmit, isLoading &#125;) =&gt; &#123; const &#123; register, handleSubmit &#125; = useForm(&#123; defaultValues &#125;) const onSubmit = handleSubmit( data =&gt; &#123; onFormSubmit(data) &#125;) return &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;Box sx=&#123;&#123; marginBottom : 3 &#125;&#125;&gt; &lt;Label htmlFor=&quot;title&quot;&gt;Title&lt;/Label&gt; &lt;Input ref=&#123;register&#125; id=&#x27;title&#x27; name=&#x27;title&#x27; type=&#x27;text&#x27; /&gt; &lt;/Box&gt; &lt;Box sx=&#123;&#123; marginBottom : 3 &#125;&#125;&gt; &lt;Label htmlFor=&#x27;author&#x27;&gt;Author&lt;/Label&gt; &lt;Input ref=&#123;register&#125; id=&#x27;author&#x27; name=&#x27;author&#x27; type=&#x27;text&#x27; /&gt; &lt;/Box&gt; &lt;Button&gt; &#123; isLoading ? &lt;Loader type=&#x27;ThreeDots&#x27; color=&#x27;#fff&#x27; height=&#123;10&#125; /&gt; : &#x27;Submit&#x27; &#125; &lt;/Button&gt; &lt;/form&gt;&#125; src\\UpdateBook\\UpdateBook.jsx 更改如下： 12345678910111213141516171819202122232425262728293031323334353637383940import Loader from &quot;react-loader-spinner&quot;import &#123; useMutation, useQuery &#125; from &quot;react-query&quot;import &#123; useHistory, useParams &#125; from &quot;react-router-dom&quot;import &#123; Box, Flex, Heading &#125; from &quot;rebass/styled-components&quot;import &#123; getBook, updateBook &#125; from &quot;../api&quot;import &#123; BookForm, Container &#125; from &quot;../shared&quot;export const UpdateBook = () =&gt; &#123; const &#123; id &#125; = useParams() const history = useHistory() // 获取单本书的接口： const &#123; data, error, isLoading, isError &#125; = useQuery([&#x27;book&#x27;, &#123;id&#125;], getBook) // 更改单本书 useMutation const &#123; mutateAsync, isLoading: isMutating &#125; = useMutation(updateBook) // 将数据传给后端： const onFormSubmit = async data =&gt; &#123; await mutateAsync(&#123; ...data, id &#125;) history.push(&#x27;/&#x27;) &#125; if ( isLoading ) return &lt;Container&gt; &lt;Flex&gt; &lt;Loader type=&#x27;ThreeDots&#x27; color=&#x27;#ccc&#x27; height=&#123;30&#125; /&gt; &lt;/Flex&gt; &lt;/Container&gt; if ( isError ) return &lt;Container&gt; &lt;Flex py=&#x27;5&#x27; justifyContent=&#x27;center&#x27;&gt; Error: &#123;error.message&#125; &lt;/Flex&gt; &lt;/Container&gt; return &lt;Container&gt; &lt;Box sx=&#123;&#123; py: 3 &#125;&#125;&gt; &lt;Heading sx=&#123;&#123; marginBottom: 3 &#125;&#125;&gt;Update Book&lt;/Heading&gt; &lt;BookForm defaultValues=&#123;data&#125; onFormSubmit=&#123;onFormSubmit&#125; isLoading=&#123;isMutating&#125; /&gt; &lt;/Box&gt; &lt;/Container&gt;&#125; 新建 src\\shared\\index.js 将所有共用组件导出： 123export * from &#x27;./Container&#x27;export * from &#x27;./BookForm&#x27;export * from &#x27;./NavBar&#x27; 看看页面的效果： 新建一本图书src\\api.js 里添加1234567891011export const createBook = async (data) =&gt; &#123; const response = await fetch(`$&#123;process.env.REACT_APP_API_SERVER&#125;/books/`, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(data) &#125;) if (!response.ok) throw new Error(response.json().message) return response.json()&#125; 更改创建图书界面 src\\CreateBook.jsx 如下：12345678910111213141516171819202122import &#123; useMutation &#125; from &quot;react-query&quot;import &#123; useHistory &#125; from &quot;react-router-dom&quot;import &#123; Box, Heading &#125; from &quot;rebass&quot;import &#123; createBook &#125; from &quot;../api&quot;import &#123; BookForm, Container, &#125; from &#x27;../shared&#x27;export const CreateBook = () =&gt; &#123; const history = useHistory() const &#123; mutateAsync, isLoading &#125; = useMutation(createBook) const onFormSubmit = async data =&gt; &#123; await mutateAsync(data) history.push(&#x27;/&#x27;) &#125; return &lt;Container&gt; &lt;Box sx=&#123;&#123; py: 3 &#125;&#125;&gt; &lt;Heading sx=&#123;&#123; marginBottom: 3 &#125;&#125;&gt;Create New Book&lt;/Heading&gt; &lt;BookForm onFormSubmit=&#123;onFormSubmit&#125; isLoading=&#123;isLoading&#125; /&gt; &lt;/Box&gt; &lt;/Container&gt;&#125; 看看页面的效果：","categories":[],"tags":[{"name":"React Query","slug":"React-Query","permalink":"https://zyzy.info/tags/React-Query/"}]},{"title":"SwaggerUI通过swagger-jsdoc在node里的应用和配置","slug":"【2021-04-25】SwaggerUI通过swagger-jsdoc在node里的应用和配置","date":"2021-04-25T00:48:17.000Z","updated":"2023-10-29T16:23:18.773Z","comments":true,"path":"2021/04/25/【2021-04-25】SwaggerUI通过swagger-jsdoc在node里的应用和配置/","link":"","permalink":"https://zyzy.info/2021/04/25/%E3%80%902021-04-25%E3%80%91SwaggerUI%E9%80%9A%E8%BF%87swagger-jsdoc%E5%9C%A8node%E9%87%8C%E7%9A%84%E5%BA%94%E7%94%A8%E5%92%8C%E9%85%8D%E7%BD%AE/","excerpt":"SwaggerUI，在Java里应该是常用工具，能根据api文件自动生成网页版的api文档界面，感觉挺有意思的，其实他支持各种语言，本篇分享一下在node里的简单配置方法，顺手搭建了个简单的服务。（p.s. 本篇后续有续篇，利用本篇的服务，介绍一下前端的状态管理组件React Query的玩法，配合本篇搭建的服务使用。）","text":"SwaggerUI，在Java里应该是常用工具，能根据api文件自动生成网页版的api文档界面，感觉挺有意思的，其实他支持各种语言，本篇分享一下在node里的简单配置方法，顺手搭建了个简单的服务。（p.s. 本篇后续有续篇，利用本篇的服务，介绍一下前端的状态管理组件React Query的玩法，配合本篇搭建的服务使用。） 基本架构初始化项目，安装依赖: 123npm init -yyarn add express lowdb morgan nanoid cors swagger-jsdoc swagger-ui-expresstouch index.js index.js 如下： 12345678910111213141516171819202122232425const express = require(&quot;express&quot;);const cors = require(&quot;cors&quot;);const morgan = require(&quot;morgan&quot;);const low = require(&quot;lowdb&quot;);const PORT = process.env.PORT || 4800const FileSync = require(&quot;lowdb/adapters/FileSync&quot;)// 用 db.json 文件充当数据库: const adapter = new FileSync(&quot;db.json&quot;)const db = low(adapter)db.defaults(&#123; books: [] &#125;).write()const app = express()app.db = dbapp.use(cors())app.use(express.json())app.use(morgan(&quot;dev&quot;))app.listen(PORT, () =&gt; console.log(`the server run on port $&#123;PORT&#125;`)) 试着运行一下，会发现生成了一个 db.json 文件，总体目录如下： server |__node_modules/ |__db.json |__index.js |__package.json |__yarn.lock 建立路由1mkdir route &amp;&amp; cd route &amp;&amp; touch books.js books.js 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const express = require(&quot;express&quot;);const router = express.Router()const &#123; nanoid &#125; = require(&quot;nanoid&quot;);const idLength = 8router.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const books = req.app.db.get(&#x27;books&#x27;) res.send(books)&#125;)router.get(&#x27;/:id&#x27;, (req, res) =&gt; &#123; const book = req.app.db.get(&#x27;books&#x27;).find(&#123; id: req.params.id &#125;).value() if (!book) res.send(404) res.send(book)&#125;)router.post(&#x27;/&#x27;, (req, res) =&gt; &#123; try &#123; const book = &#123; id: nanoid(idLength), ...req.body &#125; req.app.db.get(&#x27;books&#x27;).push(book).write() res.send(book) &#125;catch (error) &#123; return res.status(500).send(error) &#125;&#125;)router.put(&#x27;/:id&#x27;, (req, res) =&gt; &#123; try &#123; req.app.db.get(&#x27;books&#x27;).find(&#123; id: req.params.id &#125;).assign(req.body).write() res.send(req.app.db.get(&#x27;books&#x27;)).find(&#123;id: req.params.id&#125;) &#125;catch (error) &#123; return res.status(500).send(error) &#125;&#125;)router.delete(&#x27;/:id&#x27;, (req, res) =&gt; &#123; req.app.db.get(&#x27;books&#x27;).remove(&#123; id: req.params.id &#125;).write() res.sendStatus(200)&#125;)module.exports = router 应用SwaggerUI:在 index.js 里引用 SwaggerUI，添加如下配置： 12345678910111213141516171819202122const swaggerUI = require(&quot;swagger-ui-express&quot;);const swaggerJsDoc = require(&quot;swagger-jsdoc&quot;);const booksRouter = require(&quot;./route/books&quot;);const specs = swaggerJsDoc(&#123; definition: &#123; // 必须参数，不填则没有权限，填的话也只支持 3.0.n openapi: &quot;3.0.0&quot;, // 一些描述，可选： info: &#123; title: &quot;Library API&quot;, version: &quot;1.0.0&quot;, description: &quot;A simple Express Library API&quot; &#125;, servers: [&#123; url: &quot;http://localhost:4800&quot;&#125;], &#125;, apis: [&quot;./route/*.js&quot;]&#125;)app.use(&quot;/api-docs&quot;, swaggerUI.serve, swaggerUI.setup(specs))app.use(&#x27;/books&#x27;, booksRouter) 可在界面看到： 自动生成api文档页面：参照其文档，比较有意思的是swagger-jsdoc，他将多行注释里的api配置转换为页面的文档配置，我们将 route/books.js 改写为以下格式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * @swagger * components: * schemas: * Book: * type: object * required: * - title * - author * properties: * id: * type: string * description: The auto-generated id of the book * title: * type: string * description: The book title * author: * type: string * description: The book author * example: * id: d5fE_asz * title: The New Turing Omnibus * author: Alexander K. Dewdney *//** * @swagger * tags: * name: Books * description: The books managing API *//** * @swagger * /books: * get: * summary: Returns the list of all the books * tags: [Books] * responses: * 200: * description: The list of the books * content: * application/json: * schema: * type: array * items: * $ref: &#x27;#/components/schemas/Book&#x27; */router.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const books = req.app.db.get(&#x27;books&#x27;) res.send(books)&#125;)/** * @swagger * /books/&#123;id&#125;: * get: * summary: Get the book by id * tags: [Books] * parameters: * - in: path * name: id * schema: * type: string * required: true * description: The book id * responses: * 200: * description: The book description by id * contents: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; * 404: * description: The book was not found */router.get(&#x27;/:id&#x27;, (req, res) =&gt; &#123; const book = req.app.db.get(&#x27;books&#x27;).find(&#123; id: req.params.id &#125;).value() if (!book) res.send(404) res.send(book)&#125;)/** * @swagger * /books: * post: * summary: Create a new book * tags: [Books] * requestBody: * required: true * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; * responses: * 200: * description: The book was successfully created * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; * 500: * description: Server Error */router.post(&#x27;/&#x27;, (req, res) =&gt; &#123; try &#123; const book = &#123; id: nanoid(idLength), ...req.body &#125; req.app.db.get(&#x27;books&#x27;).push(book).write() res.send(book) &#125;catch (error) &#123; return res.status(500).send(error) &#125;&#125;)/** * @swagger * /books/&#123;id&#125;: * put: * summary: Update the book by the id * tags: [Books] * parameters: * - in: path * name: id * schema: * type: string * required: true * description: The book id * requestBody: * required: true * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; * responses: * 200: * description: The Book was updated * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; */router.put(&#x27;/:id&#x27;, (req, res) =&gt; &#123; try &#123; req.app.db.get(&#x27;books&#x27;).find(&#123; id: req.params.id &#125;).assign(req.body).write() res.send(req.app.db.get(&#x27;books&#x27;)).find(&#123;id: req.params.id&#125;) &#125;catch (error) &#123; return res.status(500).send(error) &#125;&#125;)/** * @swagger * /books/&#123;id&#125;: * delete: * summary: Update the book by the id * tags: [Books] * parameters: * - in: path * name: id * schema: * type: string * required: true * description: The book id * responses: * 200: * description: The Book was deleted * 404: * description: The Book was not found */router.delete(&#x27;/:id&#x27;, (req, res) =&gt; &#123; req.app.db.get(&#x27;books&#x27;).remove(&#123; id: req.params.id &#125;).write() res.sendStatus(200)&#125;)module.exports = router 重跑服务，可以发现以下界面： swagger-jsdoc 是通过 openapi 的3.0版本进行的改动，传统的 openapi 是通过独立的 json 文件对 swagger进行配置，不在本篇讨论范围，感兴趣的可以看看这篇国外的demo","categories":[],"tags":[{"name":"Swagger UI","slug":"Swagger-UI","permalink":"https://zyzy.info/tags/Swagger-UI/"},{"name":"后端","slug":"后端","permalink":"https://zyzy.info/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://zyzy.info/tags/Nodejs/"},{"name":"swagger-jsdoc","slug":"swagger-jsdoc","permalink":"https://zyzy.info/tags/swagger-jsdoc/"}]},{"title":"无限滚动和懒加载通过IntersectionObserver和React_Hooks实现","slug":"【2021-04-23】无限滚动和懒加载通过IntersectionObserver和React_Hooks实现","date":"2021-04-23T01:05:33.000Z","updated":"2023-10-29T16:23:18.773Z","comments":true,"path":"2021/04/23/【2021-04-23】无限滚动和懒加载通过IntersectionObserver和React_Hooks实现/","link":"","permalink":"https://zyzy.info/2021/04/23/%E3%80%902021-04-23%E3%80%91%E6%97%A0%E9%99%90%E6%BB%9A%E5%8A%A8%E5%92%8C%E6%87%92%E5%8A%A0%E8%BD%BD%E9%80%9A%E8%BF%87IntersectionObserver%E5%92%8CReact_Hooks%E5%AE%9E%E7%8E%B0/","excerpt":"用React Hooks做项目有一段时间了，炒鸡喜欢，这里结合 IntersectionObserver 原生js api及各种hooks，做个简单的无限滚动+懒加载页面，关于 IntersectionObserver， 阮大神的这篇博客文章里有非常详尽的描述（p.s. data用到数据接口需科学上网）","text":"用React Hooks做项目有一段时间了，炒鸡喜欢，这里结合 IntersectionObserver 原生js api及各种hooks，做个简单的无限滚动+懒加载页面，关于 IntersectionObserver， 阮大神的这篇博客文章里有非常详尽的描述（p.s. data用到数据接口需科学上网） 基础架构 用 create-react-app 构建项目后装 axios，App.js修改如下，页面呈现如下简单效果，即在输入框输入某一书籍关键字时，会出现对应所有的书籍列表： 1234567891011const App = () =&gt; &#123; return &lt;div&gt; &lt;input type=&quot;text&quot;/&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;div&gt;Error&lt;/div&gt; &lt;/div&gt;&#125; 自定义 custom hooks 作为异步请求数据：根据hooks习惯，名字用use开头： 1234567891011121314151617181920import &#123; useState, useRef, useCallback &#125; from &#x27;react&#x27;/** * @params * input 输入框输入需要查询的字段 * pageNum 页码，如果页面一页展示不玩，会持续添加pageNum*/export const useBookSearch = (query, pageNum) =&gt; &#123; useEffect(() =&gt; &#123; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://openlibrary.org/search.json&#x27;, params: &#123; q: query, page: pageNum &#125;, &#125;).then(res =&gt; &#123; // 远程获取数据，暂时控制台打印： console.log(res.data) &#125;) &#125;, [query, pageNum]) return null&#125; 在 App.js 里引入自定义hooks 123456789101112const App = () =&gt; &#123; useBookSearch(query, pageNum) return &lt;div&gt; &lt;input type=&quot;text&quot;/&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;div&gt;Error&lt;/div&gt; &lt;/div&gt;&#125; 实现动态效果 继续改造 App.js query 和 pageNum两个参数需要在本页进行变动，于是加入 useState 钩子 1234567891011121314151617181920212223import &#123; useState, useRef, useCallback &#125; from &#x27;react&#x27;const App = () =&gt; &#123; const [query, setInput] = useState(&#x27;&#x27;) const [pageNum, setPageNum] = useState(1) const handleSearch = e =&gt; &#123; setInput(e.target.value) // 重新输入查询字段后，页数重新设置为1： pageNum(1) &#125; useBookSearch(query, pageNum) return &lt;div&gt; &lt;input type=&quot;text&quot; onChange=&#123;handleSearch&#125;/&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;div&gt;Error&lt;/div&gt; &lt;/div&gt;&#125; query 通过输入框改变，传递给 useBookSearch(query, pageNum)，控制台能看到请求回来的数据，如下演示，但这种请求是实时的，即每输入一个字符就会请求一次，会浪费性能，必须优化 useBookSearch 优化请求性能： axios 有个参数 CancelToken，可取消重复请求，做如下改动： 123456789101112131415161718192021useEffect(() =&gt; &#123; setLoading(true) setError(false) // 定义取消变量 let cancel axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://openlibrary.org/search.json&#x27;, params: &#123; q: query, page: pageNum &#125;, // 执行取消变量： cancelToken: new axios.CancelToken(c =&gt; cancel = c) &#125;).then(res =&gt; console.log(res.data) ).catch(e =&gt; &#123; if (axios.isCancel(e)) return setError(true) &#125;) // 最后，useEffect里必须删除new出来的实例 return () =&gt; cancel()&#125;, [query, pageNum]) 改造完成后，继续重新尝试： 页面UI实现： 针对界面实现的丰富，我们对 useBookSearch 函数继续做改造，分别增加以下状态： loading : 读取 error : 获取数据错误 hasMore : 判断是否还有数据 books : 获取到的所有书籍的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243const useBookSearch = (query, pageNum) =&gt; &#123; const [loading, setLoading] = useState(true) const [error, setError] = useState([]) const [books, setBooks] = useState([]) const [hasMore, setHasMore] = useState(false) useEffect(() =&gt; &#123; setLoading(true) setError(false) let cancel axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://openlibrary.org/search.json&#x27;, params: &#123; q: query, page: pageNum &#125;, cancelToken: new axios.CancelToken(c =&gt; cancel = c) &#125;) .then(res =&gt; &#123; // 将后面请求回来books加入现有数组中：用Set去重： setBooks(prevBooks =&gt; &#123; return [...new Set([...prevBooks, ...res.data.docs.map(b =&gt; b.title)])] &#125;) // 每次只能显示满屏的数据，如果请求的数据没显示完 setHasMore(res.data.docs.length &gt; 0) // 则把loading显示为false setLoading(false) &#125;) .catch(e =&gt; &#123; if (axios.isCancel(e)) return // 设置错误： setError(true) &#125;) return () =&gt; cancel() &#125;, [query, pageNum]) // 每次改变 useEffect(() =&gt; &#123; setBooks([]) &#125;, [query]) // 将上面的状态一概导出，给App函数用： return &#123; loading, error, books, hasMore &#125;&#125; 改造主页面的 App 组件: 123456789101112131415161718192021222324import &#123; useState &#125; from &#x27;react&#x27;const App = () =&gt; &#123; const [query, setInput] = useState(&#x27;&#x27;) const [pageNum, setPageNum] = useState(1) // 将状态从useBookNameSearch解构出来： const &#123; books, hasMore, loading, error &#125; = useBookSearch(query, setPageNum) const handleSearch = e =&gt; &#123; setInput(e.target.value) pageNum(1) &#125; return ( &lt;&gt; &lt;input type=&quot;text&quot; onChange=&#123;handleSearch&#125;/&gt; &#123; books.map((book, index) =&gt; &lt;div key=&#123;book&#125;&gt;&#123;book&#125;&lt;/div&gt;)&#125; &lt;div&gt;&#123; loading &amp;&amp; &#x27;Loading...&#x27; &#125;&lt;/div&gt; &lt;div&gt;&#123; error &amp;&amp; &#x27;Error&#x27; &#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App; 最后，继续做翻页的部分，我们要实现的效果是，滚动到页面最下面，则自动触发loading和翻页，在 App 里用到useRef 钩子，检测到滚动到最后一行 用到 useCallback 钩子，具有缓存作用，依赖改变才重新渲染。 用到 IntersectionObserver api, 第一个参数为回调函数，其 entries 为检测到的触发的点 12345678910111213const last = useRef()const lastRecordRef = useCallback( node =&gt; &#123; if (loading) return if (observer.current) observer.current.disconnect() observer.current = new IntersectionObserver(entries =&gt; &#123; // entries[0].isIntersecting检测可见页面内是否需要调用新的数据： if( entries[0].isIntersecting &amp;&amp; hasMore ) &#123; setPageNum(prevPageNumber =&gt; prevPageNumber + 1) &#125; &#125;) // 检测是否最后一个节点node if (node) observer.current.observe(node)&#125;, [loading, hasMore] 控制台打印了entries[0].isIntersecting，当出现Loading状态时，该值为true, 单当完成加载后为false，如下： 贴出完整代码： App.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344import useBookSearch from &#x27;./useBookSearch&#x27;import &#123; useState, useRef, useCallback &#125; from &#x27;react&#x27;function App() &#123; const [query, setQuery] = useState(&#x27;&#x27;) const [pageNumber, setPageNumber] = useState(1) const &#123; books, hasMore, loading, error &#125; = useBookSearch(query, pageNumber) const observer = useRef() const lastBookElementRef = useCallback(node =&gt; &#123; if (loading) return if (observer.current) observer.current.disconnect() observer.current = new IntersectionObserver(entries =&gt; &#123; // detected is it the last one: if( entries[0].isIntersecting &amp;&amp; hasMore ) &#123; setPageNumber(prevPageNumber =&gt; prevPageNumber + 1) &#125; &#125;) if (node) observer.current.observe(node) &#125;, [loading, hasMore]) const handleSearch = e =&gt; &#123; setQuery(e.target.value) setPageNumber(1) &#125; return ( &lt;&gt; &lt;input type=&quot;text&quot; onChange=&#123;handleSearch&#125;/&gt; &#123; books.map( (book, index) =&gt; &#123; if (books.length === index + 1) &#123; return &lt;div ref=&#123;lastBookElementRef&#125; key=&#123;book&#125;&gt;&#123;book&#125;&lt;/div&gt; &#125;else&#123; return &lt;div key=&#123;book&#125;&gt;&#123;book&#125;&lt;/div&gt; &#125; &#125;)&#125; &lt;div&gt;&#123; loading &amp;&amp; &#x27;Loading...&#x27; &#125;&lt;/div&gt; &lt;div&gt;&#123; error &amp;&amp; &#x27;Error&#x27; &#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App; useBookSearch 独立成一个文件 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; useEffect, useState &#125; from &#x27;react&#x27;import axios from &#x27;axios&#x27;const useBookSearch = (query, pageNumber) =&gt; &#123; const [loading, setLoading] = useState(true) const [error, setError] = useState([]) const [books, setBooks] = useState([]) const [hasMore, setHasMore] = useState(false) useEffect(() =&gt; &#123; setLoading(true) setError(false) let cancel axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://openlibrary.org/search.json&#x27;, params: &#123; q: query, page: pageNumber &#125;, cancelToken: new axios.CancelToken(c =&gt; cancel = c) &#125;) .then(res =&gt; &#123; setBooks(prevBooks =&gt; &#123; return [...new Set([...prevBooks, ...res.data.docs.map(b =&gt; b.title)])] &#125;) setHasMore(res.data.docs.length &gt; 0) setLoading(false) &#125;) .catch(e =&gt; &#123; if (axios.isCancel(e)) return setError(true) &#125;) return () =&gt; cancel() &#125;, [query, pageNumber]) useEffect(() =&gt; &#123; setBooks([]) &#125;, [query]) return &#123; loading, error, books, hasMore &#125;&#125;export default useBookSearch","categories":[],"tags":[{"name":"React","slug":"React","permalink":"https://zyzy.info/tags/React/"},{"name":"React Hooks","slug":"React-Hooks","permalink":"https://zyzy.info/tags/React-Hooks/"},{"name":"IntersectionObserver","slug":"IntersectionObserver","permalink":"https://zyzy.info/tags/IntersectionObserver/"}]},{"title":"发现一免费CDN，我用来存该站的图","slug":"【2021-04-22】发现一免费CDN，我用来存该站的图","date":"2021-04-22T02:25:24.000Z","updated":"2023-10-29T16:23:18.773Z","comments":true,"path":"2021/04/22/【2021-04-22】发现一免费CDN，我用来存该站的图/","link":"","permalink":"https://zyzy.info/2021/04/22/%E3%80%902021-04-22%E3%80%91%E5%8F%91%E7%8E%B0%E4%B8%80%E5%85%8D%E8%B4%B9CDN%EF%BC%8C%E6%88%91%E7%94%A8%E6%9D%A5%E5%AD%98%E8%AF%A5%E7%AB%99%E7%9A%84%E5%9B%BE/","excerpt":"先上网址：https://www.jsdelivr.com/?docs=gh","text":"先上网址：https://www.jsdelivr.com/?docs=gh 说说我遇到的痛点，该站采用hexo生成，在网上搜了一圈，建议用hexo-asset-image工具，但_post文件夹里会多出一个文件夹专门用于存储图片，且该工具还有一点bug，虽然最后也解决了，但总有点不爽。思前想后，还是新建一个放图片的git repo最省事，如果直接贴仓库，可能速度有点慢，于是就得找CDN了。 CDN （Content Delivery Network/Content Distribution Network）内容分发网络。是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 选择了GitHub版本，操作如下： 首先，新建一个GitHub仓库：例如我自己的图片的仓库： https://github.com/ys558/my-blog-imgs 将你要放网络的图片推到你自己仓库 关键的一步：给仓库版本打标签，两个方法：方法一、命令行, 例如： 1git tag -a v1.4 -m &quot;my version 1.4&quot; 命令行更详细的操作可参考这里 方法二、推完图片后，直接在你github图片仓库上操作： 将你放图片链接的位置替换为 jsdelivr 举例的CDN格式即可，以我头像的图片举例，用GitHub的格式为： 1https://cdn.jsdelivr.net/gh/user/repo@version/file 替换为： 1https://cdn.jsdelivr.net/gh/ys558/my-blog-imgs@0.17/avatar/宇航员.svg","categories":[],"tags":[{"name":"CDN","slug":"CDN","permalink":"https://zyzy.info/tags/CDN/"}]},{"title":"GraphQL学习","slug":"【2021-04-20】GraphQL学习","date":"2021-04-20T02:15:27.000Z","updated":"2023-10-29T16:23:18.773Z","comments":true,"path":"2021/04/20/【2021-04-20】GraphQL学习/","link":"","permalink":"https://zyzy.info/2021/04/20/%E3%80%902021-04-20%E3%80%91GraphQL%E5%AD%A6%E4%B9%A0/","excerpt":"去年自学了GraphQL，这里重新整理一下笔记。国内使用GraphQL的项目毕竟还不多，这里写个demo，做个小小的探索。 GraphQL是facebook发明的一套API查询语言，支持多种语言，这里用js演示，官网有详细的说明比起传统的后端API整合","text":"去年自学了GraphQL，这里重新整理一下笔记。国内使用GraphQL的项目毕竟还不多，这里写个demo，做个小小的探索。 GraphQL是facebook发明的一套API查询语言，支持多种语言，这里用js演示，官网有详细的说明比起传统的后端API整合 GraphQL为你的API数据提供了一种完整且易于理解的描述。（GraphQL provides a complete and understandable description of the data in your API） 以上是官网对GraphQL的解释，利用GraphQL可以按需取字段给前端利用，不必取到不需要的字段，见下图解释： GraphQL则可以精确查找想要的字段，效率显著提高： 下面，结合自己写的demo：https://github.com/ys558/tech-blog-code/tree/master/2020/04-graphql-learn 完成以下完成本篇博客： 一、HelloWorld 将项目拉下来后，cd到对应目录下，用npm install或yarn安装依赖，运行npm run hello 或 yarn hello，先从 01helloworld.js 文件跑起，浏览器运行http://localhost:5000/左边输入框输入123query &#123; message&#125; 注意，这种是GraphQL特有的查询语法 点击运行，( 或快捷键 ctrl+enter ) 后，右边会显示： 01helloworld.js解析： graphqlHTTP 为 express-graphql 库解构的实例1const &#123; graphqlHTTP &#125; = require(&#x27;express-graphql&#x27;) GraphQL自带图形化界面且友好，，只需在实例 graphqlHTTP 中设置graphiql: true即可：1app.use(&#x27;/&#x27;, graphqlHTTP(&#123; schema, graphiql: true &#125;)) 在query实例中，fields 字段用于设置查询条件，是回调函数， fields 函数返回的东西用 resolve 函数接收其返回结果，接收结果也为回调函数 在接收结果中，可以规定其返回类型 type，其值为 Scalar Type (标量类型)1234567891011const schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: &#x27;helloWorld&#x27;, fields: () =&gt; (&#123; message: &#123; type: GraphQLString, resolve: () =&gt; &#x27;Hello World&#x27; &#125; &#125;) &#125;)&#125;) 二、基础操作 运行npm run ds2 或 yarn ds2，浏览器跑 http://localhost:5000/books， 123456&#123; books &#123; id name &#125;&#125; 输入以上条件，通过 books 字段查询其对应的 id, name 后运行，可以查询出以下结果： 02base.js 解析： books查询出来的为一数组，其标量 定义为 GraphQLList1234567891011121314151617181920212223const RootQueryType = new GraphQLObjectType(&#123; name: &#x27;Query&#x27;, description: &#x27;Root Query&#x27;, fields: () =&gt; (&#123; /* 第一个 books 是命名，也可叫 aaa，如果改 aaa 则 在 query 条件改为： aaa &#123; books &#123; id name &#125; &#125; */ books: &#123; // BookType as params pass to RootQueryType type: new GraphQLList(BookType), description: &#x27;List of all books&#x27;, // 这里的 books 对应实际的 books 数组， // 要查询数组 books里的东西： resolve: () =&gt; books &#125; &#125;)&#125;) BookType 独立为标量GraphQLObjectType的实例化，由于其为最后一层数据，无需向下深挖，所以resolve 方法不需要 GraphQLNonNull 表示该字段为必须字段12345678const BookType = new GraphQLObjectType(&#123; name: &#x27;Book&#x27;, description: &#x27;this is represents a book written by an author&#x27;, fields: () =&gt; (&#123; id: &#123; type: GraphQLNonNull(GraphQLInt) &#125;, name: &#123; type: GraphQLNonNull(GraphQLString) &#125;, &#125;)&#125;) 三、通过书籍查询对应作者（一对一关系查询）及作者查询对应的书籍信息（一对多查询） 跑 03listQuery.js 文件，输入 12345678&#123; authors &#123; books &#123; id name &#125; &#125;&#125; 可以得到结果： 解析03listQuery.js ： 可以按照上面的方法继续丰富查询，建立一个模拟数据 author ，内容如下： 12345const authors = [ &#123; id: 1, name: &#x27;J. K. Rowling&#x27;&#125;, &#123; id: 2, name: &#x27;J. R. R. Tolkien&#x27;&#125;, &#123; id: 3, name: &#x27;Brent Weeks&#x27;&#125;,] 同样的，建立两个实例查询对应信息：resolve 部分对应相应的数据 123456789101112&#123; books: &#123; type: new GraphQLList(BookType), description: &#x27;List of all books&#x27;, resolve: () =&gt; books &#125;, authors: &#123; type: new GraphQLList(AuthorType), description: &#x27;List of all Authors&#x27;, resolve: () =&gt; authors &#125;&#125; 根据上面的字段名字books 和 authors 创建对应的查询实例： books实例里，id, name, authorId 均是 books 对象里的，可直接查出， author字段在 author 数组里 books 数据有关联的是authorId，用js的数组方法.find()去找 books &lt;–&gt; authors 是一对一的关系，AuthorType本身就是GraphQLObjectType 标量，可直接使用 12345678910111213141516const BookType = new GraphQLObjectType(&#123; name: &#x27;Book&#x27;, description: &#x27;this is represents a book written by an author&#x27;, fields: () =&gt; (&#123; id: &#123; type: GraphQLNonNull(GraphQLInt) &#125;, name: &#123; type: GraphQLNonNull(GraphQLString) &#125;, authorId: &#123; type: GraphQLNonNull(GraphQLInt)&#125;, author: &#123; type: AuthorType, // query book by authorId resolve: book =&gt; &#123; return authors.find( author =&gt; author.id === book.authorId ) &#125; &#125; &#125;)&#125;) authors实例也是同样道理 authors &lt;–&gt; books 是一对多的关系，BookType实例要装入GraphQLList标量中 123456789101112131415const AuthorType = new GraphQLObjectType(&#123; name: &#x27;Author&#x27;, description: &#x27;this is represents a author of a book&#x27;, fields: () =&gt; (&#123; id: &#123; type: GraphQLNonNull(GraphQLInt) &#125;, name: &#123; type: GraphQLNonNull(GraphQLString) &#125;, // query author by book&#x27;s id books: &#123; type: new GraphQLList(BookType), resolve: author =&gt; &#123; return books.filter(book =&gt; book.authorId === author.id) &#125; &#125; &#125;)&#125;) 四、通过书籍id查询书本信息 运行04singleQuery.js，输入以下查询条件： 12345678&#123; book(id: 4) &#123; name author &#123; name &#125; &#125;&#125; 执行结果如下： 输入以下条件 12345678&#123; book(id: 4) &#123; name author &#123; name &#125; &#125;&#125; 执行结果如下： 04singleQuery.js解析： 从以上的查询条件 book(id: 4) 可看出，通过传参id查询具体书籍信息，这里的id就体现在args参数上： args 在 resolve 函数里处于第二个参数的位置1234567book: &#123; type: BookType, description: &#x27;A Single Book&#x27;, // must query this book by params of book id: args: &#123; id: &#123; type: GraphQLInt &#125; &#125;, resolve: ( parent, args ) =&gt; books.find( book =&gt; book.id === args.id )&#125;, 同样的， author也可以按照传入authorId查询得到：1234567author: &#123; type: AuthorType, description: &#x27;A Single Author&#x27;, // query an author by params of author id: args: &#123; id: &#123; type: GraphQLInt &#125; &#125;, resolve: ( parent, args ) =&gt; authors.find( author =&gt; author.id === args.id )&#125;, 用 author(id) 查询结果： 五、修改数据（MutationType） 运行yarn ds5，浏览器输入： 123456mutation &#123; addBook(name: &quot;new book&quot;, authorId: 1) &#123; id name &#125;&#125; 可以看到增加单本书成功： 输入： 12345mutation &#123; addAuthor(name: &quot;new author&quot;) &#123; name &#125;&#125; 可以看到增加一个作者成功： 点击右上角的 &lt; Docs，可以发现该文件的Mutation函数，其中!意为必要字段： 05mutationType.js解析： 想要实现 Mutation Type 须在GraphQLSchema实例里添加mutation类型：1234const Schema = new GraphQLSchema(&#123; query: RootQueryType, mutation: RootMutationType&#125;) 和普通的 Query Type 类似，只不过 Mutation Type 在 resolve 里直接对数据进行改动而已：123456789101112131415161718192021222324252627fields: () =&gt; (&#123; addBook: &#123; type: BookType, description: &#x27;Add a book&#x27;, args: &#123; name: &#123; type: GraphQLNonNull(GraphQLString) &#125;, authorId: &#123; type: GraphQLNonNull(GraphQLInt) &#125; &#125;, resolve: ( parent, args ) =&gt; &#123; const book = &#123; id: books.length + 1, name: args.name, authorId: args.authorId &#125; books.push(book) return book &#125; &#125;, addAuthor: &#123; type: AuthorType, description: &#x27;Add a author&#x27;, args: &#123; name: &#123; type: GraphQLNonNull(GraphQLString) &#125; &#125;, resolve: ( parent, args ) =&gt; &#123; const author = &#123; id: authors.length + 1, name: args.name &#125; authors.push(author) return author &#125; &#125;,&#125;)","categories":[],"tags":[{"name":"GraphQL","slug":"GraphQL","permalink":"https://zyzy.info/tags/GraphQL/"}]},{"title":"Github Page建站心得及所踩的坑","slug":"【2021-04-19】GithubPage建站心得及所踩的坑","date":"2021-04-19T02:46:18.000Z","updated":"2023-10-29T16:23:18.772Z","comments":true,"path":"2021/04/19/【2021-04-19】GithubPage建站心得及所踩的坑/","link":"","permalink":"https://zyzy.info/2021/04/19/%E3%80%902021-04-19%E3%80%91GithubPage%E5%BB%BA%E7%AB%99%E5%BF%83%E5%BE%97%E5%8F%8A%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91/","excerpt":"最近想用 github.io 建立我的个人博客站点，具体步骤我参考了知乎上的一篇文章，里面写的够清楚了，下面就建站时碰到的坑写的不完全总结，估计以后陆续增加","text":"最近想用 github.io 建立我的个人博客站点，具体步骤我参考了知乎上的一篇文章，里面写的够清楚了，下面就建站时碰到的坑写的不完全总结，估计以后陆续增加 ys558.github.io改为自己的域名去阿里云申请一个自己的域名后绑定原理的ys558.github.io域名，步骤： 登陆阿里云的万网，挑一个喜欢便宜的域名注册，我的域名 zyzy.info 一年只花21元，注册完成后选择个人站点，顺便也就开通了阿里云账号，如其他域名服务商，如申请.me结尾的个人网站，应该去GoDaddy等 依次进入右上角的 控制台 =&gt; 运维管理 选项卡下找到 域名 标签 =&gt; 点击 解析，如下： =&gt; 点击添加记录， 在 记录值 处填下ys558.github.io，如下，点击确定。这样就把你github.io上的页面绑定了购买的域名下 用ping 也可查询到新绑定的域名网址IP： 按以下命令在自己的github仓库中添加CNAME文件，其中填入购买的域名。或者可以在仓库的settings中设置Custom Domain设置好自己的域名，github会自动添加CNAME文件。 12touch CNAMEecho &#x27;zyzy.info&#x27;&gt; CNAME 图片显示错误：！！！该方法也是在网上搜索得到，虽可行，但解析中文路径时经常会出错，后来还是转用CDN，把图片全部移到另一个repo，推荐用CDN的方法，具体操作办法看我另一篇文章 需要安装一个图片路径转换的插件，这个插件名字是 hexo-asset-image 123npm i hexo-asset-image --save# oryarn add hexo-asset-image --save _config.yml文件，修改下述内容，用 hexo n &lt;博客文章名字&gt; 生成新博客时，会生成一个对应的文件夹，将图片放入该文件夹引用即可： 1post_asset_folder: true 修改博客目录下node_modules\\hexo-asset-image\\index.js (hexo文件有bug) 证书错误，不是私密连接Github建站好之后，经常会碰到打开页面浏览器显示不是私密链接的情况，搜来搜去，说是GitHub的SSL证书不稳定，不知道是不是墙的原因。 有两个方法可以解决：一是申请 cloudfare 的免费证书，二是自己买证书，两种方法都介绍以下 方法一： 某宝买证书去某宝买了证书，（p.s. 不差钱也可以直接买阿里云的证书，两年2000多），证书是有有效期的，我买的那家证书一年80元，两年140元，5年300元。选个自己能接受，不太贵的价格即可。一般销量高的店家都有教你怎么配置，我这里把其配置记录了下来： 1. 在 Github Page 上取消勾选 Enforce HTTPS 服务位置如下图： 2. 将买到的证书在阿里云上设置如下图顺序设置便可完成： 方法二：蹭 cloudfare 的免费证书1. 申请个 cloudfare 账号，并添加DNScloudfare 我的cloudfare是以前注册的，忘了一步步截图，但有中文界面跟着提示操作即可，不会很难，注册完成后，在以下界面操作： 找到github的ipv4的地址为以下几个，也不知道访问时会分配到哪个ip，索性A类地址全部添加上，像阿里云以下，把 CHAME 类地址也添加上，如下： 2. 返回阿里云添加 cloudfare 申请的DNS服务器 Github Page 更新自己的域名 点击仓库 ys558.github.io 里的 Settings 点击左侧的 Pages 在 Custom domain 里输入自己配置好DNS的域名 点击 Save, 则会自动检查域名是否可用","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://zyzy.info/tags/Hexo/"},{"name":"Github Page","slug":"Github-Page","permalink":"https://zyzy.info/tags/Github-Page/"}]}],"categories":[],"tags":[{"name":"bun","slug":"bun","permalink":"https://zyzy.info/tags/bun/"},{"name":"react","slug":"react","permalink":"https://zyzy.info/tags/react/"},{"name":"react Suspense","slug":"react-Suspense","permalink":"https://zyzy.info/tags/react-Suspense/"},{"name":"rust","slug":"rust","permalink":"https://zyzy.info/tags/rust/"},{"name":"enum","slug":"enum","permalink":"https://zyzy.info/tags/enum/"},{"name":"struct","slug":"struct","permalink":"https://zyzy.info/tags/struct/"},{"name":"ownership","slug":"ownership","permalink":"https://zyzy.info/tags/ownership/"},{"name":"cargo","slug":"cargo","permalink":"https://zyzy.info/tags/cargo/"},{"name":"type script","slug":"type-script","permalink":"https://zyzy.info/tags/type-script/"},{"name":"umijs","slug":"umijs","permalink":"https://zyzy.info/tags/umijs/"},{"name":"qiankun","slug":"qiankun","permalink":"https://zyzy.info/tags/qiankun/"},{"name":"esbuild","slug":"esbuild","permalink":"https://zyzy.info/tags/esbuild/"},{"name":"webpack","slug":"webpack","permalink":"https://zyzy.info/tags/webpack/"},{"name":"mono repo","slug":"mono-repo","permalink":"https://zyzy.info/tags/mono-repo/"},{"name":"yarn","slug":"yarn","permalink":"https://zyzy.info/tags/yarn/"},{"name":"lerna","slug":"lerna","permalink":"https://zyzy.info/tags/lerna/"},{"name":"conventional commit","slug":"conventional-commit","permalink":"https://zyzy.info/tags/conventional-commit/"},{"name":"React","slug":"React","permalink":"https://zyzy.info/tags/React/"},{"name":"面试","slug":"面试","permalink":"https://zyzy.info/tags/%E9%9D%A2%E8%AF%95/"},{"name":"Web性能优化","slug":"Web性能优化","permalink":"https://zyzy.info/tags/Web%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"name":"node cli","slug":"node-cli","permalink":"https://zyzy.info/tags/node-cli/"},{"name":"ssr","slug":"ssr","permalink":"https://zyzy.info/tags/ssr/"},{"name":"node","slug":"node","permalink":"https://zyzy.info/tags/node/"},{"name":"ES6","slug":"ES6","permalink":"https://zyzy.info/tags/ES6/"},{"name":"ESM","slug":"ESM","permalink":"https://zyzy.info/tags/ESM/"},{"name":"CJS","slug":"CJS","permalink":"https://zyzy.info/tags/CJS/"},{"name":"eventEmitter","slug":"eventEmitter","permalink":"https://zyzy.info/tags/eventEmitter/"},{"name":"npm package","slug":"npm-package","permalink":"https://zyzy.info/tags/npm-package/"},{"name":"JWT","slug":"JWT","permalink":"https://zyzy.info/tags/JWT/"},{"name":"Token","slug":"Token","permalink":"https://zyzy.info/tags/Token/"},{"name":"HOC","slug":"HOC","permalink":"https://zyzy.info/tags/HOC/"},{"name":"Webpack","slug":"Webpack","permalink":"https://zyzy.info/tags/Webpack/"},{"name":"Vue","slug":"Vue","permalink":"https://zyzy.info/tags/Vue/"},{"name":"Electron","slug":"Electron","permalink":"https://zyzy.info/tags/Electron/"},{"name":"后端","slug":"后端","permalink":"https://zyzy.info/tags/%E5%90%8E%E7%AB%AF/"},{"name":"Nginx","slug":"Nginx","permalink":"https://zyzy.info/tags/Nginx/"},{"name":"反向代理","slug":"反向代理","permalink":"https://zyzy.info/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/"},{"name":"Dart","slug":"Dart","permalink":"https://zyzy.info/tags/Dart/"},{"name":"flutter","slug":"flutter","permalink":"https://zyzy.info/tags/flutter/"},{"name":"Flutter","slug":"Flutter","permalink":"https://zyzy.info/tags/Flutter/"},{"name":"跨端","slug":"跨端","permalink":"https://zyzy.info/tags/%E8%B7%A8%E7%AB%AF/"},{"name":"ES","slug":"ES","permalink":"https://zyzy.info/tags/ES/"},{"name":"Babel","slug":"Babel","permalink":"https://zyzy.info/tags/Babel/"},{"name":"React Query","slug":"React-Query","permalink":"https://zyzy.info/tags/React-Query/"},{"name":"Swagger UI","slug":"Swagger-UI","permalink":"https://zyzy.info/tags/Swagger-UI/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://zyzy.info/tags/Nodejs/"},{"name":"swagger-jsdoc","slug":"swagger-jsdoc","permalink":"https://zyzy.info/tags/swagger-jsdoc/"},{"name":"React Hooks","slug":"React-Hooks","permalink":"https://zyzy.info/tags/React-Hooks/"},{"name":"IntersectionObserver","slug":"IntersectionObserver","permalink":"https://zyzy.info/tags/IntersectionObserver/"},{"name":"CDN","slug":"CDN","permalink":"https://zyzy.info/tags/CDN/"},{"name":"GraphQL","slug":"GraphQL","permalink":"https://zyzy.info/tags/GraphQL/"},{"name":"Hexo","slug":"Hexo","permalink":"https://zyzy.info/tags/Hexo/"},{"name":"Github Page","slug":"Github-Page","permalink":"https://zyzy.info/tags/Github-Page/"}]}