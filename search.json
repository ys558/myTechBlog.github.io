[{"title":"Kubernetes 基础","path":"/2024/05/26/【2024-05-26】Kubernetes 基础/","content":"Kubernetes 是一个开源的容器编排平台，可以轻松部署、扩展和管理容器化应用程序。这篇文章是我自学 Kubernetes 的过程，我将过程记录下来。 基础概念弄清楚 Kubernetes 服务，要先弄清以下几个 Kubernates 的基础概念 Node 一个节点（Node）是一个虚拟机或者物理机 Pod Pod 是 Kubernetes 最小的调度单元，一个 Pod 可以是一个或者多个容器（container）的组合，他创建了一个容器的运行环境，在这个容器中，容器可以共享一些资源，比如网络，存储以及一些运行时的配置等等。 比如我们有一个应用程序或一个数据库，我们可以将其分别放在两个不同的 pod 中。一个 Pod 运行一个容器，这是一种最佳实践。 当然，一些特殊情况，一个 Pod 也可运行多个容器，这种情况也仅限于这些容器是高度耦合的情况，即我们所说的边车模式 （Sidecar），如下图： Service 每个 pod 都会有一个集群内部的 IP 地址，外部不可以访问到。pod 并不是一个稳定的实例，十分容易被创建或销毁，当 pod 发生故障时，会被销毁，IP 地址就会变更。这时候就需要 Kubernetes 的 Service 来管理和创建 IP 地址的变更，如下图： service 上图的 service 连接数据库的 pod 和 App 的 pod，当 App 访问 Service 时，Service 会分配对应的数据库 IP 给 App 进行访问，如下图： Ingress 当我们服务在本地开发时，可以用 IP 和端口号访问节点，而当部署到生产环境时，则必须配置域名，通过域名来访问 而 Ingress 就是用来管理从集群外部访问集群内部服务的入口和方式的。可以根据 Ingress 规定不同的转发规则，访问集群内部不同的 Service 除此之外，Ingress 还可以配置 SSL 证书、负载均衡等等 ConfigMap 配置完上述描述的配置后，我们就可以提供对外服务了 但还忽略一个问题，例如应用程序的 pod 访问数据库 pod 时，开发中我们会把数据库的地址、端口等连接信息写到配置文件或者环境变量中，然后在应用程序中读取这些信息。这样做，配置信息与应用程序就耦合在一起了。 一旦数据库的地址或者端口发生变化，那我们就要重新编译应用程序，再重新部署到集群中。 为了解决以上问题，Kubernetes 提供了 ConfigMap 的功能，将一些配置信息封装起来，就可以在应用程序中读取和使用了。 Secret 就是 ConfigMap的延伸，对其里面的内容进行 base64 进行编码。ConfigMap是明文的，比如我们会配置数据库访问的用户名，密码等，Secret 对这些敏感信息做编码，注意，还不是加密。base64 编码可以通过编程语言进行解析。 User, C.role, Sa 这 3 个分别是身份认证、网络安全、访问控制 Volume我们知道 pod 是很容易被销毁的，数据库的 pod 一旦被销毁，其后果可能是灾难性的。K8s 提供了 Volume 组件，他可以将数据库 pod 的数据，同时同步挂载到本地的磁盘上或者集群外部的远程存储上。 这样即使 pod 被销毁，数据也能持久化存储。 Deployment现在为止，我们还须考虑到应用程序的 pod 高可用姓，比如某个应该程序的节点发生故障，或者节点需要升级或更新维护时，应用程序就会停止服务。这显然是不能接受的。 解决方法是复制多个 Node，并用 Service 进行几种管理，此时 k8s 会自动将请求分散到其他正常工作的节点上。 而 k8s 提供了一个 Deployment 组件，用于管理所有应用程序 pod，他可以定义和管理应用程序的副本数量，以及应用程序的更新策略，简化应用程序的部署和更新操作。如下图： Deployment 还具备 副本控制 ( 就是定义应用的副本数量，如上图，定义了 3 个，如果其中一个副本有故障，那么他会自动创建一个新的副本来替代原有副本，维持副本的数量在 3 个 ) 滚动更新 ( 可以定义应用程序的升级策略，用于应用程序的版本升级 ) 自动扩容 等高级功能。 StatefulSet相较于上面 Deployment 管理应用的副本，数据库其实也需要对应的副本管理工具，这个工具是 StatefulSet。 和应用不同的是，数据库的每个副本，都是有独立的状态的，而应用是无状态的。简单来说，10 秒前存入的数据的状态，和现在的数据的状态往往是不一样的。所以数据库的 pod，需要把数据同步到其他的副本中，或者把数据写入到一个共享的存储中。 和 Deployment 的功能类似，但 StatefulSet 还保证每个副本都有自己稳定的网络标识符和持久化存储。所以，像数据库，缓存，消息队列等等，以及一些保留了会话状态的应用，都使用 StatefulSet 来部署。 当然，一种更好的实践是将有状态的 pod 从各个节点中剥离出来，进行单独的部署 基础架构k8s 是一个典型的 master-worker架构。所以，比如以上所提到的部署了应用和数据库的节点，也被称为工作节点 worker node。而工作节点通常有多个，master只有一个，用于管理所有 worker node 工作节点 worker node 为了能提供对外服务，每个 Node 节点上都会包含 3 个对应的服务组件，分别是: kubelet，负责管理和维护每个节点上的 pod，也会定期从 api-server 组件接受新的 pod 规范，监视工作节点的运行情况，将信息汇报给 api-server kube-proxy，负责为 pod 提供网络代理和负载均衡 container runtime 容器运行时 container runtime 就是我们常说的 Docker-Engine，每个节点都必须有容器运行时，当然，容器运行时也不止 docker，还有如：Containerd，CRI-O，Mirantis 通常情况下，一个集群包含多个节点，节点间的通信和负载均衡器就是通过 k-proxy 管理节点 master node也称作 control panel 从上图可以看出，master 节点的结构和 worker 节点完全不同，他分别包括 API server，scheduler，control manager， etcd和 cloud control manager，通过 api server 来管理所有工作节点。 API server 就像一个集群的网关，是整个系统的入口。所有请求都会经过他，再由他分发给不同的组件进行处理。而且所有的组件间也会通过 API server 进行通信。 例如，当我们部署一个新应用 pod 时，那么可以用客户端，例如 kubectl 命令行，dashboard 或者其他的 UI 界面工具。 当使用kubectl 命令行创建新的 pod 时，这个请求会先到达 api server 并验证这个请求的合法性，验证通过后再转发给相应的 Scheduler 调度器组件进行处理 Scheduler 负责监控集群中所有节点资源的使用情况，根据一些调度策略，将 pod 调度到合适的节点上运行。 例如下图： 调度器会将 pod 部署时较为空闲的节点上运行 controller manager 控制者管理器，复制管理集群中各种资源对象的状态。比如任何一个节点上的 pod 发生故障时，必须有一种机制监测到这个故障，尽快对其进行处理。例如重启该 pod 或者新启用一个 pod 进行替换。 controller manager 是如何知道哪个节点发生故障的呢？这就需要下面介绍的 etcd 组件 etcd 这个是一个高可用的键值存储系统，类似 Redis，存储集群中所有资源对象的状态信息。比如哪个 pod 挂掉，哪个 pod 又被新创建了。可以理解为集群的大脑。是整个集群的数据存储中心。 cloud controller manager 云控制器管理器，他是用来和各种云上的 api 进行交互的。而且他能提供一致的管理接口，使得用户可以在不同云平台中管理他们的应用程序。 minicube 搭建单节点环境本文为了实践 k8s，在本地搭建了个模拟线上的简易版环境来学习 k8s。 minikube 是一个轻量级的 Kubernetes 实现，可在本地计算机上创建虚拟机，并部署仅包含一个节点的简单集群。 一般生产环境的 Kubernetes 集群，一般都是使用云厂商提供的 Kubernetes 服务，如阿里云的 ACK、腾讯云的 TKE、华为云的 CCE 、AWS 的 EKS 等 。他们需要多个节点的集群才能实现高可用。每个节点都是一个服务器或者虚拟机。所以本地开发环境可以使用 minikube 来验证 Kubernetes 的功能。 安装123456789# macOSbrew install minikube# Windowschoco install minikube# Linuxcurl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64sudo install minikube-linux-amd64 /usr/local/bin/minikube minikube 常用命令123456789# 帮助菜单minikube# 启动# 后面的参数是国内网络问题下载镜像失败时加，如果下载成功，不加也可以：minikube start --image-mirror-country=cn# 检查状态minikube status kubectl 命令安装完成 minikube 之后，附带 kubectl 命令，这个命令就是 Kubernetes 自带的和集群交互的命令 123(base) zyzy:~ $ kubectl get nodesNAME STATUS ROLES AGE VERSIONminikube Ready control-plane 8m9s v1.30.0 multipass 虚拟机 + K3s 的多节点集群搭建minikube 是一个单节点的集群环境，但是稍微复杂一点的环境就不适用了。这里我们用虚拟机和 k3s 技术，模拟一个多节点环境的搭建。 multipass 安装超级简单，点击这里 multipass 点击相应的版本安装即可 multipass 常用命令 创建一个 ubuntu1 虚拟机 12(base) zyzy:~ $ multipass launch --name k3s --cpus 2 --memory 4G --disk 10GLaunched: k3s 查看本机所运行的所有虚拟机 123(base) zyzy:~ $ multipass lsName State IPv4 Imagek3s Running 192.168.64.3 Ubuntu 24.04 LTS 进入 k3s 虚拟机系统 123(base) zyzy:~ $ multipass shell k3s。。。ubuntu@k3s:~$ 启用虚拟机 1(base) zyzy:~ $ multipass start k3s 停止虚拟机 1(base) zyzy:~ $ multipass stop k3s 删除虚拟机 1234(base) zyzy:~ $ multipass delete k3s# 永久删除已经delete的虚拟机(base) zyzy:~ $ multipass purge k3s 安装登录进虚拟机后，安装 k3s 的 master 节点： 1234curl -sfL https://get.k3s.io | sh -# 国内用户使用：curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn sh - kubectl命令验证是否安装成功： 123ubuntu@k3s:~$ sudo kubectl get nodesNAME STATUS ROLES AGE VERSIONk3s Ready control-plane,master 23s v1.29.4+k3s1 创建 worker node上面我们已经安装好了 master node，下面我们来安装 worker node 先在 master 节点上获取 token，并复制下来 1ubuntu@k3s:~$ sudo cat /var/lib/rancher/k3s/server/node-token 重新开一个 mac 的终端，输入 123(base) zyzy:~ $ TOKEN=$(multipass exec k3s sudo cat /var/lib/rancher/k3s/server/node-token)(base) zyzy:~ $ echo $TOKENK10dc6a... 可以看到能 echo 打印出相应的 token，证明 token 配置成功，再将 master 的 IP 地址配置到本地并验证 123(base) zyzy:~ $ MASTER_IP=$(multipass info k3s | grep IPv4 | awk &#x27;&#123;print $2&#125;&#x27;)(base) zyzy:~ $ echo $MASTER_IP192.168.64.3 我们可以继续创建两个 worker 节点并将其配置到 master 节点中 1234567multipass launch --name workder1 --cups 2 --memory 8G --disk 10Gmultipass launch --name workder2 --cups 2 --memory 8G --disk 10G# 在worker节点虚拟机上安装k3s，得用国内的镜像： for f in 1 2; do multipass exec worker$f -- bash -c &quot;curl -sfL https://rancher-mirror.rancher.cn/k3s/k3s-install.sh | INSTALL_K3S_MIRROR=cn K3S_URL=\\&quot;https://$MASTER_IP:6443\\&quot; K3S_TOKEN=\\&quot;$TOKEN\\&quot; sh -&quot; done 验证，让我们进入 k3s 的 master 节点中，可以看到 worker1 worker2节点已经加入到集群中： 1234567(base) zyzy:~ $ multipass shell k3s...ubuntu@k3s:~$ sudo kubectl get nodesNAME STATUS ROLES AGE VERSIONk3s Ready control-plane,master 55m v1.29.4+k3s1worker1 Ready &lt;none&gt; 15m v1.29.4+k3s1worker2 Ready &lt;none&gt; 15m v1.29.4+k3s1 kubectl 管理工具12# 进入k3smaster节点：multipass shell k3s 基础命令123456789# 查看帮助文档kubectl --help# 查看API版本kubectl api-versions# 查看集群信息kubectl cluster-info 创建 kubectl create 及运行kubectl (run | apply)1234567891011121314151617# 创建并运行一个指定的镜像kubectl run NAME --image=image [params...]# e.g. 创建并运行一个名字为nginx的Podkubectl run nginx --image=nginx# 根据nginx.yaml配置文件创建资源kubectl create -f nginx.yaml# 根据URL创建资源kubectl create -f https://k8s.io/examples/application/deployment.yaml# 根据目录下的所有配置文件创建资源kubectl create -f ./dir# 通过文件名或标准输入配置资源kubectl apply -f (-k DIRECTORY | -f FILENAME | stdin)# e.g.# 根据nginx.yaml配置文件创建资源kubectl apply -f nginx.yaml 查看 kubectl (get | describe)123456789101112131415161718192021# 其中，RESOURCE可以是以下类型：kubectl get pods / po # 查看Podkubectl get svc # 查看Servicekubectl get deploy # 查看Deploymentkubectl get rs # 查看ReplicaSetkubectl get cm # 查看ConfigMapkubectl get secret # 查看Secretkubectl get ing # 查看Ingresskubectl get pv # 查看PersistentVolumekubectl get pvc # 查看PersistentVolumeClaimkubectl get ns # 查看Namespacekubectl get node # 查看Nodekubectl get all # 查看所有资源# 后面还可以加上 -o wide 参数来查看更多信息kubectl get pods -o wide# 查看某一类型资源的详细信息kubectl describe RESOURCE NAME# e.g. 查看名字为nginx的Pod的详细信息kubectl describe pod nginx 调试 kubectl logs 交互 kubectl exec比如上面用 replilcaset 创建的 pod，查看日志 1sudo kubectl logs nginx-deployment-6d6565499c-bn7gd 也可以进入 pod 内部查看： 12ubuntu@k3s:~$ sudo kubectl exec -it nginx-deployment-6d6565499c-bn7gd -- /bin/bashroot@nginx-deployment-6d6565499c-bn7gd:/# 修改，删除和清理资源123456789101112131415161718192021222324# 更新某个资源的标签kubectl label RESOURCE NAME KEY_1=VALUE_1 ... KEY_N=VALUE_N# e.g. 更新名字为nginx的Pod的标签kubectl label pod nginx# 删除某个资源kubectl delete RESOURCE NAME# e.g. 删除名字为nginx的Podkubectl delete pod nginx# 删除某个资源的所有实例kubectl delete RESOURCE --all# e.g. 删除所有Podkubectl delete pod --all# 根据YAML配置文件删除资源kubectl delete -f FILENAME# e.g. 根据nginx.yaml配置文件删除资源kubectl delete -f nginx.yaml# 设置某个资源的副本数kubectl scale --replicas=COUNT RESOURCE NAME# e.g. 设置名字为nginx的Deployment的副本数为3kubectl scale --replicas=3 deployment/nginx 例如： 12345678910# 删除名为nginx的podubuntu@k3s:~$ sudo kubectl delete pod nginxpod &quot;nginx&quot; deleted# 删除名为 nginx-deployment 的 deploymentubuntu@k3s:~$ sudo kubectl delete deployment nginx-deploymentdeployment.apps &quot;nginx-deployment&quot; deletedubuntu@k3s:~$ sudo kubectl get allNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kubernetes ClusterIP 10.43.0.1 &lt;none&gt; 443/TCP 10h Deployment利用 kubectl 创建以上是创建的的基本命令，但实际操作中，创建一个 pod， 更提倡使用 Deployment 这样的上层资源来创建，具体如下： 12345# nginx-deployment 为别名kubectl create deployment nginx-deployment --image=nginx# 查看已创建的deploymentsudo kubectl get deployment 查看已创建的 Deployment 资源： 123456789101112131415# 查看所有pod，包括非deployment创建的ubuntu@k3s:~$ sudo kubectl get podNAME READY STATUS RESTARTS AGEnginx 1/1 Running 0 6h44mnginx-deployment-6d6565499c-bn7gd 1/1 Running 0 2m35s# 通过 deployment 查看 podubuntu@k3s:~$ sudo kubectl get deploymentNAME READY UP-TO-DATE AVAILABLE AGEnginx-deployment 1/1 1 1 85s# 通过 replicaset 查看 podubuntu@k3s:~$ sudo kubectl get replicasetNAME DESIRED CURRENT READY AGEnginx-deployment-6d6565499c 1 1 1 6m52s 修改 replicaset 副本数量： 上面的 replicaset 是通过 deployment 创建时自动生成的，实际上他是一个管理副本数量的组件 可以通过 edit 来编辑 replicaset 的 ymal 文本 12ubuntu@k3s:~$ sudo kubectl edit deployment nginx-deploymentdeployment.apps/nginx-deployment edited 当输入以上命令后，会自动进入 nginx-deployment 的 yaml 文件进行编辑，我们把replicas值改为 3 后保存退出 12345678910ubuntu@k3s:~$ sudo kubectl get podNAME READY STATUS RESTARTS AGEnginx 1/1 Running 0 7h11mnginx-deployment-6d6565499c-bn7gd 1/1 Running 0 29mnginx-deployment-6d6565499c-m26m2 1/1 Running 0 4m28snginx-deployment-6d6565499c-sjvql 1/1 Running 0 4m27subuntu@k3s:~$ sudo kubectl get replicasetNAME DESIRED CURRENT READY AGEnginx-deployment-6d6565499c 3 3 3 29m 查看后发现 pod 多了 3 个同属于一个 replicaset 的 pod 利用 yaml 文件创建 (重点)kubectl 命令行方式创建 pod 可以加入很多参数，例如我们上面举例过的 --image=nginx ，这个参数如果一多或者嵌套的话，那么命令行的方式是非常麻烦的，这时，更推荐利用 yaml 文件的方式创建。 yaml类似 Docerfile，创建后再用 kubectl 进行调用，pod 就会自动更新了。 具体步骤： 创建并编辑 yaml 文件 1ubuntu@k3s:~$ vim nginx-deployment.yaml 编辑如下，下面是一个最基本的 yml 文件 123456789101112131415161718apiVersion: apps/v1metadata: name: nginx-deploymentspec: # 顶层 spec 定义 deployment 的配置信息 selector: matchLabels: app: nginx replicas: 3 # replicas 定义副本数量 template: metadata: labels: app: nginx spec: # 底层 spec 定义 pod 的详细信息 containers: - name: nginx image: nginx:1.25 ports: - containerPort: 80 #向外暴露的端口 apiVersion : 指定 apiServer 版本，格式是：组别/版本号，group/version，组别经常有 apps(应用), batch(批处理), autoscaling(自动扩缩容) 等等 kind: 用来指定资源对象的类型 metadata: 定义资源对象的元数据，比如资源的名称，标签，命名空间等。 spec: 是 specification 的缩写，定义资源的各种配置信息，包括有多少个副本 (replicas), 像上面的 spec 有两层嵌套，第一层是定义 deployment 的信息，第二层是定义 Pod 的配置信息 经 yml 文件创建创建资源 kubectl create -f 123456789101112131415161718ubuntu@k3s:~$ sudo kubectl create -f nginx-deployment.yamldeployment.apps/nginx-deployment created# 检验ubuntu@k3s:~$ sudo kubectl get allNAME READY STATUS RESTARTS AGEpod/nginx-deployment-cd5968d5b-h4nng 1/1 Running 0 3h42mpod/nginx-deployment-cd5968d5b-bg649 1/1 Running 0 3h42mpod/nginx-deployment-cd5968d5b-qcs7t 1/1 Running 0 3h42mNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEservice/kubernetes ClusterIP 10.43.0.1 &lt;none&gt; 443/TCP 16hNAME READY UP-TO-DATE AVAILABLE AGEdeployment.apps/nginx-deployment 3/3 3 3 3h42mNAME DESIRED CURRENT READY AGEreplicaset.apps/nginx-deployment-cd5968d5b 3 3 3 3h42m 修改(kubectl apply) 删除 (kubectl delete) 12345678# 通过文件名或标准输入配置资源kubectl apply -f (-k DIRECTORY | -f FILENAME | stdin)# e.g.# 根据nginx.yaml配置文件创建资源kubectl apply -f nginx.yaml# 删除kubectl delete -f nginx-deployment.yaml Service利用 kubectl 创建上面我们用 Deployment 创建了 5 个 pod，我们可以用以下命令查询到其 IP 地址： 1234567ubuntu@k3s:~$ sudo kubectl get pod -o wideNAME READY STATUS RESTARTS AGE IP NODE NOMINATED NODE READINESS GATESnginx-deployment-cd5968d5b-h4nng 1/1 Running 0 4h3m 10.42.0.10 k3s &lt;none&gt; &lt;none&gt;nginx-deployment-cd5968d5b-bg649 1/1 Running 0 4h3m 10.42.3.4 worker2 &lt;none&gt; &lt;none&gt;nginx-deployment-cd5968d5b-qcs7t 1/1 Running 0 4h3m 10.42.1.5 worker1 &lt;none&gt; &lt;none&gt;nginx-deployment-cd5968d5b-rml8k 1/1 Running 0 2m32s 10.42.3.5 worker2 &lt;none&gt; &lt;none&gt;nginx-deployment-cd5968d5b-z8k52 1/1 Running 0 2m32s 10.42.1.6 worker1 &lt;none&gt; &lt;none&gt; 这些 pod 的 IP 地址都是节点内部地址，无法提供对外服务，所以我们必须创建 Service 并配置其外部服务 创建步骤： 1234# 创建服务命令sudo kubectl create service nginx-service# 对外暴露已有 deploymentsudo kubectl expose deployment nginx-deployment 查看已经创建服务： 1234ubuntu@k3s:~$ sudo kubectl get svcNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGEkubernetes ClusterIP 10.43.0.1 &lt;none&gt; 443/TCP 17hnginx-deployment ClusterIP 10.43.54.95 &lt;none&gt; 80/TCP 22s 删除服务： 1sudo kubectl delete service nginx-deployment 利用 yml 文件创建（重点）1vim nginx-service.yaml 内容如下： 12345678910111213apiVersion: v1kind: Servicemetadata: name: nginx-servicespec: type: NodePort # 指定对外暴露类型 selector: app: nginx ports: - protocol: TCP port: 80 # 对外端口 targetPort: 80 # pod内部端口 nodePort: 30080 type: 该参数指定了对外端口类型，如果不定义该字段，那么默认是 Cluster IP 类型服务，只能在节点内部间访问，NodePort为对外服务，具体类型参加下表 nodePort： 该参数指定了对外暴露的端口号，范围必须在 30000~32767之间 服务类型 描述 ClusterIP 默认类型，集群内部的服务 NodePort 节点端口类型，将服务公开到集群节点上 LoadBalancer 负载均衡类型，将服务公开到外部负载均衡器上 ExternalName 外部名称类型，将服务映射到一个外部域名上 Headless 无头类型，主要用于 DNS 解析和服务发现 启用： 1sudo kubectl apply -f nginx-service.yaml 查看 pod 的 ip 地址： 12345ubuntu@k3s:~$ sudo kubectl get nodes -o wideNAME STATUS ROLES AGE VERSION INTERNAL-IP EXTERNAL-IP OS-IMAGE KERNEL-VERSION CONTAINER-RUNTIMEk3s Ready control-plane,master 17h v1.29.4+k3s1 192.168.64.3 &lt;none&gt; Ubuntu 24.04 LTS 6.8.0-31-generic containerd://1.7.15-k3s1worker2 Ready &lt;none&gt; 17h v1.29.4+k3s1 192.168.64.6 &lt;none&gt; Ubuntu 24.04 LTS 6.8.0-31-generic containerd://1.7.15-k3s1worker1 Ready &lt;none&gt; 17h v1.29.4+k3s1 192.168.64.5 &lt;none&gt; Ubuntu 24.04 LTS 6.8.0-31-generic containerd://1.7.15-k3s1 复制一个任意一个 worker 节点的 ip，并在浏览器打开，发现打开成功，端口采用我们配置的 nodePort: 30080 portainer 图形界面管理工具安装及访问有两种方法： 获取 portainer 的 yaml 文件配置安装，安装在 master 节点 直接在 master 节点，即我们创建的 k3s 上执行kubectl apply -n portainer -f https://downloads.portainer.io/ce2-19/portainer.yaml -n 参数指定 pod 的命名空间，看起来更直观，有隔离不同项目和环境的作用 利用 helm 安装，安装在本地 helm 是 k8s 的包管理工具，利用以下命令安装 Mac 电脑： 1234brew install helmhelm repo add portainer https://portainer.github.io/k8s/helm update portainerhelm upgrade --install --create-namespace -n portainer portainer portainer/portainer --set tls.force=true 删除删除 portainer 时，由于我们加了命名空间，所以也要指定命名空间，如下： 1sudo kubectl delete namespace portainer 命名空间 kubectl get ns | namespace上面提到的命名空间，可以用以下命令查看所有集群里的命名空间 1234567ubuntu@k3s:~$ sudo kubectl get nsNAME STATUS AGEkube-system Active 18hkube-public Active 18hkube-node-lease Active 18hdefault Active 18hportainer Active 10m 上面 portainer是我们指定的命名空间，其余是 k8s 默认创建的 平时创建任何资源如果不指定命名空间，则全部默认放到 default 的命名空间里 从上图可以发现，如创建了命名空间的资源，查看时必须加上 -n 参数 访问这里我们要输入 master 节点的 IP，而不是 portainer 的 IP，所以本地访问 master 节点的 ip+端口号 30777，本地 master ip 用sudo kubectl get pod -o wide查找，例如浏览器访问 master 节点：http://192.168.64.3:30777 可以看到访问的页面：","tags":["Kubernetes","Docker","K8s","K3s","minikube","multipass","kubectl"]},{"title":"Node 的多进程管理————多核CPU解决计算密集型应用","path":"/2024/05/20/【2024-05-20】Node多进程解决计算密集型问题/","content":"最近面试被问到过的问题，查了资料后，自己总结一下记录下来。 问题的提出众所周知。Node.js 是单线程的，单线程特性使得能够以较低的系统资源消耗快速处理许多请求。 有异步 I/O，所以 Node.js 是可以处理 IO 密集型任务，但是 Node.js 碰到 CPU 密集型，或者说计算密集型任务（例如机器学习，求斐波那契数列，求素数等），node 的单线程优势就往往变成劣势。 有人说，那可以用他的异步队列来解决。那让我们看看 Promise 的代码： 123456789101112131415161718192021222324252627282930313233// serverWithPromises.jsconst express = require(&quot;express&quot;);const app = express();app.get(&quot;/isprime&quot;, async (req, res) =&gt; &#123; const startTime = new Date(); const result = await isPrime(parseInt(req.query.number)); const endTime = new Date(); res.json(&#123; number: parseInt(req.query.number), isprime: result, time: endTime.getTime() - startTime.getTime() + &quot;ms&quot;, &#125;);&#125;);app.get(&quot;/testrequest&quot;, (req, res) =&gt; &#123; res.send(&quot;I am unblocked now&quot;);&#125;);const isPrime = (number) =&gt; &#123; return new Promise((resolve) =&gt; &#123; let isPrime = true; for (let i = 3; i &lt; number; i++) &#123; if (number % i === 0) &#123; isPrime = false; break; &#125; &#125; resolve(isPrime); &#125;);&#125;;app.listen(3000, () =&gt; console.log(&quot;listening on port 3000&quot;)); 可以看出 Promise 是异步的部分在 .then()代码里，但是他自身的阻塞是无法避免的，例如上面的代码，我们把for (let i = 3; i &lt; number; i++) 改成 for (let i = 3; i &lt; 1000000000; i++)，那么整个任务就会卡死。从而阻塞 &#39;/testrequest&#39; api 的请求。 Promise 之所以在 JavaScript 社区中被推崇为“异步非阻塞操作”的一种方式，是因为 Promise 擅长完成需要更多时间而不是更多 CPU 的工作。 这里所说的“需要更多时间的工作”通常包括：数据库通信、跨服务器通信等，这也是 Web 服务器所做的 99% 的工作。 JavaScript Promise 通过将任务推送到特殊队列并侦听事件（例如：数据库返回）发生并在该事件发生时执行一个回调函数，这就是著名的事件循环。 1234567891011121314151617181920212223import express from &quot;express&quot;;import fetch from &quot;node-fetch&quot;;const app = express();// node-fetch 用于在Nodejs中发送情况app.get(&quot;/calltoslowserver&quot;, async (req, res) =&gt; &#123; const result = await fetch(&quot;http://localhost:5000/slowrequest&quot;); // 返回一个Promise const resJson = await result.json(); res.json(resJson);&#125;);app.get(&quot;/slowrequest&quot;, (req, res) =&gt; &#123; setTimeout(() =&gt; res.json(&#123; message: &quot;sry i was late&quot; &#125;), 20000); // setTimeout 模拟10s的时间花销，即使花销很长时间也不会阻塞其他访问&#125;);app.get(&quot;/testrequest&quot;, (req, res) =&gt; &#123; res.send(&quot;I am unblocked now&quot;);&#125;);app.listen(4000, () =&gt; console.log(&quot;listening on port 4000&quot;)); 在上面的示例中可以看到，即使对 /slowrequest 或者 /calltoslowserver 的调用花费了很长时间，所有其他请求，比如：/testrequest，都没有被阻止。 这是因为 node-fetch 的 fetch 函数返回一个 Promise，而 这种单线程、非阻塞、异步的处理方式是 Node 中默认的。 解决方案Node js 提供了三种解决方案来解决上面问题。 child_process 模块child_process 模块提供了生成拥有自己内存的新进程的能力， 这些进程之间的通信是通过 OS 提供的 IPC（Inter-process Communication）建立。 该模块内部主要有 3 个 api： child_process.exec() child_process.spawn() child_process.fork() exec()该 api 允许你执行系统命令。虽然它不能直接解决 CPU 密集型任务，但你可以使用它来调用其他语言编写的程序或脚本来处理 CPU 密集型任务，如计算斐波那契数列。 首先我们写一个 fibonacci.py 文件： 1234567891011121314# fibonacci.pyimport sysdef fibonacci(n): if n &lt;= 0: return 0 elif n == 1: return 1 else: return fibonacci(n-1) + fibonacci(n-2)if __name__ == &quot;__main__&quot;: n = int(sys.argv[1]) print(fibonacci(n)) 接下来，在 Express 中使用 child_process.exec() 调用这个 Python 脚本： 12345678910111213141516171819202122232425262728293031323334const express = require(&quot;express&quot;);const bodyParser = require(&quot;body-parser&quot;);// npm i express body-parserconst &#123; execSync, exec &#125; = require(&quot;child_process&quot;);const app = express();const port = 3000;app.use(bodyParser.json());// 阻塞接口的示例app.post(&quot;/testblock&quot;, (req, res) =&gt; &#123; const number = req.body.number || 10; // 使用 execSync 会阻塞Node.js事件循环 const result = execSync(`python fibonacci.py $&#123;number&#125;`).toString().trim(); res.json(&#123; fibonacci: result &#125;);&#125;);// 非阻塞接口的示例app.post(&quot;/fibonaccipy&quot;, (req, res) =&gt; &#123; const number = req.body.number || 10; exec(`python fibonacci.py $&#123;number&#125;`, (error, stdout, stderr) =&gt; &#123; if (error) &#123; return res.status(500).json(&#123; error: `执行的错误: $&#123;error.message&#125;` &#125;); &#125; if (stderr) &#123; return res.status(500).json(&#123; error: `标准错误输出: $&#123;stderr&#125;` &#125;); &#125; res.json(&#123; fibonacci: stdout.trim() &#125;); &#125;);&#125;);app.listen(port, () =&gt; &#123; console.log(`Server is running on port $&#123;port&#125;`);&#125;); 在这个示例中，我们创建了两个 POST 接口。/testblock接口使用 execSync 来同步执行 Python 脚本，这会阻塞 Node.js 的事件循环，直到 Python 脚本执行完成。而/fibonaccipy 接口则使用 exec 来异步执行 Python 脚本，不会阻塞 Node.js 的事件循环。 spawn()该方法用于异步生成子进程，该子进程可以是允许终端运行的任何命令。用法与上一个 exec() 方法类似，但 spawn() 方法返回一个 ChildProcess 对象，该对象具有 stdout 和 stderr 属性，用于读取子进程的输出。他可以和子进程间进行通信，获取其输出，这点是 exec() 方法无法做到的。 123456789101112131415161718192021const express = require(&quot;express&quot;);const app = express();const &#123; spawn &#125; = require(&quot;child_process&quot;);// 导入child_process子进程app.get(&quot;/ls&quot;, (req, res) =&gt; &#123; const ls = spawn(&quot;ls&quot;, [&quot;-lash&quot;, req.query.directory]); ls.stdout.on(&quot;data&quot;, (data) =&gt; &#123; // stdin,stdout,stderr 管道（connection）是通过父级parent建立的 // Node.js 进程和生成的子进程，可以在标准输出上监听数据事件 res.write(data.toString()); // 日期将以流（数据块）的形式出现 // 由于 res 是一个可写流，支持写入 &#125;); ls.on(&quot;close&quot;, (code) =&gt; &#123; console.log(`child process exited with code $&#123;code&#125;`); res.end(); // 最后，当子进程退出时，所有写入的流都会被发送回来 &#125;);&#125;);app.listen(7000, () =&gt; console.log(&quot;listening on port 7000&quot;)); fork() 重点关注child_process.fork() 专门用于生成新的 Nodejs 进程。 与 spawn 一样，返回的 childProcess 对象将具有内置的 IPC 通信通道，允许消息在父进程和子进程之间来回传递。 例如以下主程序代码： 1234567891011121314151617181920212223const express = require(&quot;express&quot;);const app = express();const &#123; fork &#125; = require(&quot;child_process&quot;);app.get(&quot;/isprime&quot;, (req, res) =&gt; &#123; const childProcess = fork(&quot;./forkedchild.js&quot;); // fork() 的第一个参数是子进程要运行的 js 文件的名称 childProcess.send(&#123; number: parseInt(req.query.number) &#125;); // send方法用于通过IPC向子进程发送消息 const startTime = new Date(); childProcess.on(&quot;message&quot;, (message) =&gt; &#123; // on(&quot;message&quot;)方法用于监听子进程发送的消息 const endTime = new Date(); res.json(&#123; ...message, time: endTime.getTime() - startTime.getTime() + &quot;ms&quot;, &#125;); &#125;);&#125;);app.get(&quot;/testrequest&quot;, (req, res) =&gt; &#123; res.send(&quot;I am unblocked now&quot;);&#125;);app.listen(3636, () =&gt; console.log(&quot;listening on port 3636&quot;)); 其中，forkedchild.js 文件如下： 1234567891011121314151617181920212223process.on(&quot;message&quot;, (message) =&gt; &#123; //子进程正在监听父进程的消息 const result = isPrime(message.number); process.send(result); // 使用后要exit() 防止进程孤立 process.exit();&#125;);function isPrime(number) &#123; let isPrime = true; for (let i = 3; i &lt; number; i++) &#123; if (number % i === 0) &#123; isPrime = false; break; &#125; &#125; return &#123; number: number, isPrime: isPrime, &#125;;&#125; 此时当访问 /isprime?number=29355126551 时候虽然浏览器也会一直处于 loading 等待直到返回，但是此时不会阻塞后续的其他请求，比如：/testrequest api 的请求。 总结： 如果你需要执行一个简短的命令并获取其完整输出，可以使用 exec()。 如果你需要处理大量数据或需要与子进程进行实时通信，应该使用 spawn()。 如果你正在创建多个 Node.js 工作进程，并希望通过 IPC 进行通信，那么 fork() 是最佳选择。 cluster 模块cluster 主要用于垂直（为现有机器添加更多功能）扩展 Nodejs Web 服务器，构建在 child_process 模块之上。 在 Http 服务器中，cluster 模块使用 child_process.fork() 自动 fork 进程并建立主从架构，其中父进程以循环方式将传入请求分发给子进程。 理想情况下，fork 的进程数应等于计算机具有的 CPU 核数。 下面示例使用 cluster 模块构建一个 Express 服务器： 123456789101112131415161718192021222324252627282930313233343536const cluster = require(&quot;cluster&quot;);const http = require(&quot;http&quot;);const cpuCount = require(&quot;os&quot;).cpus().length;// 返回cpu的核数if (cluster.isMaster) &#123; masterProcess();&#125; else &#123; childProcess();&#125;// 父进程function masterProcess() &#123; console.log(`Master process $&#123;process.pid&#125; is running`); // fork()更多 workers for (let i = 0; i &lt; cpuCount; i++) &#123; console.log(`Forking process number $&#123;i&#125;...`); cluster.fork(); //creates new node js processes &#125; cluster.on(&quot;exit&quot;, (worker, code, signal) =&gt; &#123; console.log(`worker $&#123;worker.process.pid&#125; died`); cluster.fork(); //forks a new process if any process dies &#125;);&#125;// 子进程function childProcess() &#123; const express = require(&quot;express&quot;); const app = express(); // workers 可以共享 TCP connection app.get(&quot;/&quot;, (req, res) =&gt; &#123; res.send(`hello from server $&#123;process.pid&#125;`); &#125;); app.listen(5555, () =&gt; console.log(`server $&#123;process.pid&#125; listening on port 5555`) );&#125; 当运行上面的代码时，cluster.isMaster 第一次为 true 并且 masterProcess() 函数被执行。masterProcess()函数 fork()了 4 个 NodeJS 进程（依赖于设备 CPU 的核数），每当 fork()另一个进程时，都会再次运行相同的文件，但 cluster.isMaster 将返回 false，因为该进程现在是一个子进程，因为是 fork（）的，因此控制转到 else 条件。 最终 childProcess() 函数执行了 4 次，并创建了 4 个 Express 服务器实例，后续请求以循环方式分发到四台服务器，从而充分利用机器的 CPU。 Node js 文档还指出，有一些内置的智能功能可以避免工作进程过载。 Cluster 模块是垂直扩展简单 Nodejs 服务器的最简单、最快的方法。 但是，为了实现更高级和弹性的扩展，可以使用 docker 容器和 Kubernetes 等工具。 worker threads本质上，工作线程和子进程之间的区别就像线程和进程之间的区别一样。理想情况下，创建的线程数应等于 cpu 核数。 下面演示 worker_threads 的使用。先创建一个单进程的服务器： 1234567891011121314151617181920212223242526272829303132333435363738const express = require(&quot;express&quot;);const app = express();// 求和function sumOfPrimes(n: number): number &#123; var sum = 0; for (var i = 2; i &lt;= n; i++) &#123; for (var j = 2; j &lt;= i / 2; j++) &#123; if (i % j == 0) &#123; break; &#125; &#125; if (j &gt; i / 2) &#123; sum += i; &#125; &#125; return sum;&#125;app.get( &quot;/sumofprimes&quot;, ( &#123; query: &#123; number &#125; &#125;: any, res: &#123; json: (arg0: &#123; number: any; sum: number; timeTaken: string &#125;) =&gt; void; &#125; ) =&gt; &#123; const startTime = new Date().getTime(); const sum = sumOfPrimes(number as number); const endTime = new Date().getTime(); res.json(&#123; number: number, sum: sum, timeTaken: (endTime - startTime) / 1000 + &quot; seconds&quot;, &#125;); &#125;);app.listen(6868, () =&gt; console.log(&quot;listening on port 6868&quot;)); 当我们请求 100 万的质数之和时，我们看到以下结果：我用的电脑是 MacBook’s M1，也要足足阻塞 12 秒 我们把他改造为工作线程模式：主程序： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778import express from &quot;express&quot;;import &#123; Worker &#125; from &quot;worker_threads&quot;;const app = express();function runWorker(workerData) &#123; return new Promise((resolve, reject) =&gt; &#123; // 第一个参数是worker的文件名 const worker = new Worker(&quot;./cpu密集型演示_worker_threads_质数加总.js&quot;, &#123; workerData, &#125;); worker.on(&quot;message&quot;, resolve); // 当数据从worker线程返回的时候改Promise为resolve worker.on(&quot;error&quot;, reject); worker.on(&quot;exit&quot;, (code) =&gt; &#123; if (code !== 0) &#123; reject(new Error(`Worker stopped with exit code $&#123;code&#125;`)); &#125; &#125;); &#125;);&#125;function divideWorkAndGetSum() &#123; // 为了简单起见，对值 600000 进行硬编码分成4等份 const start1 = 2; const end1 = 150000; const start2 = 150001; const end2 = 300000; const start3 = 300001; const end3 = 450000; const start4 = 450001; const end4 = 600000; const start5 = 600001; const end5 = 750000; const start6 = 750001; const end6 = 900000; const start7 = 900001; const end7 = 1000000; // 为每一个worker单独分配内容 const worker1 = runWorker(&#123; start: start1, end: end1 &#125;); const worker2 = runWorker(&#123; start: start2, end: end2 &#125;); const worker3 = runWorker(&#123; start: start3, end: end3 &#125;); const worker4 = runWorker(&#123; start: start4, end: end4 &#125;); const worker5 = runWorker(&#123; start: start5, end: end5 &#125;); const worker6 = runWorker(&#123; start: start6, end: end6 &#125;); const worker7 = runWorker(&#123; start: start7, end: end7 &#125;); // 要求所有都resolve return Promise.all([ worker1, worker2, worker3, worker4, worker5, worker6, worker7, ]);&#125;app.get(&quot;/sumofprimeswiththreads&quot;, async (req, res) =&gt; &#123; const startTime = new Date().getTime(); const sum = await divideWorkAndGetSum() .then( ( values //values is an array containing all the resolved values ) =&gt; values.reduce((accumulator, part) =&gt; accumulator + part.result, 0) //reduce is used to sum all the results from the workers ) .then((finalAnswer) =&gt; finalAnswer); const endTime = new Date().getTime(); res.json(&#123; number: 1000000, sum: sum, timeTaken: (endTime - startTime) / 1000 + &quot; seconds&quot;, &#125;);&#125;);app.listen(7777, () =&gt; console.log(&quot;listening on port 7777&quot;)); 文件 cpu密集型演示_worker_threads_质数加总.js : 123456789101112131415161718192021222324import &#123; workerData, parentPort &#125; from &quot;worker_threads&quot;;// workerData 将是 multiThreadServer.js 中 Worker 构造函数的第二个参数const start = workerData.start;const end = workerData.end;var sum = 0;for (var i = start; i &lt;= end; i++) &#123; for (var j = 2; j &lt;= i / 2; j++) &#123; if (i % j == 0) &#123; break; &#125; &#125; if (j &gt; i / 2) &#123; sum += i; &#125;&#125;parentPort.postMessage(&#123; // 将结果消息发送回父进程 start: start, end: end, result: sum,&#125;); 看一下运行时间,只有 3 秒多","tags":["Node"]},{"title":"Nginx 简介及配置 (24-05-15)","path":"/2024/05/15/【2024-05-14】Nginx配置/","content":"以前写过一篇类似的博文，之前的文章现在看起来逻辑有点混乱，当时用的是阿里云的红帽发行版本，现在空间不租了，我用 Mac 电脑又折腾了一遍，为了加深印象，我把过程记录下来。 简介Nginx 是一个高性能的 HTTP 和 reverse proxy 服务器，同时也支持邮件代理。由俄罗斯程序员 Igor Sysoev 创建，目的为了解决 C10k 问题，即并发问题。在 2004 年 8 月 1 日首次发布。2019 年 3 月，Nginx 已经被 F5 公司收购。 Nginx 是一个轻量级的 Web 服务器，并且支持反向代理，负载均衡，HTTP 缓存，图片转换，静态内容加速等。在服务器市场占有率迄今为止是最高的。 安装 Linux 12sudo apt updatesudo apt install nginx Mac OS 1brew install nginx Windows 12scoop install nginxchoco install nginx docker 1docker pull nginx 启动 Linux，Mac OS 1nginx Windows 双击 nginx.exe docker 1docker run -d -p 8080:8080 nginx 浏览器打开：localhost:8080 验证是否启动成功：1ps -ef | grep nginx 第二栏就是 nginx 进程的 PID 53807 (Master) 和 53808 (Worker) Nginx 的工作模式是主进程 Master - Worker 模式，主进程主要复制读取和验证配置文件，而 Worker 子进程负责处理请求。 查看 8080 端口占用情况： 1lsof -i:8080 常用命令 停止，重载及重新打开日志 1nginx -s &lt;signal&gt; 上面的&lt;signal&gt;可以是： stop：停止 Nginx quit：退出 Nginx reload：重载 Nginx 配置文件 reopen：重新打开 Nginx 日志文件 查看 Nginx 各种配置参数 查看所有参数：nginx -V，再看 --conf-path 参数的值 123456(base) zyzy:~ $ nginx -Vnginx version: nginx/1.25.5built by clang 15.0.0 (clang-1500.3.9.4)built with OpenSSL 3.2.1 30 Jan 2024 (running with OpenSSL 3.3.0 9 Apr 2024)TLS SNI support enabledconfigure arguments: --prefix=/opt/homebrew/Cellar/nginx/1.25.5 --sbin-path=/opt/homebrew/Cellar/nginx/1.25.5/bin/nginx --with-cc-opt=&#x27;-I/opt/homebrew/opt/pcre2/include -I/opt/homebrew/opt/openssl@3/include&#x27; --with-ld-opt=&#x27;-L/opt/homebrew/opt/pcre2/lib -L/opt/homebrew/opt/openssl@3/lib&#x27; --conf-path=/opt/homebrew/etc/nginx/nginx.conf --pid-path=/opt/homebrew/var/run/nginx.pid --lock-path=/opt/homebrew/var/run/nginx.lock --http-client-body-temp-path=/opt/homebrew/var/run/nginx/client_body_temp --http-proxy-temp-path=/opt/homebrew/var/run/nginx/proxy_temp --http-fastcgi-temp-path=/opt/homebrew/var/run/nginx/fastcgi_temp --http-uwsgi-temp-path=/opt/homebrew/var/run/nginx/uwsgi_temp --http-scgi-temp-path=/opt/homebrew/var/run/nginx/scgi_temp --http-log-path=/opt/homebrew/var/log/nginx/access.log --error-log-path=/opt/homebrew/var/log/nginx/error.log --with-compat --with-debug --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_degradation_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-http_v3_module --with-ipv6 --with-mail --with-mail_ssl_module --with-pcre --with-pcre-jit --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module 也可以用 nginx -t查看 123(base) zyzy:~ $ nginx -tnginx: the configuration file /opt/homebrew/etc/nginx/nginx.conf syntax is oknginx: configuration file /opt/homebrew/etc/nginx/nginx.conf test is successful 一般来说，Mac 系统该配置文件在 /opt/homebrew/etc/nginx/nginx.conf Linux 系统该配置文件在 /etc/nginx/conf 或 /usr/local/etc/nginx 配置这个是 Nginx 的默认配置文件：默认很多操作没有解开： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events &#123; worker_connections 1024;&#125;http &#123; include mime.types; default_type application/octet-stream; #log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; # &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; # &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server &#123; listen 8080; server_name localhost; #charset koi8-r; #access_log logs/host.access.log main; location / &#123; root html; index index.html index.htm; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http://127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#x27;s document root # concurs with nginx&#x27;s one # #location ~ /\\.ht &#123; # deny all; #&#125; &#125; # another virtual host using mix of IP-, name-, and port-based configuration # #server &#123; # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; # HTTPS server # #server &#123; # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / &#123; # root html; # index index.html index.htm; # &#125; #&#125; include servers/*;&#125; 别看这么多，其实就 3 部分内容 全局块：例如worker_processes配置 Nginx 的进程数，默认为 1; events：事件部分，配置 Nginx 的事件处理方式，如 worker_processes、worker_connections 等 http：HTTP 模块部分，配置 Nginx 的 HTTP 模块，如 server、location 等 worker_processes我们可以配置该参数为 auto，这样就能自动匹配电脑应有的核心数。 这里我故意把配置写错：worker_processes 10，尾部没加;，运行 nginx -t，能帮我们自带检查该文件错误： 123(base) zyzy:1.25.5 (master) $ nginx -tnginx: [emerg] directive &quot;worker_processes&quot; is not terminated by &quot;;&quot; in /opt/homebrew/etc/nginx/nginx.conf:12nginx: configuration file /opt/homebrew/etc/nginx/nginx.conf test failed 每次修改完成后，nginx -s reload 重新加载 nginx.conf 文件 改为 auto 后，跑 ps -ef | grep nginx，发现 nginx 进程数变为 8 个，代表我用的 mac 电脑有 8 核，如下图： eventsworker_connections：配置 Nginx 的最大连接数，默认为 1024multi_accept：是否允许同时接受多个连接，默认为 off，表示只接受一个连接，如果为 on，则表示允许同时接受多个连接 http这个是被修改得最多的模块 include mime.types：包含 Nginx 能处理文件类型，默认为路径为： /opt/homebrew/etc/nginx/mime.types server在 http 模块下，包含多个 server 模块，每个 server 模块代表一个虚拟主机。 修改默认的 HTML 静态页面部署一个静态站点，我们需要按以下配置修改对应的 html 文件： 1234location / &#123; root html; index index.html index.htm;&#125; location /：表示匹配所有请求，root：表示静态资源文件存放的目录，index：表示默认首页，默认为 index.html 那就去找这个 html 文件夹，可用 nginx -V 找到 --prefix=/opt/homebrew/Cellar/nginx/1.25.5字段，能找到 Nginx 的安装路径 1234567891011121314151617(base) zyzy:~ $ cd /opt/homebrew/Cellar/nginx/1.25.5(base) zyzy:1.25.5 (master) $ lltotal 680-rw-r--r-- 1 ziyouzhiyi admin 319K 4 16 22:37 CHANGES-rw-r--r-- 1 ziyouzhiyi admin 1.3K 5 14 10:49 INSTALL_RECEIPT.json-rw-r--r-- 1 ziyouzhiyi admin 1.4K 4 16 22:37 LICENSE-rw-r--r-- 1 ziyouzhiyi admin 49B 4 16 22:37 READMEdrwxr-xr-x 3 ziyouzhiyi admin 96B 5 14 10:49 bin-rw-r--r-- 1 ziyouzhiyi admin 685B 5 14 10:49 homebrew.mxcl.nginx.plist-rw-r--r-- 1 ziyouzhiyi admin 202B 5 14 10:49 homebrew.nginx.servicelrwxr-xr-x 1 ziyouzhiyi admin 16B 5 14 10:49 html -&gt; ../../../var/wwwdrwxr-xr-x 4 ziyouzhiyi admin 128B 4 16 22:37 share(base) zyzy:1.25.5 (master) $ ls -ld $(readlink html)drwxr-xr-x 4 ziyouzhiyi admin 128 2 15 00:03 ../../../var/www(base) zyzy:1.25.5 (master) $ cd html(base) zyzy:html (master) $ ls50x.html index.html 可以清晰的看到，html 不仅仅是一个软链接，他还是一个文件夹，Linux 和 MacOS 都可以将文件夹作为软链接，这样可以避免移动文件夹。 我们改动 index.html，然后 nginx -s reload 重新加载配置，可以看到浏览器的页面已经修改： 123(base) zyzy:1.25.5 (master) $ cd html(base) zyzy:html (master) $ ls50x.html index.html location / 下的 root 指定 include servers/*;：表示将 servers 目录下的所有配置文件包含进来 反向代理及负载均衡写一个最简单的 node http 服务 index.js 123456789101112const http = require(&quot;http&quot;);const PORT = 3000;const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/html&quot; &#125;); res.write(`&lt;h1&gt;Node.js web server! Port: $&#123;PORT&#125;&lt;/h1&gt;`); res.end();&#125;);server.listen(PORT, () =&gt; &#123; console.log(`Server is running on port $&#123;PORT&#125;`);&#125;); 我们将其复制 2 份，端口号分别改为 3020 和 3030，文件名改为 index-3000.js，index-3020.js，index-3030.js，分别跑起来，页面localhost:3000、localhost:3020、localhost:3030 都能打开。 再修改 nginx.conf，添加反向代理配置：http 模块中添加 upstream反向代理字段, server 模块中添加 proxy_pass字段，如下： 12345678910111213141516http &#123; # 其他配置。。。 upstream backend &#123; server 127.0.0.1:3000; server 127.0.0.1:3010; server 127.0.0.1:3020; &#125; server &#123; location /app &#123; # backend字段对应上面upstream的backend字段 proxy_pass http://backend; &#125; &#125;&#125; 重载 nginx -s reload，然后访问 localhost:8080/app，再不断刷新，页面显示如下，反向代理成功： 请求策略 weight upstream 字段下的 ip 地址，可以添加权重 weight，如： 12345upstream backend &#123; server 127.0.0.1:3000 weight=3; server 127.0.0.1:3010; server 127.0.0.1:3020;&#125; 这样，我们多数的请求就会分配到端口为 3000 的服务器上，3000 的请求数量就会是其余两个的 3 倍。 ip_hash 123456upstream backend &#123; ip_hash; server 127.0.0.1:3000; server 127.0.0.1:3010; server 127.0.0.1:3020;&#125; ip_hash：根据客户端的 IP 地址进行哈希，同一个客户端的请求会分配到同一个服务器上，这样主要是解决 session 命中的问题。 SSL 配置HTTPS 的安全层正数，可以在主流的云平台申请，我们也可以自己制作证书 生成密钥和证书123openssl genrsa -out private.key 2048openssl req -new -key private.key -out cert.csropenssl x509 -req -in cert.csr -out cacert.pem -signkey private.key -days 3650 按照以上命令生成了 cacert.pem(证书) 和 private.key(私钥) 两个文件。将两个文件移动到 /opt/homebrew/etc/nginx/ 目录下 1(base) zyzy:1.25.5 (master) $ mv cacert.pem private.key /opt/homebrew/etc/nginx/ 配置 nginx.conf 如下：12345678910111213141516171819server &#123; # ssl证书默认443端口： listen 443 ssl; server_name localhost; # 以下写法固定： # 证书文件名称： ssl_certificate /opt/homebrew/etc/nginx/cacert.pem; # 私钥文件名称： ssl_certificate_key /opt/homebrew/etc/nginx/private.key; # ssl验证： ssl_session_timeout 5m; # 缓存有效期 # 安全链接可选的加密协议： ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # 加密套件/加密算法，写法遵循 openssl的格式： ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; # 使用服务端的首选算法： ssl_prefer_server_ciphers on;&#125; 当我们访问 localhost:8080，会发现 chrome 浏览器会提示我们不安全，这是因为证书是我们自己制作的，并非机构颁发，我们选择继续访问，并在这里可以点开查看我们刚刚输入的证书信息： 点击看到证书： 配置重定向可以将 http 的访问重定向到我们的 https 端口上 12345server &#123; listen 8080; server_name localhost; return 301 https://$host$request_uri;&#125; 如果有配置域名，则改为如下： 12345server &#123; listen 8080; server_name zyzy.info; return 301 https://$server_name$request_uri;&#125; 虚拟主机在网站初期，访问量较小，一个服务器配置多个服务可以节省资源，这种多服务器配置称为虚拟主机，下面我们来实现 server 独立配置我们将 /opt/homebrew/etc/nginx/nginx.conf 下上面配置好的 server单独剪切出来，新建一个 localhost.conf 文件，放到 /opt/homebrew/etc/nginx/server 下， 重载 nginx -s reload，浏览器打开发现网站正常运行，说明 server 目录可以存放多个虚拟主机的配置文件。 /nginx/server下创建其他服务创建前端 SPA 页面结合的 SPA 项目，我们用 vite 生成一个 react 项目， 1234npm create vite@latest demo-project -- --template reactcd vite_reactnpm installnpm run build 进入 dist 目录，复制路径： 12(base) zyzy:dist $ pwd/Users/ziyouzhiyi/servers/demo-project/dist 创建server 模块我们在 /opt/homebrew/etc/nginx/server 目录下写一个 vite_react.conf 配置文件，配置如下：将上面/Users/ziyouzhiyi/servers/demo-project/dist 路径配置如下： 123456789server &#123; listen 5173; server_name vite_react; location / &#123; root /Users/ziyouzhiyi/servers/demo-project/dist; index index.html index.htm; &#125;&#125; 重载 nginx -s reload 检验配置访问 localhost:5173，页面正常显示，说明配置成功。页面访问：http://localhost:5173/，如下： 上面的页面还没配置 ssl，我们把他改成 https 访问，将 localhost.conf，的配置粘过来，改动如下： 1234567891011121314151617181920212223server &#123; listen 5173 ssl; server_name vite_react; # 证书文件名称： ssl_certificate /opt/homebrew/etc/nginx/cacert.pem; # 私钥文件名称： ssl_certificate_key /opt/homebrew/etc/nginx/private.key; # 以下配置固定： # ssl验证： ssl_session_timeout 5m; # 缓存有效期 # 安全链接可选的加密协议： ssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # 加密套件/加密算法，写法遵循 openssl的格式： ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:HIGH:!aNULL:!MD5:!RC4:!DHE; # 使用服务端的首选算法： ssl_prefer_server_ciphers on; location / &#123; root /Users/ziyouzhiyi/servers/demo-project/dist; index index.html index.htm; &#125;&#125;","tags":["Nginx"]},{"title":"Vue3 新特性一览","path":"/2024/05/04/【2024-05-04】Vue3 learn/","content":"最近学习 Vue3, 这里做个简单的记录，Vue3 在 Vue2 的升级，语法和 API 都发生了变化。下面就一些新增的 API，写一些简单的 demo 进行记录。 创建项目vue3 创建项目，使用 Vite 脚手架。放弃了原来的 vue-cli。 12# 跟着cli的提示一步步创建即可：npm init vite@latest 我尝试着删除 src 目录，重新新建一个 src 目录，自己写一个 src/main.ts 和 src/App.vue。 会发现 ts 检查在 App.vue 中报错。这时因为 ts 的检查中，不认识.vue 文件，需要配置 env.d.ts文件。cmd (Mac)/ctrl (Windows) + 左键点击下面的 &quot;vite/client&quot; 路径 1/// &lt;reference types=&quot;vite/client&quot; /&gt; 会跳转到 vite/client 文件，添加： 12345declare module &quot;*.vue&quot; &#123; import &#123; ComponentOptions &#125; from &quot;vue&quot;; const componentOptions: ComponentOptions; export default componentOptions;&#125; 即可 Vue3 入口文件一些概念 Vite 项目中，index.html 是项目的入口文件，在项目最外层。 加载 index.html 后，Vite 解析 &lt;script type=&quot;module&quot; src=&quot;xxx&quot;&gt;指回的 Javascript Vue3 中是通过createApp函数创建一个应用实例。 Options API 和 Composition APIVue2 属于 Option API (配置选项式 API)，Vue3 属于 Composition API（组合式 API），我愿意称他为功能性组合 API。 随着 Vue2 里的各个组件越来越复杂，配置式 API 缺点非常明显，所有的值散落在诸如 data(), methods(), computed(), watch()等等方法中，修改一处有可能要修改多处。 比起原来 Options API（例如：data(),methods()），setup有两个特点： 一个 vue 文件可以同时具备 data(), methods() 等 Vue2 的功能，也可以同时具备 setup()写法的 Vue3 功能。 setup() 函数中，不能再使用 this。而且setup是最早的生命周期函数。所以 data() 和 methods() 函数中，可以访问 setup() 函数中定义的变量。但 setup() 函数中，不能访问 data() 和 methods() 函数中定义的变量。 setup()这个是 Vue3 追赶 React 函数式编程的新概念，在 Vue2 里，setup普通的写法，他是执行在生命周期里的 beforeCreate 阶段之前的函数，因此，Vue3 将 setup函数提升到一个新的高度。 12345&lt;script&gt; export default &#123; setup() &#123;&#125;, &#125;;&lt;/script&gt; 语法糖 &lt;script setup lang=&quot;ts&quot;&gt;鉴于 setup()的特殊性，Vue3 将其独立为一个语法糖的写法，将其整合进 &lt;script lang=&quot;ts&quot; setup&gt; 里，下面是 vue3 App.vue 文件的 setup 改法： 12345678&lt;template&gt; &lt;ChildComp /&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; // 直接导出子组件即可，省略 export default import ChildComp from &quot;./components/WatchEffectDemo.vue&quot;;&lt;/script&gt; setup插件: VueSetupExtend 增强 script 标签用法1npm i vite-plugin-vue-setup-extend -D vite.config.ts 配置：plugins 中添加 VueSetupExtend()，如： 123456789101112131415import &#123; fileURLToPath, URL &#125; from &quot;node:url&quot;;import &#123; defineConfig &#125; from &quot;vite&quot;;import vue from &quot;@vitejs/plugin-vue&quot;;import VueSetupExtend from &quot;vite-plugin-vue-setup-extend&quot;;// https://vitejs.dev/config/export default defineConfig(&#123; plugins: [vue(), VueSetupExtend()], resolve: &#123; alias: &#123; &quot;@&quot;: fileURLToPath(new URL(&quot;./src&quot;, import.meta.url)), &#125;, &#125;,&#125;); ref 和 reactive，将数变为响应式让我们看一个例子： 12345678910111213141516171819202122232425262728293031323334&lt;template&gt; &lt;div class=&quot;car&quot;&gt; &lt;h2&gt;&#123;&#123; car.brand &#125;&#125; -&gt; &#123;&#123; car.price &#125;&#125;元&lt;/h2&gt; &lt;button @click=&quot;addPrice&quot;&gt;修改价格+10万&lt;/button&gt; &lt;button @click=&quot;minusPrice&quot;&gt;修改价格-1万&lt;/button&gt; &lt;button @click=&quot;changeCarByReactive&quot;&gt;修改整车by reactive&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;&#123;&#123; car2.brand &#125;&#125; -&gt; &#123;&#123; car2.price &#125;&#125;元&lt;/h2&gt; &lt;button @click=&quot;changeCarByRef&quot;&gt;修改整车by ref&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Car12&quot;&gt; import &#123; ref, reactive, toRefs &#125; from &quot;vue&quot;; let car = reactive(&#123; brand: &quot;Toyota&quot;, price: 200000 &#125;); // 如果要解构，必须用toRefs套上，否则页面无法响应 let &#123; price &#125; = toRefs(car); const addPrice = () =&gt; (price.value += 100000); // 如果只修改某一个属性，用.语法修改 const minusPrice = () =&gt; (car.price -= 10000); const changeCarByReactive = () =&gt; &#123; // 如果涉及整个对象修改过，必须用Object.assign Object.assign(car, &#123; brand: &quot;Audi&quot;, price: 300000 &#125;); &#125;; let car2 = ref(&#123; brand: &quot;Benz&quot;, price: 800000 &#125;); const changeCarByRef = () =&gt; &#123; // 如果改用ref，必须用value修改，而且.value就是响应式，页面可以实时呈现 car2.value = &#123; brand: &quot;Audi&quot;, price: 300000 &#125;; &#125;;&lt;/script&gt; ref 可以包裹任意数据类型，作为响应式数据，并实时修改视图的值 被 ref 包裹的数据，如果要更改页面的值，必须用 .value 修改。例如例子中的：car2.value = &#123; brand: &quot;Audi&quot;, price: 300000 &#125;; reactive 只能用来包裹一个对象，作为响应式数据。 被 reactive 包裹的对象，如果要整体修改，必须用 Object.assign 修改。例如例子中的: Object.assign(car, &#123; brand: &quot;Audi&quot;, price: 300000 &#125;); 如果遇到解构，必须用toRefs 包裹普通对象，使其变为响应式对象，要不页面上的响应式数据就不会更新。例如例子中的：let &#123; price &#125; = toRefs(car); computed 计算属性computed 是一个计算属性，它依赖其他数据，当依赖的数据发生变化时，计算属性会重新计算。这是我们在 Vue2 中经常使用的。 但是 Vue3 中，我们还可以用computed自带的 getter 和 setter 来实现计算属性的获取和修改。 1234567891011121314151617181920212223242526272829303132333435&lt;template&gt; &lt;div class=&quot;person&quot;&gt; 全名：&lt;span&gt;这个是计算属性计算出来的全名：&#123;&#123; fullName &#125;&#125;&lt;/span&gt; &lt;button @click=&quot;changeFullName&quot;&gt;点击修改姓名为Li si&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup name=&quot;Person&quot;&gt; import &#123; ref, computed &#125; from &quot;vue&quot;; let firstName = ref(&quot;zhang&quot;); let lastName = ref(&quot;san&quot;); // 传统vue2，计算属性是只读属性，页面上并不能直接修改： // const fullName = computed( // () =&gt; // `$&#123;firstName.value.slice(0, 1).toUpperCase()&#125;$&#123;firstName.value.slice(1)&#125; - $&#123;lastName.value&#125;` // ) // vue3的fullName计算属性，可读可写：用setter，可以直接修改 const fullName = computed(&#123; get() &#123; return `$&#123;firstName.value .slice(0, 1) .toUpperCase()&#125;$&#123;firstName.value.slice(1)&#125; - $&#123;lastName.value&#125;`; &#125;, set(val) &#123; const [f, l] = val.split(&quot;-&quot;); firstName.value = f; lastName.value = l; &#125;, &#125;); const changeFullName = () =&gt; (fullName.value = &quot;li-si&quot;);&lt;/script&gt; watch 监视watch 是一个监听器，它监听某个数据，当数据发生变化时，执行回调函数。watch 监听的数据可以是一个响应式数据，也可以是一个普通数据。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;template&gt; &lt;div class=&quot;person&quot;&gt; &lt;h2&gt;姓名：&#123;&#123; person.name &#125;&#125;&lt;/h2&gt; &lt;h2&gt;汽车：&#123;&#123; person.car.c1 &#125;&#125; &#123;&#123; person.car.c2 &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changeName&quot;&gt;改名&lt;/button&gt; &lt;button @click=&quot;changeCar1&quot;&gt;改第一台🚗&lt;/button&gt; &lt;button @click=&quot;changeCar2&quot;&gt;改第二台🚗&lt;/button&gt; &lt;button @click=&quot;changeCars&quot;&gt;改所有🚗&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; reactive, watch &#125; from &quot;vue&quot;; let person = reactive(&#123; name: &quot;张三&quot;, car: &#123; c1: &quot;奔驰&quot;, c2: &quot;宝马&quot;, &#125;, &#125;); const changeName = () =&gt; (person.name += &quot;~&quot;); const changeCar1 = () =&gt; (person.car.c1 = &quot;audi&quot;); const changeCar2 = () =&gt; (person.car.c2 = &quot;Toyota&quot;); const changeCars = () =&gt; (person.car = &#123; c1: &quot;byd&quot;, c2: &quot;yy&quot; &#125;); // reactive监视属性时候，第一个参数必须写为函数返回类型，否则报错 watch( () =&gt; person.name, (newValue, oldValue) =&gt; &#123; console.log(&quot;newValue&quot;, newValue); console.log(&quot;oldValue&quot;, oldValue); &#125; ); // 监视的reactive对象属性也是obj时 // 如果要监视除该 watch( () =&gt; person.car, (newValue, oldValue) =&gt; &#123; console.log(&quot;newValue&quot;, newValue); console.log(&quot;oldValue&quot;, oldValue); &#125;, // 加上deep：true，可以监视任意person对象里的细微变化 &#123; deep: true &#125; ); // 监视多个属性 watch([() =&gt; person.name, () =&gt; person.car.c1], (newValue, oldValue) =&gt; &#123; console.log(&quot;newValue&quot;, newValue); console.log(&quot;oldValue&quot;, oldValue); &#125;);&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt; 和 watch 等价的，有另一个 api watchEffect，它更智能，它接收一个函数，函数里可以写异步代码，当函数执行时，会自动收集依赖，当依赖的数据发生变化时，会重新执行函数。 下面写一个 demo 实现：下面是一个简单的监测水温和水位的例子，当水温达到或超过 60℃，或者水位达到或超过 80cm 时，给服务器发请求。这里的请求用了 console.log，实际应用中，可以发送请求。 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div&gt; &lt;h2&gt;当水温达到或超过60℃，或者水位达到或超过80cm时，给服务器发请求&lt;/h2&gt; &lt;h2&gt;水温：&#123;&#123; temp &#125;&#125;&lt;/h2&gt; &lt;h2&gt;水位：&#123;&#123; height &#125;&#125;&lt;/h2&gt; &lt;button @click=&quot;changeTemp&quot;&gt;水温+10 ℃&lt;/button&gt; &lt;button @click=&quot;changeHeight&quot;&gt;水位+10 cm&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref, watch, watchEffect &#125; from &quot;vue&quot;; let temp = ref(10); let height = ref(0); const changeTemp = () =&gt; &#123; temp.value += 10; &#125;; const changeHeight = () =&gt; &#123; height.value += 10; &#125;; // watch实现： watch([temp, height], (value) =&gt; &#123; let [newTemp, newHeight] = value; if (newTemp &gt;= 60 || newHeight &gt;= 80) &#123; console.log(&quot;给服务器发请求&quot;); &#125; &#125;); // watchEffect实现： // wathcEffect可以不用写函数，直接写代码，会自动收集依赖。 watchEffect(() =&gt; &#123; if (temp.value &gt;= 60 || height.value &gt;= 80) &#123; console.log(&quot;给服务器发请求&quot;); &#125; &#125;);&lt;/script&gt; defineExpose 暴露响应式数据 ref 除了定义一个引用之外，还可以给真实 DOM 元素或组件元素打标记，然后通过 ref 获取到该元素或者组件元素实例。 和 vue2 不一样，vue3 的引用值 ref 必须用 defineExpose 暴露给父组件，父组件才能获取到他的值 123456789101112131415161718&lt;template&gt; &lt;div ref=&quot;x&quot;&gt;hello vue3&lt;/div&gt; &lt;button @click=&quot;showRef&quot;&gt;get ref DOM&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref, defineExpose &#125; from &quot;vue&quot;; // 和vue2不一样，vue3的引用值ref必须用defineExpose暴露 let a = ref(&quot;1&quot;); defineExpose(&#123; a &#125;); // x 必须与上面的 ref 标签名字一致 let x = ref(); const showRef = () =&gt; &#123; console.log(x.value); // &lt;div&gt;hello vue3&lt;/div&gt; &#125;;&lt;/script&gt; ref 打在组件标签上，能打印出组件实例 12345678910111213&lt;template&gt; &lt;RefDemo ref=&quot;aa&quot; /&gt; &lt;button @click=&quot;showRef&quot;&gt;showRef&lt;/button&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import RefDemo from &quot;./components/RefDemo.vue&quot;; import &#123; ref &#125; from &quot;vue&quot;; let aa = ref(); const showRef = () =&gt; &#123; console.log(aa.value); // Proxy(Object) &#123;__v_skip: true&#125; &#125;;&lt;/script&gt; props, defineProps 和 withDefaults不废话，直接上 demo，和 React 不同的是，子组件如果要显示 Props，需要用defineProps定义，否则会报错。 父组件： 1234567891011121314&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;PropsDemo a=&quot;hehe&quot; :personsList=&quot;persons&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import PropsDemo from &quot;./components/PropsDemo.vue&quot;; let persons = [ &#123; id: 1, name: &quot;张三&quot;, age: 18 &#125;, &#123; id: 2, name: &quot;李四&quot;, age: 19 &#125;, ];&lt;/script&gt; 子组件的写法就有点奇葩，如果定义默认值，还要再引入一个withDefaults，他的定义是比 vue2 啰嗦的。 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div&gt;&#123;&#123; a &#125;&#125;&lt;/div&gt; &lt;ul&gt; &lt;li :key=&quot;person.id&quot; v-for=&quot;person in personsList&quot;&gt; &#123;&#123; person.name &#125;&#125;: &#123;&#123; person.age &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; defineProps, withDefaults &#125; from &quot;vue&quot;; import type &#123; Person &#125; from &quot;@/types&quot;; // 写法1：如果不用ts的普通写法 // const props1 = defineProps([&#x27;a&#x27;, &#x27;personsList&#x27;]) // console.log(props1) // // 写法2：用上ts及withDefaults，当然，withDefaults可以省略不用 const props = withDefaults( defineProps&lt;&#123; a: string; personsList: Person[] &#125;&gt;(), &#123; a: &quot;xx&quot;, personsList: () =&gt; [&#123; id: &quot;kk&quot;, name: &quot;yy&quot;, age: 18 &#125;], &#125; ); console.log(props); // Proxy(Object) &#123;a: &#x27;hehe&#x27;, personsList: Array(2)&#125;&lt;/script&gt; 生命周期Vue2 的生命周期：创建阶段：beforeCreate created挂载阶段：beforeMount mounted更新阶段：beforeUpdate updated销毀阶段：beforeDestroy destroyed Vue3 的生命周期： 创建阶段：setup挂载阶段：onBeforeMount onMounted更新阶段：onBeforeUpdate onUpdated销毁阶段：onBeforeUnmount onUnmounted 由于 Vue3 我们把 setup 阶段写在 script 标签里，所以 Vue3 的生命周期比 Vue2 的少了 2 个，分别是beforeCreate和created。 123456789101112131415&lt;!-- vue2的写法： --&gt;&lt;script&gt; export default &#123; created() &#123; console.log(&quot;created&quot;); &#125;, &#125;;&lt;/script&gt;&lt;!-- Vue3的写法： --&gt;&lt;script setup lang=&quot;ts&quot;&gt; onMounted(() =&gt; &#123; console.log(&quot;onMounted&quot;); &#125;);&lt;/script&gt; Custom Hooks 模块化封装这个概念完全是抄袭 React hooks，由于 Vue3 设计成了setup 语法，所以使得函数式编程称为可能，下面是一个 demo 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;person&quot;&gt; &lt;img v-for=&quot;(image, idx) in dogImages&quot; :src=&quot;image&quot; :key=&quot;idx&quot; alt=&quot;dog&quot; /&gt; &lt;br /&gt; &lt;button @click=&quot;addNewDogImage&quot;&gt;添加狗图&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import useDogImages from &quot;@/hooks/useDogImages&quot;; const &#123; dogImages, addNewDogImage &#125; = useDogImages();&lt;/script&gt;&lt;style scoped&gt; img &#123; height: 150px; margin-right: 10px; &#125;&lt;/style&gt; 在 useDogImages.ts 文件里，可以写下 123456789101112131415161718192021import &#123; ref, reactive &#125; from &quot;vue&quot;;// 添加狗图export default (url: string = &quot;https://dog.ceo/api/breeds/image/random&quot;) =&gt; &#123; // https://dog.ceo/api/breeds/image/random const defaultDogImage = &quot;https://images.dog.ceo/breeds/affenpinscher/n02110627_11811.jpg&quot;; const dogImages = reactive([defaultDogImage]); const addNewDogImage = async () =&gt; &#123; fetch(url) .then((res) =&gt; res.json()) .then((data) =&gt; dogImages.push(data.message)) .catch((err) =&gt; alert(err)); &#125;; return &#123; dogImages, addNewDogImage, &#125;;&#125;; Pinia 状态管理pinia 是一个符合直觉的状态管理库，和vuex一样，都是基于vue3的，但是pinia比vuex更简单易用，而且vuex的作者已经推荐使用pinia了。pinia 的使用非常简单，只需要在main.ts里引入createPinia，然后app.use(createPinia())，然后就可以在setup函数里使用defineStore定义一个状态了。 1npm i pinia createAppmain.ts 引入： 123456789import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &#123; createPinia &#125; from &quot;pinia&quot;;// 下面这个顺序不能乱，必须按照这个顺序，先createPinia()，再app.use(pinia), 再挂载到app的根节点上const app = createApp(App);const pinia = createPinia();app.use(pinia);app.mount(&quot;#app&quot;); defineStore, state, actions创建一个store/count.ts： 12345678910111213141516171819import &#123; defineStore &#125; from &quot;pinia&quot;;const useCountStore = defineStore(&quot;count&quot;, &#123; actions: &#123; addToMaxTwenty(value: number) &#123; if (this.count &lt;= 20) &#123; this.count += value; &#125; &#125;, &#125;, state() &#123; return &#123; count: 0, by: &quot;X&quot;, &#125;; &#125;,&#125;);export default useCountStore; 在应用中使用： 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=&quot;talk&quot;&gt; &lt;div&gt; &lt;h1&gt;count：&#123;&#123; countStore.count &#125;&#125;&lt;/h1&gt; &lt;h2&gt;countStore的其他数据: &#123;&#123; countStore.by &#125;&#125;&lt;/h2&gt; &lt;!-- v-model.number 可以直接转换为数字类型 --&gt; &lt;select v-model.number=&quot;n&quot;&gt; &lt;option value=&quot;1&quot; selected&gt;1&lt;/option&gt; &lt;option value=&quot;2&quot;&gt;2&lt;/option&gt; &lt;option value=&quot;3&quot;&gt;3&lt;/option&gt; &lt;/select&gt; &lt;button @click=&quot;plus&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;minus&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref, reactive &#125; from &quot;vue&quot;; import useCountStore from &quot;@/store/count&quot;; import useTalkStore from &quot;@/store/talks&quot;; const countStore = useCountStore(); const n = ref(1); const plus = () =&gt; &#123; // 第一种改法：pinia符合直觉的状态管理，可以直接修改其值，例如： // countStore.count += n.value // 第二种改法：$patch // countStore.$patch(&#123; // count: 1, // by: &#x27;pinia&#x27; // &#125;) // 第三种改法：actions，这种方法的好处是可以在addToMaxTwenty里添加复杂逻辑 countStore.addToMaxTwenty(n.value); &#125;; const minus = () =&gt; (countStore.count -= n.value);&lt;/script&gt; defineStore 第二个参数改写为组合式 API上面的 talkStore 的例子，第二个参数，我们写的是配置式的 API（OptionAPI），但是 pinia 也支持组合式 API，可以改为： 1234567891011121314151617181920212223242526272829import &#123; defineStore &#125; from &quot;pinia&quot;;import &#123; reactive &#125; from &quot;vue&quot;;type Talk = &#123; id: number; content: string;&#125;;const useTalkStore = defineStore(&quot;talks&quot;, () =&gt; &#123; const talkList = reactive&lt;Talk[]&gt;( JSON.parse(localStorage.getItem(&quot;talkList&quot;) as string) ?? [] ); const assertOneNewTalk = async () =&gt; &#123; try &#123; const response = await fetch( &quot;https://api.uomg.com/api/rand.qinghua?format=json&quot; ); if (!response.ok) throw new Error(&quot;Network response was not ok&quot;); const &#123; content &#125; = await response.json(); return talkList.push(&#123; id: talkList.length + 1, content &#125;); &#125; catch (err) &#123; console.error(err); &#125; &#125;; return &#123; talkList, assertOneNewTalk &#125;;&#125;);export default useTalkStore; storeToRefs如果我们要省略上面的写法 countStore.count，在 pinia 中，可以使用 storeToRefs 解构，这样我们就可以省略 countStore.count，直接使用 count。这里最好不要使用 vue 自带的 **toRefs**，因为 toRefs 会将所有属性都变成响应式，而 storeToRefs 只会将 state 中的属性变成响应式。 TalkStore 的例子： 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;talk&quot;&gt; &lt;button @click=&quot;addNewTalk&quot;&gt;获取一句土味情话&lt;/button&gt; &lt;ul&gt; &lt;li v-for=&quot;talk in talkList&quot; :key=&quot;talk.id&quot;&gt;&#123;&#123; talk.content &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref &#125; from &quot;vue&quot;; import &#123; storeToRefs &#125; from &quot;pinia&quot;; import useCountStore from &quot;@/store/count&quot;; import useTalkStore from &quot;@/store/talks&quot;; const talkStore = useTalkStore(); // 不能直接解构，const &#123; talkList &#125; = talkStore，这样解构出来的 talkList 不是是响应式对象数据，页面用了不会触发更新 const &#123; talkList &#125; = storeToRefs(talkStore); const addNewTalk = () =&gt; talkStore.assertOneNewTalk();&lt;/script&gt; store/talks 文件里，可以直接请求数据： 1234567891011121314151617181920212223242526272829import &#123; defineStore &#125; from &quot;pinia&quot;;type Talk = &#123; id: number; content: string;&#125;;const useTalkStore = defineStore(&quot;talks&quot;, &#123; actions: &#123; async assertOneNewTalk() &#123; try &#123; const response = await fetch( &quot;https://api.uomg.com/api/rand.qinghua?format=json&quot; ); if (!response.ok) throw new Error(&quot;Network response was not ok&quot;); const &#123; content &#125; = await response.json(); return this.talkList.push(&#123; id: this.talkList.length + 1, content &#125;); &#125; catch (err) &#123; console.log(err); &#125; &#125;, &#125;, state() &#123; return &#123; talkList: [] as Talk[], &#125;; &#125;,&#125;);export default useTalkStore; getters 处理数据接着上面的例子，我们在 defineStore 函数中加入：getters, 如： 1234567891011121314151617181920212223242526import &#123; defineStore &#125; from &quot;pinia&quot;;const useCountStore = defineStore(&quot;count&quot;, &#123; actions: &#123; addToMaxTwenty(value: number) &#123; if (this.count &lt;= 20) &#123; this.count += value; &#125; &#125;, &#125;, state() &#123; return &#123; count: 0, by: &quot;X&quot;, &#125;; &#125;, // 两种写法均可 getters: &#123; doubleCount: (state) =&gt; state.count * 2, square(): number &#123; return this.count ** 2; &#125;, &#125;,&#125;);export default useCountStore; 这样就可以在 template 里面直接使用 doubleCount 和 square 了。 $subscribe store 的订阅接着上面TalkStore的例子，添加$subscribe，监视数据，并将其存在浏览器，进行简单的数据持久化，如： 123talkStore.$subscribe((_, state) =&gt; &#123; localStorage.setItem(&quot;talkList&quot;, JSON.stringify(state.talkList));&#125;); 再将state里的talkList 换成在 localStorage 里取：当然，必须判断第一次打开页面时，localStorage 里没有数据，所以需要写一下空值判断符： 123state: () =&gt; (&#123; talkList: JSON.parse(localStorage.getItem(&quot;talkList&quot;) as string) ?? [],&#125;); vue-router 路由安装 1npm i vue-router 创建路由创建 src/router/index.ts，当然，前提还必须创建页面的组件如 Home.vue 等 3 个，这里不详细介绍。 123456789101112131415161718192021222324252627282930import &#123; createRouter, createWebHistory &#125; from &quot;vue-router&quot;;import Home from &quot;@/views/Home.vue&quot;;import News from &quot;@/views/News.vue&quot;;import About from &quot;@/views/About.vue&quot;;const router = createRouter(&#123; // Provide the history routes to use. // 消灭url的#号 // 但history 路由必须要服务器配合设置 history: createWebHistory(), routes: [ &#123; path: &quot;/&quot;, name: &quot;Home&quot;, component: Home, &#125;, &#123; path: &quot;/news&quot;, name: &quot;News&quot;, component: News, &#125;, &#123; path: &quot;/about&quot;, name: &quot;About&quot;, component: About, &#125;, ],&#125;);export default router; history 模式 在 Nginx上配置如下： 123456789101112server &#123; listen 80; server_name your-domain.com; root /path/to/your/webroot; index index.html; location / &#123; # 当Nginx接收到一个请求时，它会首先尝试按照请求的URI提供文件（$uri），如果找不到，它会尝试将请求定向到URI对应的目录（$uri/），如果还是找不到，那么最终会提供/index.html文件。 try_files $uri $uri/ /index.html; &#125;&#125; 在 main.ts 中，引入路由，并挂载到 app 上： 1234567import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import router from &quot;./router&quot;;const app = createApp(App);app.use(router);app.mount(&quot;#app&quot;); 使用路由在路由页面可以显示： 12345678910111213141516171819202122232425262728&lt;template&gt; &lt;div class=&quot;router-demo&quot;&gt; &lt;h2 class=&quot;title&quot;&gt;Vue Router&lt;/h2&gt; &lt;div class=&quot;navigator&quot;&gt; &lt;RouterLink to=&quot;/&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt; &lt;RouterLink :to=&quot;&#123; name: &#x27;News&#x27; &#125;&quot; active-class=&quot;active&quot;&gt;新闻&lt;/RouterLink&gt; &lt;RouterLink :to=&quot;&#123; path: &#x27;/about&#x27; &#125;&quot; active-class=&quot;active&quot; &gt;关于&lt;/RouterLink &gt; &lt;/div&gt; &lt;div class=&quot;content&quot;&gt; &lt;RouterView&gt;&lt;/RouterView&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; RouterView, RouterLink &#125; from &quot;vue-router&quot;;&lt;/script&gt;&lt;style scoped&gt; /* a.active 对应上面的 active-class， 其他样式省略 */ .navigator a.active &#123; background-color: rgb(76, 146, 199); font-weight: 900; text-shadow: 0 0 1px black; &#125;&lt;/style&gt; &lt;RouterView&gt;&lt;/RouterView&gt; 为各个路由组件的占位符， &lt;RouterLink to=&quot;/&quot; active-class=&quot;active&quot;/&gt; 是&lt;a/&gt; 标签的二次封装 属性 to 有 2 种写法，可to=&quot;/&quot;, 也可 :to=&quot;&#123;path: &#39;/&#39;&#125;&quot; 或 :to=&quot;&#123;name: &#39;Home&#39;&#125;&quot;, 这里的 name 对应路由文件 router/index.ts 里定义的 name 路由导航到的页面，挂载到页面的根节点上，切换时则卸载该节点，可以用在具体页面里用 onMounted 和 onUnmounted 来监听，验证这点。 子路由在上面我们创建的 router/index.ts 文件里，用 news 页面创建二级路由， 在 /news路由下，添加 children 数组，如下： 12345678910111213141516import NewsDetail from &#x27;@/views/NewsDetail.vue&#x27;... &#123; path: &#x27;/news&#x27;, name: &#x27;News&#x27;, component: News, children: [ &#123; path: &#x27;newsDetail&#x27;, name: &#x27;NewsDetail&#x27;, component: NewsDetail &#125; ] &#125;... 路由传参query 传参这种是放在 url 的后面，如：/news?id=1&amp;title=xxx&amp;content=xxx，比较啰嗦，不太推荐。改造 views/News.vue 文件，添加 RouterLink 组件，并添加 query 参数，如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div class=&quot;news&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot;&gt; &lt;!-- 1. 利用字符串模板，拼接query参数，太长，比较恶心 --&gt; &lt;!-- &lt;RouterLink :to=&quot;`/news/newsDetail?id=$&#123;news.id&#125;&amp;title=$&#123;news.title&#125;&amp;content=$&#123;news.content&#125;`&quot; &gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink &gt; --&gt; &lt;!-- 2. 以对象拼接query参数 --&gt; &lt;RouterLink :to=&quot;&#123; path: &#x27;/news/newsDetail&#x27;, query: &#123; id: news.id, title: news.title, content: news.content &#125; &#125;&quot; &gt;&#123;&#123; news.title &#125;&#125; &lt;/RouterLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;news-content&quot;&gt; &lt;RouterView&gt;&lt;/RouterView&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; reactive &#125; from &quot;vue&quot;; import &#123; RouterView, RouterLink &#125; from &quot;vue-router&quot;; const newsList = reactive([ &#123; id: 1, title: &quot;1111111&quot;, content: &quot;aaaaaa&quot; &#125;, &#123; id: 2, title: &quot;2222222&quot;, content: &quot;bbbbbb&quot; &#125;, &#123; id: 3, title: &quot;3333333&quot;, content: &quot;cccccc&quot; &#125;, ]);&lt;/script&gt; 在 views/NewsDetail.vue 文件里，添加 props 接收传参，如下： 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;div&gt;编号：&#123;&#123; query.id &#125;&#125;&lt;/div&gt; &lt;div&gt;标题：&#123;&#123; query.title &#125;&#125;&lt;/div&gt; &lt;div&gt;内容：&#123;&#123; query.content &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; toRefs &#125; from &quot;vue&quot;; import &#123; useRoute &#125; from &quot;vue-router&quot;; const route = useRoute(); const &#123; query &#125; = toRefs(route);&lt;/script&gt; params 传参这种传参是放在 url 的后面，如：/news/newsDetail/1，写起来比 query 传参简洁些 先改造 router/index.ts 文件，添加 params 参数，如下： 123456789101112&#123; path: &#x27;/news&#x27;, name: &#x27;News&#x27;, component: News, children: [ &#123; path: &#x27;newsDetail/:id/:title/:content&#x27;, name: &#x27;NewsDetail&#x27;, component: NewsDetail &#125; ]&#125;, 在views/News.vue 文件，改造如下，值得注意的是，写法 2 对象里不能用 path,必须写路由里的 name 参数 1234567891011121314151617181920212223242526272829303132333435363738&lt;template&gt; &lt;div class=&quot;news&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;news in newsList&quot; :key=&quot;news.id&quot;&gt; &lt;!-- parmas传参写法1 --&gt; &lt;!-- &lt;RouterLink :to=&quot;`/news/newsDetail/$&#123;news.id&#125;/$&#123;news.title&#125;/$&#123;news.content&#125;`&quot;&gt;&#123;&#123; news.title &#125;&#125;&lt;/RouterLink&gt; --&gt; &lt;!-- parmas传参写法2 --&gt; &lt;RouterLink :to=&quot;&#123; name: &#x27;NewsDetail&#x27;, params: &#123; id: news.id, title: news.title, content: news.content &#125; &#125;&quot; &gt;&#123;&#123; news.title &#125;&#125; &lt;/RouterLink&gt; &lt;/li&gt; &lt;/ul&gt; &lt;div class=&quot;news-content&quot;&gt; &lt;RouterView&gt;&lt;/RouterView&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; reactive &#125; from &quot;vue&quot;; import &#123; RouterView, RouterLink &#125; from &quot;vue-router&quot;; const newsList = reactive([ &#123; id: 1, title: &quot;1111111&quot;, content: &quot;aaaaaa&quot; &#125;, &#123; id: 2, title: &quot;2222222&quot;, content: &quot;bbbbbb&quot; &#125;, &#123; id: 3, title: &quot;3333333&quot;, content: &quot;cccccc&quot; &#125;, ]);&lt;/script&gt; NewsDetail.vue 文件: 1234567891011121314&lt;template&gt; &lt;div&gt; &lt;div&gt;编号：&#123;&#123; params.id &#125;&#125;&lt;/div&gt; &lt;div&gt;标题：&#123;&#123; params.title &#125;&#125;&lt;/div&gt; &lt;div&gt;内容：&#123;&#123; params.content &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; toRefs &#125; from &quot;vue&quot;; import &#123; useRoute &#125; from &quot;vue-router&quot;; const route = useRoute(); const &#123; params &#125; = toRefs(route);&lt;/script&gt; 路由props参数上面提到的params传参，都可以通过 props 参数来接收，最推荐这种写法，改写如下： 在 router/index.ts 文件里，添加 props 参数，如下： 1234567891011121314151617181920&#123; path: &#x27;/news&#x27;, name: &#x27;News&#x27;, component: News, children: [ &#123; path: &#x27;newsDetail/:id/:title/:content&#x27;, name: &#x27;NewsDetail&#x27;, component: NewsDetail, props: true, // props可以写成回调函数的写法，但没必要 // props: (&#123; params: &#123; id, title, content &#125; &#125;) =&gt; (&#123; // id // title, // content // &#125;) &#125; ]&#125; views/News.vue 文件 和上面提到的一样，无需改动，views/NewsDetail.vue 改造如下： 1234567891011&lt;template&gt; &lt;div&gt; &lt;div&gt;编号：&#123;&#123; id &#125;&#125;&lt;/div&gt; &lt;div&gt;标题：&#123;&#123; title &#125;&#125;&lt;/div&gt; &lt;div&gt;内容：&#123;&#123; content &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; defineProps([&quot;id&quot;, &quot;title&quot;, &quot;content&quot;]);&lt;/script&gt; replacereplace 是一个&lt;RouterLink&gt;组件的属性，加上则表示不缓存该页面，不能点击浏览器上的后退按钮，如： 1&lt;RouterLink replace to=&quot;/&quot; active-class=&quot;active&quot;&gt;首页&lt;/RouterLink&gt; useRouter 编程式路由导航上面我们提到的例子都是&lt;RouterLink&gt;组件，实际应用中，还有一种编程式路由导航，使用频率远大于&lt;RouterLink&gt;组件，例如我们用上面的例子，在首页有一个 button，点击可以跳转到 news 新闻页面，views/Home.vue文件如下： 1234567891011121314151617181920&lt;template&gt; &lt;div&gt;home page&lt;/div&gt; &lt;button @click=&quot;jumpToNews&quot;&gt;jump to news page&lt;/button&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; useRouter &#125; from &quot;vue-router&quot;; const navigateTo = useRouter(); const jumpToNews = () =&gt; &#123; // 用push： // navigateTo.push(&#x27;/news&#x27;) // 也可这种写法： navigateTo.push(&#123; path: &quot;/news&quot;, &#125;); // 用replace：不能后退 // navigateTo.replace(&#x27;/news&#x27;) &#125;;&lt;/script&gt; redirect 重定向这个太简单，不赘述了，直接上代码router/index.ts： 1234&#123; path: &quot;/&quot;, redirect: &quot;/home&quot;,&#125; 组件间通信 ICC inner-component communication父子互传definedProps 和回调函数父子组件间通信，demo 如下： 父组件： 12345678910111213141516171819202122&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h3&gt;parent&lt;/h3&gt; &lt;h4&gt;parent&#x27;s house：&#123;&#123; house &#125;&#125;&lt;/h4&gt; &lt;h4&gt;toy fr child：&#123;&#123; toy &#125;&#125;&lt;/h4&gt; &lt;Child :house=&quot;house&quot; :sendToyToParent=&quot;getToyFromChild&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import Child from &quot;./ChildComp.vue&quot;; import &#123; ref &#125; from &quot;vue&quot;; const house = ref(&quot;🏠&quot;); // 回调函数：在Child上定义的是sendToyToParent const toy = ref(&quot;&quot;); const getToyFromChild = (value: string) =&gt; &#123; console.log(value); toy.value = value; &#125;;&lt;/script&gt; 子组件： 123456789101112131415&lt;template&gt; &lt;div class=&quot;app&quot;&gt; house fr parent：&#123;&#123; house &#125;&#125; &lt;div&gt;my toy: &#123;&#123; toy &#125;&#125;&lt;/div&gt; &lt;button @click=&quot;sendToyToParent(toy)&quot;&gt;send to parent&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref &#125; from &quot;vue&quot;; const toy = ref(&quot;🐻&quot;); // 第一个参数是父组件传过来的数据，第二个是父组件传过来的函数 defineProps([&quot;house&quot;, &quot;sendToyToParent&quot;]);&lt;/script&gt; v-model 双绑 -&gt; 组件封装说实话，这个属性在项目中是不常用的特性，项目中我们多用第三方组件库， 而 vue2 的v-model必须写在原生的 input 框上， 但 vue3 中的 v-model，可以直接写在组件标签上，有了这个特性，可以使其拥有更多的用法 首先，我们先看一下 v-model 在 vue2 中的实现原理 12345678910111213141516&lt;template&gt; &lt;div&gt;&#123;&#123; inputValue &#125;&#125;&lt;/div&gt; &lt;!-- v-model 用在HTML标签上 --&gt; &lt;input v-model=&quot;inputValue&quot; type=&quot;text&quot; /&gt; &lt;!-- 原理： --&gt; &lt;input :value=&quot;inputValue&quot; type=&quot;text&quot; @input=&quot;inputValue = ($event.target as HTMLInputElement).value&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref &#125; from &quot;vue&quot;; const inputValue = ref(&quot;hello&quot;);&lt;/script&gt; 原始的 v-model 是一个语法糖，实际上，是将 input 框的 :value 和 @input，利用这个特性，我们可以实现一个多 input 的组件，实现和 vue2 的 v-model 一样的效果。 被封装的多 input 组件： 12345678910111213141516171819202122232425&lt;template&gt; &lt;input type=&quot;text&quot; :value=&quot;uName&quot; @input=&quot;emit(&#x27;update:uName&#x27;, ($event.target as HTMLInputElement).value)&quot; /&gt; &lt;input type=&quot;password&quot; :value=&quot;pwd&quot; @input=&quot;emit(&#x27;update:pwd&#x27;, ($event.target as HTMLInputElement).value)&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; defineProps([&quot;uName&quot;, &quot;pwd&quot;]); const emit = defineEmits([&quot;update:uName&quot;, &quot;update:pwd&quot;]);&lt;/script&gt;&lt;style scoped&gt; /* 特别牛叉的样式： */ input &#123; background-color: #26b9b1; &#125;&lt;/style&gt; 在页面里使用： 12345678910111213&lt;template&gt; &lt;h4&gt;&#123;&#123; userName &#125;&#125;&lt;/h4&gt; &lt;h4&gt;&#123;&#123; userPwd &#125;&#125;&lt;/h4&gt; &lt;Inputs v-model:uName=&quot;userName&quot; v-model:pwd=&quot;userPwd&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref &#125; from &quot;vue&quot;; import Inputs from &quot;./FormInputs.vue&quot;; const userName = ref(&quot;hello&quot;); const userPwd = ref(&quot;123456&quot;);&lt;/script&gt; 通过以上的例子，可以看出以下特征： 被封装的组件中，:value 和 @input 事件，实现了使用中 &lt;Inputs v-model:uName=&quot;userName&quot; v-model:pwd=&quot;userPwd&quot; /&gt; 的 v-model 效果。 v-model:uName=&quot;userName&quot; 可以取别名uName，我们在封装的组件里提取时，也可以使用其别名 slot相当于 react 的 children，自定义组件双标签中包的那一块内容 匿名插槽：数据 父-&gt;子父组件： 123456789101112131415161718192021222324&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h3&gt;parent Comp&lt;/h3&gt; &lt;div class=&quot;content&quot;&gt; &lt;Category title=&quot;热门游戏列表&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;game in ganmes&quot; :key=&quot;game.id&quot;&gt;&#123;&#123; game.name &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/Category&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import Category from &quot;./CategoryBoard.vue&quot;; import &#123; reactive &#125; from &quot;vue&quot;; const ganmes = reactive([ &#123; id: 1, name: &quot;英雄联盟&quot; &#125;, &#123; id: 2, name: &quot;王者荣耀&quot; &#125;, &#123; id: 3, name: &quot;绝地求生&quot; &#125;, &#123; id: 4, name: &quot;原神&quot; &#125;, ]);&lt;/script&gt; 子组件：相当于用 slot 进行占位 html 的内容： 1234567891011&lt;template&gt; &lt;div class=&quot;category&quot;&gt; &lt;h2&gt;&#123;&#123; title &#125;&#125;&lt;/h2&gt; &lt;!-- slot 相当于react 的 children --&gt; &lt;slot&gt;默认内容&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; defineProps([&quot;title&quot;]);&lt;/script&gt; 具名插槽：数据 父-&gt;子父组件：其中 #s1 #s2 是插槽的名称，可以自定义，#s1 号是v-slot:s1的缩写 1234567891011121314151617181920212223242526272829&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h3&gt;parent Comp&lt;/h3&gt; &lt;div class=&quot;content&quot;&gt; &lt;Category title=&quot;热门游戏列表&quot;&gt; &lt;template #s1&gt; &lt;h2&gt;热门游戏列表&lt;/h2&gt; &lt;/template&gt; &lt;template #s2&gt; &lt;div class=&quot;games&quot;&gt; &lt;div v-for=&quot;game in ganmes&quot; :key=&quot;game.id&quot;&gt;&#123;&#123; game.name &#125;&#125;&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;/Category&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import Category from &quot;./CategoryBoard.vue&quot;; import &#123; reactive &#125; from &quot;vue&quot;; const ganmes = reactive([ &#123; id: 1, name: &quot;英雄联盟&quot; &#125;, &#123; id: 2, name: &quot;王者荣耀&quot; &#125;, &#123; id: 3, name: &quot;绝地求生&quot; &#125;, &#123; id: 4, name: &quot;原神&quot; &#125;, ]);&lt;/script&gt; 子组件：可以看到，slot 分为 s1 和 s2，分别对应子组件中的上下的两个插槽 123456&lt;template&gt; &lt;div class=&quot;category&quot;&gt; &lt;slot name=&quot;s1&quot;&gt;默认内容1&lt;/slot&gt; &lt;slot name=&quot;s2&quot;&gt;默认内容2&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt; 作用域插槽：数据 子-&gt;父简单来说，这个是要解决数据放在子组件处，将子组件数据传递给父组件而设计的插槽。 父组件： 123456789101112131415&lt;template&gt; &lt;div class=&quot;game&quot;&gt; &lt;ScopedSlotChild&gt; &lt;template v-slot:game-slot=&quot;params&quot;&gt; &lt;ol&gt; &lt;li v-for=&quot;game in params.games&quot; :key=&quot;game.id&quot;&gt;&#123;&#123; game.name &#125;&#125;&lt;/li&gt; &lt;/ol&gt; &lt;/template&gt; &lt;/ScopedSlotChild&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import ScopedSlotChild from &quot;./ScopedSlotChild.vue&quot;;&lt;/script&gt; 子组件： 12345678910111213141516&lt;template&gt; &lt;div class=&quot;game&quot;&gt; &lt;h2&gt;游戏列表&lt;/h2&gt; &lt;slot name=&quot;game-slot&quot; :games=&quot;games&quot;&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; reactive &#125; from &quot;vue&quot;; const games = reactive([ &#123; id: 1, name: &quot;Dota 2&quot; &#125;, &#123; id: 2, name: &quot;Counter-Strike: Global Offensive&quot; &#125;, &#123; id: 3, name: &quot;League of Legends&quot; &#125;, ]);&lt;/script&gt; 以上有几个注意的点： slot 的 name 属性 name=&quot;game-slot&quot;，可以省略，当 slot 没有 name 属性，那父组件也不用起别名 slot 的 name 属性如果出现，那么在父组件的别名，例如：v-slot:game-slot=&quot;params&quot; 的:game 必须和 slot 的 name 属性一致 当 slot 的 name 属性值为 default 时，父组件的别名也可以省略 emit 事件这种方案其实我比较反感，因为上面的回调函数完全可以取代他，但既然框架提供了，那也得介绍一下 接着上面的例子，简单来说就是在子组件中 将点击事件加上 emit api 根据 vue2 的文档，将命名由上面的驼峰法，改为 kebab-case 命名法则，即用 - 连接 1234567&lt;button @click=&quot;emit(&#x27;send-toy-to-parent&#x27;, toy)&quot;&gt;send to parent&lt;/button&gt;&lt;script&gt; // ... const emit = defineEmits([&quot;send-toy-to-parent&quot;]);&lt;/script&gt; 父组件中，接收子组件的点击事件，并做相应处理 将原来的 :click 改为 vue2 的写法： @send-toy-to-parent，如下： 1&lt;Child :house=&quot;house&quot; @send-toy-to-parent=&quot;getToyFromChild&quot; /&gt; $ref -&gt; 父子， $parent -&gt; 子父先上代码，父组件： 12345678910111213141516171819202122232425&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h3&gt;parent comp&lt;/h3&gt; &lt;h4&gt;house: &#123;&#123; house &#125;&#125;&lt;/h4&gt; &lt;button @click=&quot;getAllChildrenBooks($refs)&quot;&gt;+ Children 3 books&lt;/button&gt; &lt;Child1Comp ref=&quot;child1&quot; /&gt; &lt;Child2Comp ref=&quot;child2&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref &#125; from &quot;vue&quot;; import Child1Comp from &quot;./Child1Comp.vue&quot;; import Child2Comp from &quot;./Child2Comp.vue&quot;; const house = ref(4); const getAllChildrenBooks = (refs: &#123; [x: string]: any &#125;) =&gt; &#123; for (let key in refs) &#123; refs[key].books += 3; &#125; &#125;; defineExpose(&#123; house &#125;);&lt;/script&gt; 子组件： 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h3&gt;Child 1 Comp&lt;/h3&gt; &lt;h4&gt;books: &#123;&#123; books &#125;&#125;&lt;/h4&gt; &lt;button @click=&quot;minusHouse($parent)&quot;&gt;take one house&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref &#125; from &quot;vue&quot;; const books = ref(3); defineExpose(&#123; books &#125;); const minusHouse = (parent: any) =&gt; &#123; if (parent.house &lt;= 0) return; parent.house--; &#125;;&lt;/script&gt; 可以看出这个属性得配合 defineExpose() 使用，且必须是父子组件 在各自组件里，通过回调函数 $parent 获取父组件，通过 $refs 获取子组件 这种写法，允许在父组件获取多个子组件的变量值数据 隔代\\跨代传值$attrParentComp.vue 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h1&gt;Parent Comp&lt;/h1&gt; &lt;h2&gt;a: &#123;&#123; a &#125;&#125;&lt;/h2&gt; &lt;h2&gt;b: &#123;&#123; b &#125;&#125;&lt;/h2&gt; &lt;ChildComp :a=&quot;a&quot; :b=&quot;b&quot; v-bind=&quot;&#123; x: 100 &#125;&quot; :updateA=&quot;updateA&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import ChildComp from &quot;./ChildComp.vue&quot;; import &#123; ref &#125; from &quot;vue&quot;; const a = ref(1); const b = ref(2); const updateA = (val: number) =&gt; &#123; a.value += val; &#125;;&lt;/script&gt; ChildComp.vue中间的组件，仅写一个属性就够了 v-bind=&quot;$attrs&quot; 12345678910&lt;template&gt; &lt;div class=&quot;child&quot;&gt; &lt;h1&gt;Child Comp&lt;/h1&gt; &lt;GrandChildComp v-bind=&quot;$attrs&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import GrandChildComp from &quot;./GrandChildComp.vue&quot;;&lt;/script&gt; GrandChildComp.vue最底层的组件直接接收 1234567891011121314&lt;template&gt; &lt;div class=&quot;grandChild&quot;&gt; &lt;h1&gt;Grand Child Comp&lt;/h1&gt; &lt;h2&gt;props from Parent:&lt;/h2&gt; &lt;h3&gt;&#123;&#123; a &#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123; b &#125;&#125;&lt;/h3&gt; &lt;h3&gt;&#123;&#123; x &#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;updateA(3)&quot;&gt;cb to parent updateA&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; defineProps([&quot;a&quot;, &quot;b&quot;, &quot;x&quot;, &quot;updateA&quot;]);&lt;/script&gt; 从上面的代码可以看出，中间的层级如果只写 v-bind=&quot;$attrs&quot; 就可以无限层级的传参，而从最底层的子组件开始，如果要回传到最顶层，也只需写回调函数即可 provide + inject这个比起上一个更简单，上一个中间组件还需要写一个 v-bind=&quot;$attrs&quot;属性，而这种方法中间组件不用添加任何属性 祖先组件用 provide 注入数据，后代组件用 inject 获取数据 祖先组件： 1234567891011121314151617181920212223242526&lt;template&gt; &lt;div class=&quot;parent&quot;&gt; &lt;h1&gt;Parent Comp&lt;/h1&gt; &lt;h2&gt;house: &#123;&#123; house &#125;&#125; 万元&lt;/h2&gt; &lt;h2&gt;car: &#123;&#123; car.price &#125;&#125; 万元&lt;/h2&gt; &lt;ChildComp /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import ChildComp from &quot;./ChildComp.vue&quot;; import &#123; ref, reactive, provide &#125; from &quot;vue&quot;; const house = ref(800); const car = reactive(&#123; brand: &quot;Benz&quot;, price: 80, &#125;); const updateHousePrice = (value: number) =&gt; &#123; house.value -= value; &#125;; provide(&quot;houseContext&quot;, &#123; house, updateHousePrice &#125;); provide(&quot;car&quot;, car);&lt;/script&gt; 最底层的孙子组件： 1234567891011121314151617181920&lt;template&gt; &lt;div class=&quot;grandgrandChild&quot;&gt; &lt;h1&gt;Grand Grand Child Comp&lt;/h1&gt; &lt;h2&gt;house &amp; car from parent:&lt;/h2&gt; &lt;h3&gt;house: &#123;&#123; house &#125;&#125; 万元&lt;/h3&gt; &lt;h3&gt;car: 一辆&#123;&#123; y.brand &#125;&#125;车，价值&#123;&#123; y.price &#125;&#125; 万元&lt;/h3&gt; &lt;button @click=&quot;updateHousePrice(1)&quot;&gt;修改house价值&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; inject &#125; from &quot;vue&quot;; // 直接解构出回调函数updateHousePrice const &#123; house, updateHousePrice &#125; = inject(&quot;houseContext&quot;, &#123; house: 0, updateHousePrice: (num: number) =&gt; &#123;&#125;, &#125;); const y = inject(&quot;car&quot;, &#123; brand: &quot;BMW&quot;, price: 60 &#125;);&lt;/script&gt; 从上面的代码可以看出： provide 的第一个参数是定义所传的值的名字，第二个参数可以是单一值，也可以是复杂的对象 inject 的第一个参数是定义所传的值的名字，第二个参数是默认值，如果传值失败，则使用默认值 provide 和 inject 是 vue3 的新特性，在 vue2 中，可以通过 $parent 和 $children 来实现 任意组件互传mitt这是一个独立压缩后只有几百字节的库 mitt，node 环境下均可用，不仅仅局限于 vue 1npm install mitt 创建 utils/emitter.ts 文件 12345678import mitt, &#123; type Emitter &#125; from &quot;mitt&quot;;type Events = &#123; [key: string]: string;&#125;;const emitter: Emitter&lt;Events&gt; = mitt();export default emitter; 组件 1 1234567891011121314&lt;template&gt; &lt;div class=&quot;comp1&quot;&gt; &lt;h2&gt;组件1&lt;/h2&gt; &lt;h3&gt;我的玩具：&#123;&#123; toyCar &#125;&#125;&lt;/h3&gt; &lt;button @click=&quot;emitter.emit(&#x27;send-to-comp2&#x27;, toyCar)&quot;&gt;发送给组件2&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref &#125; from &quot;vue&quot;; import emitter from &quot;@/utils/emitter&quot;; const toyCar = ref(&quot;🚙&quot;);&lt;/script&gt; 组件 2 12345678910111213141516171819&lt;template&gt; &lt;div class=&quot;comp2&quot;&gt; &lt;div&gt;my toy: &#123;&#123; toyCarFrComp1 &#125;&#125;&lt;/div&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref, onUnmounted &#125; from &quot;vue&quot;; import emitter from &quot;@/utils/emitter&quot;; const toyCarFrComp1 = ref(&quot;&quot;); emitter.on(&quot;send-to-comp2&quot;, (value: string) =&gt; &#123; toyCarFrComp1.value = value; &#125;); onUnmounted(() =&gt; &#123; emitter.off(&quot;send-to-comp2&quot;); &#125;);&lt;/script&gt; 发送数据方，可以看到上面的 emitter 里调用了 .emit() 方法，.emit() 方法接收两个参数，第一个参数是事件名称，第二个参数是事件携带的数据。 接受数据方，可以看到上面的 emitter 里调用了 .on() 方法，.on() 方法接收两个参数，第一个参数是事件名称，第二个参数是事件监听函数。赋值给页面对应的变量名 onUnmounted 的作用是在组件卸载时，也卸载掉监听事件，避免内存留存 Pinia这种在上面单独拎出来的讲了，这里就不多说了，直接看上面的例子 customRef 自定义响应式这是一个常用的 api，例如实现防抖，我们用普通 ref 时加上双向数据绑定时，input 框输入实时变化都会实时渲染，如果页面信息过多，那么会影响性能，所以需要用到 customRef实现防抖功能： 我们把他写为一个钩子函数： 123456789101112131415161718192021222324import &#123; customRef &#125; from &quot;vue&quot;;const useDelayInput = (initVal: string = &quot;&quot;, delay: number = 500) =&gt; &#123; const msg = customRef((track, trigger) =&gt; &#123; return &#123; // msg 被读取时调用： get() &#123; track(); // return initVal; &#125;, // msg 被修改时调用： set(value) &#123; clearTimeout(delay); delay = setTimeout(() =&gt; &#123; initVal = value; trigger(); &#125;, delay); &#125;, &#125;; &#125;); return msg;&#125;;export default useDelayInput; 使用： 1234567891011&lt;template&gt; &lt;div class=&quot;app&quot;&gt; &lt;h2&gt;&#123;&#123; msg &#125;&#125;&lt;/h2&gt; &lt;input type=&quot;text&quot; v-model=&quot;msg&quot; /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import useDelayInput from &quot;../hooks/useDelayInput&quot;; const msg = useDelayInput(&quot;customRef&quot;, 800);&lt;/script&gt; 从钩子函数可以出： customRef 里是一个函数，返回一个对象，对象里有 get 和 set 方法，get 方法是读取数据，set 方法是修改数据 track 和 trigger 是两个函数，track 是读取数据时调用，trigger 是修改数据时调用 track 的作用是告诉 vue 追踪依赖，trigger 是告诉 vue 触发依赖 shallowRef 和 shallowReactive这 2 个 api 旨在对付那些比较大的 Object，只监听第一层，层次比较深的数据不会被监听到 shallowRef 举例： 1234567891011121314151617&lt;script lang=&quot;ts&quot; setup&gt; import &#123; shallowRef, shallowReactive &#125; from &quot;vue&quot;; // 当修改以下数据时： const toy = shallowRef(&#123; toy: &quot;🚗&quot;, &#125;); const change = () =&gt; &#123; // ❌ 无效修改：shallowRef 只监听第一层，只会监听到 toy.value // toy.value.toy = &quot;🚙&quot;; // ✅ 修改成功 toy.value = &#123; toy: &quot;🚙&quot;, &#125;; &#125;;&lt;/script&gt; shallowRef 举例： 123456789101112131415&lt;script lang=&quot;ts&quot; setup&gt; import &#123; shallowReactive &#125; from &quot;vue&quot;; const nations = shallowRef(&#123; China: &quot;CN&quot;, &#125;); const changenations = () =&gt; &#123; // ❌无效修改： // nations.value.China = &#x27;中国&#x27; // ✅ 修改成功 nations.value = &#123; China: &quot;中国&quot;, &#125;; &#125;;&lt;/script&gt; shallowReactive 举例： 1234567891011&lt;script lang=&quot;ts&quot; setup&gt; const toys = shallowReactive(&#123; car: &quot;🚗&quot;, animals: &#123; dog: &quot;🐭&quot;, cat: &quot;🐱&quot; &#125;, &#125;); // ✅ 修改成功: 位于对象第一层： const changeToyCar = () =&gt; (toys.car = &quot;🚙&quot;); // ❌ 无效修改：位于对象更深的层次： const changeAnimals = () =&gt; (toys.animals.dog = &quot;🐶&quot;);&lt;/script&gt; 但当我把上面 const changeToyCar = () =&gt; (toys.car = &quot;🚙&quot;); 函数改为： 12345678&lt;script lang=&quot;ts&quot; setup&gt; // ✅ 修改成功: // ❗️但不推荐，因为对象会触发两次修改： const changeToyCar = () =&gt; &#123; toys.car = &quot;🚙&quot;; toys.animals.dog = &quot;🐶&quot;; &#125;;&lt;/script&gt; 确两个都成功了，toys.animals.dog，尽管这个属性不是响应式的，但因为之前对 toys.car 的修改已经触发了更新，所以任何依赖于 toys 的视图都会重新渲染，这时你会看到 toys.animals.dog 的新值。所以不推荐这种写法，他与shallowRef的原意背道而驰，直接用 ref即可。 readOnly 和 shallowReadOnly对象整体只读和浅层只读，只针对于 reactive 包裹的对象属性，看下面的例子： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div&gt; &lt;p&gt;Deep Readonly Car: &#123;&#123; deepReadonlyCar &#125;&#125;&lt;/p&gt; &lt;p&gt;Shallow Readonly Car: &#123;&#123; shallowReadonlyCar &#125;&#125;&lt;/p&gt; &lt;p&gt; Nested Property in Shallow Readonly: &#123;&#123; shallowReadonlyCar.details.color &#125;&#125; &lt;/p&gt; &lt;button @click=&quot;tryToModify&quot;&gt;Try to Modify&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; readonly, shallowReadonly, reactive &#125; from &quot;vue&quot;; // 创建一个响应式对象 const car = reactive(&#123; model: &quot;Tesla Model 3&quot;, details: &#123; color: &quot;Red&quot;, year: 2023, &#125;, &#125;); // 使用 readonly 创建一个深层只读的响应式对象 const deepReadonlyCar = readonly(car); // 使用 shallowReadonly 创建一个浅层只读的响应式对象 const shallowReadonlyCar = shallowReadonly(car); // 尝试修改对象的函数 const tryToModify = () =&gt; &#123; // ❌ 这个对象只读，所以控制台会发出警告 warn 不能修改 deepReadonlyCar.model = &quot;Tesla Model S&quot;; // ❌ 浅层只读对象，依然不能修改 shallowReadonlyCar.model = &quot;Tesla Model X&quot;; // 这将不会生效，并且控制台会给出警告 // ✅ 成功，shallowReadonlyCar 的嵌套对象属性，因为 shallowReadonly 是浅层的 shallowReadonlyCar.details.color = &quot;Blue&quot;; // 这将生效，但修改不会触发响应式更新 &#125;;&lt;/script&gt; toRaw 和 markRawtoRaw : 这是一个可以用于临时读取而不引起代理访问/跟踪开销，或是写入而不触发更改的特辣方法。不建议保存对原始对象的持久引用，请还慎使用。toRaw 何时使用？—-在露要将响应式对象传递给非 Vue 的库或外部系统时，使用 toRaw 可以确保它们收到的是普通对象 markRaw 标记一个对象，使其永远不会变成响应式的 例子： 123456789101112131415161718192021222324252627282930&lt;template&gt; &lt;div&gt; &lt;p&gt;Raw Value: &#123;&#123; rawValue.foo &#125;&#125;&lt;/p&gt; &lt;p&gt;Marked Raw Value: &#123;&#123; markedRawValue.foo &#125;&#125;&lt;/p&gt; &lt;button @click=&quot;modifyToRaw&quot;&gt;Modify to Raw&lt;/button&gt; &lt;button @click=&quot;modifyMarkRaw&quot;&gt;Modify Marked Raw&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup&gt; import &#123; reactive, toRaw, markRaw &#125; from &quot;vue&quot;; const reactiveValue = reactive(&#123; foo: &quot;Reactive Foo&quot; &#125;); // 使用 toRaw 获取响应式对象的原始对象 const rawValue = toRaw(reactiveValue); const originalObject = &#123; foo: &quot;Marked Raw Foo&quot; &#125;; const markedRawValue = markRaw(originalObject); const modifyToRaw = () =&gt; &#123; // 修改原始对象的属性，不会触发视图更新，因为它不是响应式的 rawValue.foo = &quot;Modified Raw Foo&quot;; &#125;; const modifyMarkRaw = () =&gt; &#123; // 修改被标记为原始的对象，同样不会触发视图更新 markedRawValue.foo = &quot;Modified Marked Raw Foo&quot;; &#125;;&lt;/script&gt; Teleport这个类似 React 的 createPortal 功能。我们看看 React 官网的示例代码： 1234&lt;div&gt; &lt;SomeComponent /&gt; &#123;createPortal(children, domNode, key?)&#125;&lt;/div&gt; 实际使用中，我们多把弹框从底层传送到 &lt;body&gt; 上，而不是某层的子组件上。 123456789101112131415161718&lt;template&gt; &lt;div&gt; &lt;button @click=&quot;showModal = true&quot;&gt;pop out modal&lt;/button&gt; &lt;teleport to=&quot;body&quot;&gt; &lt;div v-if=&quot;showModal&quot; class=&quot;modal&quot;&gt; &lt;h2&gt;title&lt;/h2&gt; &lt;p&gt;this is a modal create by teleport&lt;/p&gt; &lt;button @click=&quot;showModal = false&quot;&gt;close&lt;/button&gt; &lt;/div&gt; &lt;/teleport&gt; &lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; import &#123; ref &#125; from &quot;vue&quot;; const showModal = ref(false);&lt;/script&gt; suspence 异步组件参考了 React 18 的 suspence 组件，suspence也是 Vue3 的新特性，用于实现组件的懒加载。 使用例子如下： 1234567891011121314151617181920212223&lt;template&gt; &lt;div&gt; &lt;h1&gt;Vue 3 Suspense Example&lt;/h1&gt; &lt;Suspense&gt; &lt;template #default&gt; &lt;!-- &lt;AsyncComponent /&gt; --&gt; &lt;FetchComp /&gt; &lt;/template&gt; &lt;template #fallback&gt; &lt;h1&gt;Loading...&lt;/h1&gt; &lt;/template&gt; &lt;/Suspense&gt; &lt;FetchComp /&gt; &lt;/div&gt;&lt;/template&gt;&lt;script setup lang=&quot;ts&quot;&gt; import &#123; defineAsyncComponent, Suspense &#125; from &quot;vue&quot;; import FetchComp from &quot;./FetchComp.vue&quot;; // import()定义一个异步组件 const AsyncComponent = defineAsyncComponent(() =&gt; import(&quot;./AsyncComp.vue&quot;));&lt;/script&gt; FetchComp.vue 1234567891011&lt;template&gt; &lt;h2&gt;fetch comp&lt;/h2&gt; &lt;div class=&quot;chlid&quot;&gt;&#123;&#123; content &#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt; const request = await fetch( &quot;https://api.uomg.com/api/rand.qinghua?format=json&quot; ); const &#123; content &#125; = await request.json();&lt;/script&gt; 全局 apiVue3 在 main.ts 中，可以用全局 api 注册全局组件， app.component(name, component) 注册全局组件 app.directive(name, directive) 注册全局指令 app.provide(key, value) 注册全局 provide/inject app.config.globalProperties.$foo = &#39;bar&#39; 注册全局属性 app.unmount(element) 卸载应用 app.use(plugin) 安装插件 例子： 1234567891011121314151617181920212223242526272829import &#123; createApp &#125; from &quot;vue&quot;;import App from &quot;./App.vue&quot;;import &#123; createPinia &#125; from &quot;pinia&quot;;import router from &quot;./router&quot;;import Hello from &quot;./GlobalHello.vue&quot;;const app = createApp(App);const pinia = createPinia();app.use(pinia);app.use(router);app.mount(&quot;#app&quot;);// 定义全局组件：app.component(&quot;globalHello&quot;, Hello);// 定义全局变量：app.config.globalProperties.globalVariable = 999;// 官方建议 type 声明：declare module &quot;vue&quot; &#123; interface ComponentCustomProperties &#123; globalVariable: number; &#125;&#125;// 自定义指令：app.directive(&quot;focus&quot;, (ele) =&gt; &#123; ele.style.color = &quot;red&quot;; ele.style.backgoundColor = &quot;green&quot;;&#125;); 在任意一个 src 下的组件中使用，且不需要 import 1234567&lt;template&gt; &lt;GlobalHello /&gt; &lt;div&gt;&#123;&#123; globalNumber &#125;&#125;&lt;/div&gt; &lt;input v-focus /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot; setup&gt;&lt;/script&gt; 效果如下图： 非兼容性改变可以参考官方文档 重点关注这些比较常用的： 过渡类名 v-enter 修改为 v-enter-from、过渡类名 v-leave 修改为 v-leave-from。 keyCode 作为 v-on 修饰符的支持 v-model 指令在组件上的使用已经被重新设计，替换掉了 y-bind.sync v-if 和 v-for 在同一个元素身上使用时的优先级发生了变化。v-if 优先级 &gt; v-for 优先级 移除了 $on、$off 和 $once 实例方法。 移除了过滤器 filter 移除了 $children 实例 propert","tags":["Vue"]},{"title":"Node面试题及原理总结","path":"/2024/04/29/【2024-04-29】Node 面试题/","content":"最近面试了一些 Nodejs 的工作，总结了一些 Node 原理。这里分享一下。 0. Node 是什么？优缺点是什么？开源的，基于 V8 引擎的，非阻塞式异步 I/O 的 JavaScript 运行环境。 回答点：非阻塞 I/O (回调函数) + 事件队列 优点： 高并发场景 IO 密集型应用 （内存读取） 缺点： 不适合 CPU 密集型应用，只在单核 CPU 上运行 代码有问题，整个系统会发生崩溃 1. Node 的应用场景 后台管理系统，实时交互，高并发 canvas 绘图，联网 web 游戏，实时交互，高并发 webSocket, 聊天室 利用 db，搭建 json api 单页面浏览器应用及创建服务 2. Node 的全局对象全局对象是指在任何模块中都可以直接访问到的对象，而不需要通过 require 或其他方式进行导入。 global最基础的全局对象，类似于浏览器环境中的 window 对象。在 Node.js 中，所有全局变量（除了 global 本身以外）都是 global 对象的属性。 process这是一个提供了与当前 Node.js 进程互动接口的全局对象。通过 process 对象，我们可以获取到当前进程的信息，如 PID（进程 ID）、运行环境等。同时，它也提供了一些方法，如 process.exit()用于退出当前进程。 consoleBuffer在 Node.js 中，Buffer 类是一个全局可用的类型，用于处理二进制数据。它可以用于在 TCP 流、文件系统操作、以及其他上下文中与八位字节流进行交互。 setTimeout/setInterval/clearTimeout/clearInterval这些全局函数用于处理定时器。例如，setTimeout()函数用于在指定的毫秒数后执行一个函数，而 setInterval()函数则用于定期执行一个函数。 filename这是一个包含当前正在执行的脚本的文件名的全局变量。它返回的是文件所在位置的绝对路径。 dirname这是一个包含当前执行脚本所在目录的全局变量。它返回的是目录的绝对路径。 3. 模块加载机制 require()require 加载模块的机制 CommonJS 规范：require 是基于 CommonJS 规范的模块加载方式，主要在 Node.js 环境中使用。 动态加载：require 可以在代码的任何地方进行调用，允许动态地加载和执行模块。 同步加载：require 是同步的，意味着在模块加载完成之前，代码执行会暂停。 缓存机制：当使用 require 加载一个模块时，Node.js 会缓存该模块。如果再次尝试加载同一个模块，Node.js 会直接从缓存中取出，而不会重新执行模块的代码。 导出方式：使用 module.exports 或 exports 来导出模块成员。 import 模块加载机制 ES6 (ECMAScript 2015) 规范：import 是基于 ES6 模块的加载方式，旨在提供静态的模块结构。 静态加载：import 语句必须位于文件的顶部，不能在代码块内（如 if 语句或函数内）使用。 异步与同步：虽然 import 主要是同步的，但 ES6 也引入了动态 import() 函数，它返回一个 Promise，允许异步加载模块。 不缓存（默认情况下）：与 require 不同，每次使用 import 加载模块时，都会重新执行模块的代码（除非使用了特定的缓存策略或打包工具进行了优化）。 导出方式：使用 export 关键字来导出模块成员。 4. 基础模块基于事件处理，node 内置了不同的模块，如 fs、http、path、os、util、events、stream 等。下面，对相应的基础模块进行举例： fs 文件读取和写入1234567891011121314const fs = require(&quot;fs&quot;);// 读取文件异步：fs.readFile(&quot;example.txt&quot;, &quot;utf8&quot;, (err, data) =&gt; &#123; if (err) throw err; console.log(data);&#125;);// 写入文件const content = &quot;Hello, Node.js!&quot;;fs.writeFile(&quot;output.txt&quot;, content, (err) =&gt; &#123; if (err) throw err; console.log(&quot;The file has been saved!&quot;);&#125;); path 文件路径处理1234567const path = require(&quot;path&quot;);const fullPath = path.resolve(&quot;/foo/bar&quot;, &quot;./baz&quot;);console.log(fullPath); // 输出: /foo/bar/bazconst extname = path.extname(&quot;index.html&quot;);console.log(extname); // 输出: .html events 事件模块处理12345678const EventEmitter = require(&quot;events&quot;);const emitter = new EventEmitter();emitter.on(&quot;myEvent&quot;, (arg1, arg2) =&gt; &#123; console.log(`Event triggered with $&#123;arg1&#125; and $&#123;arg2&#125;`);&#125;);emitter.emit(&quot;myEvent&quot;, &quot;Hello&quot;, &quot;World&quot;); // 输出: Event triggered with Hello and World http HTTP 请求和响应1234567891011const http = require(&quot;http&quot;);const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); res.end(&quot;Hello, World! &quot;);&#125;);const port = 3000;server.listen(port, () =&gt; &#123; console.log(`Server running at http://localhost:$&#123;port&#125;/`);&#125;); url 处理123456789const url = require(&quot;url&quot;);const myURL = new URL(&quot;https://example.com/path?name=value#hash&quot;);console.log(myURL.protocol); // 输出: https:console.log(myURL.hostname); // 输出: example.comconsole.log(myURL.pathname); // 输出: /pathconsole.log(myURL.search); // 输出: ?name=valueconsole.log(myURL.hash); // 输出: #hash querystring 处理这个模块配合上面的 url 使用 12345678const querystring = require(&quot;querystring&quot;);const params = querystring.parse(&quot;name=John&amp;age=30&quot;);console.log(params.name); // 输出: Johnconsole.log(params.age); // 输出: 30const stringified = querystring.stringify(&#123; name: &quot;Jane&quot;, age: 25 &#125;);console.log(stringified); // 输出: name=Jane&amp;age=25 events 事件处理12345678const EventEmitter = require(&quot;events&quot;);const emitter = new EventEmitter();emitter.on(&quot;myEvent&quot;, (arg1, arg2) =&gt; &#123; console.log(`Event triggered with $&#123;arg1&#125; and $&#123;arg2&#125;`);&#125;);emitter.emit(&quot;myEvent&quot;, &quot;Hello&quot;, &quot;World&quot;); // 输出: Event triggered with Hello and World os 操作系统模块1234const os = require(&quot;os&quot;);console.log(os.homedir()); // 输出用户的主目录路径console.log(os.totalmem()); // 输出系统的总内存（以字节为单位） 5. Node 有哪些网络模块以 demo 代码来说明问题： http 模块1234567891011const http = require(&quot;http&quot;);const server = http.createServer((req, res) =&gt; &#123; res.writeHead(200, &#123; &quot;Content-Type&quot;: &quot;text/plain&quot; &#125;); res.end(&quot;Hello, World! &quot;);&#125;);const PORT = process.env.PORT || 3000;server.listen(PORT, () =&gt; &#123; console.log(`Server is running on port $&#123;PORT&#125;`);&#125;); https 模块12345678910111213141516171819const https = require(&quot;https&quot;);const fs = require(&quot;fs&quot;);// 需要SSL证书的配置：const options = &#123; key: fs.readFileSync(&quot;path/to/private.key&quot;), cert: fs.readFileSync(&quot;path/to/certificate.pem&quot;), ca: fs.readFileSync(&quot;path/to/ca.pem&quot;),&#125;;const server = https.createServer(options, (req, res) =&gt; &#123; res.writeHead(200); res.end(&quot;Hello, Secure World! &quot;);&#125;);const PORT = process.env.PORT || 443;server.listen(PORT, () =&gt; &#123; console.log(`Secure server is running on port $&#123;PORT&#125;`);&#125;); net 模块TCP 模块可以用来创建 TCP 服务器。比起 HTTP 底层 1234567891011121314151617const net = require(&quot;net&quot;);const server = net.createServer((socket) =&gt; &#123; socket.write(&quot;Welcome to the TCP server! &quot;); socket.on(&quot;data&quot;, (data) =&gt; &#123; console.log(`Received from client: $&#123;data.toString()&#125;`); socket.write(`Server received: $&#123;data.toString()&#125;`); &#125;); socket.on(&quot;end&quot;, () =&gt; &#123; console.log(&quot;Client connection ended.&quot;); &#125;);&#125;);const PORT = process.env.PORT || 12345;server.listen(PORT, () =&gt; &#123; console.log(`TCP server is listening on port $&#123;PORT&#125;`);&#125;); 6. Node 处理高并发任务的原理非阻塞 I/O：Node.js 中的 I/O 操作（如文件读写、网络通信等）是非阻塞的，这意味着当一个 I/O 操作被发起时，Node.js 不会等待这个操作完成，而是继续执行后面的代码。当 I/O 操作完成时，会通过回调函数或者 Promise 的方式通知 Node.js，从而进行后续处理。这种方式避免了线程阻塞，使得 Node.js 可以同时处理多个请求。 事件驱动：Node.js 采用事件驱动模型，通过监听事件来处理各种任务。例如，当一个 HTTP 请求到达时，Node.js 会触发一个 ‘request’ 事件，并将请求对象作为参数传递给事件处理函数。这种模型使得 Node.js 可以轻松地处理大量并发的网络连接。 异步编程：Node.js 鼓励使用异步编程模式，通过回调函数、Promise、async/await 等技术来处理异步操作。这使得 Node.js 能够在处理一个请求的同时，继续接收和处理其他请求，从而实现高并发。 单线程的优势：虽然 Node.js 是单线程的，但这意味着它不需要像多线程环境那样处理复杂的线程同步问题，从而降低了编程的复杂性。此外，单线程模型也使得 Node.js 在处理大量并发连接时具有较低的内存占用和上下文切换开销。 利用多核处理器：尽管 Node.js 本身是单线程的，但你可以通过创建多个 Node.js 进程来利用多核处理器的能力。例如，使用 Node.js 的 cluster 模块可以创建多个工作进程，每个进程运行在不同的 CPU 核心上，从而实现并行处理。此外，还可以使用 PM2 等工具来管理和负载均衡多个 Node.js 进程。 线程池处理 CPU 密集型任务：对于 CPU 密集型任务（如大量的数学计算或数据处理），Node.js 的单线程模型可能不是最高效的。在这种情况下，可以使用 Node.js 的 worker_threads 模块或其他第三方线程池库（如前面提到的 node-worker-threads-pool）来创建多线程环境，从而提高 CPU 密集型任务的处理能力。 7. Node 的多线程处理模块Node.js 本身是单线程的，通过事件循环和非阻塞 I/O 操作实现了高并发。然而，有些 CPU 密集型任务可能会阻塞事件循环，这时候可以考虑使用线程池来处理这些任务。 在 Node.js 中，可以使用 worker_threads 模块来创建多线程，但这个模块相对底层，直接使用可能会比较复杂。为了简化线程池的使用，可以使用第三方库，比如 fast-pool 或 node-worker-threads-pool。 1npm install node-worker-threads-pool 下面是一个使用 node-worker-threads-pool 库创建线程池的简单示例： 1234567891011121314151617181920212223242526272829303132const &#123; WorkerPool &#125; = require(&quot;node-worker-threads-pool&quot;);// 创建一个具有4个工作线程的线程池const pool = new WorkerPool(&#123; max: 4 &#125;);// 定义一个要在工作线程中执行的任务const task = (n) =&gt; &#123; let sum = 0; for (let i = 0; i &lt; n; i++) &#123; sum += i; &#125; return sum;&#125;;// 将任务提交到线程池执行，并处理返回的结果pool .exec(task, [100000000]) .then((result) =&gt; &#123; console.log(&quot;Result:&quot;, result); &#125;) .catch((err) =&gt; &#123; console.error(&quot;Error:&quot;, err); &#125;);// 当不再需要线程池时，应该关闭它// 注意：在实际应用中，通常会在应用程序终止时关闭线程池。// 这里为了示例简单，直接在后面关闭了。setTimeout(() =&gt; &#123; pool.terminate().then(() =&gt; &#123; console.log(&quot;Worker pool terminated&quot;); &#125;);&#125;, 5000); // 等待5秒后关闭线程池 8. I/O 模型的分类Node 里经常提到非阻塞 I/O, 那么对于 I/O 模型，也是有多重分类。在电脑中，IO 是处理输入输出操作的不同方式。这些模型主要关注于如何有效地管理数据的读写，特别是在涉及磁盘、网络或其他外部设备时。 阻塞在这种模型中，当用户空间的应用程序执行一个系统调用进行 IO 操作时，如果该操作不能立即完成，那么应用程序会被阻塞，直到该 IO 操作完成为止。在此期间，应用程序无法执行其他任务。 非阻塞与阻塞 IO 相反，非阻塞 IO 模型中的系统调用会立即返回，无论 IO 操作是否完成。如果数据还未准备好，系统调用会返回一个错误或者表示数据未准备好的状态。这样，应用程序可以继续执行其他任务，而不会被阻塞。 多路复用这种模型允许应用程序同时监控多个 IO 通道，例如多个网络连接或文件描述符。通过使用 select、poll 或 epoll 等系统调用，应用程序可以等待多个 IO 事件，而无需为每个通道都使用一个单独的线程或进程。当某个通道准备好进行 IO 操作时，应用程序会收到通知并进行相应的处理。 异步在这种模型中，当应用程序发起一个 IO 操作后，它不需要等待该操作的完成。相反，当数据准备好时，操作系统会通过某种机制（如回调函数、事件或信号）通知应用程序。这种模型允许应用程序继续执行其他任务，而不需要轮询或等待 IO 操作的完成。 9. Node 的事件循环机制Node.js 的事件循环是基于 libuv 跨平台的异步 I/O 库（multi-platform async IO）实现的。这个库关联到一个EVENT_QUEUE先进先出（FIFO）的事件队列，并且该事件循环负责处理所有事件EVENT_LOOP，包括定时器、文件系统操作等。 timers 阶段：此阶段执行定时器（setTimeout/setInterval）的回调函数。 I/O callbacks 阶段：执行除了定时器和 setImmediate 的回调外的 I/O 回调。 idle 和 prepare 阶段：这两个阶段主要为系统内部使用，可以认为是闲置时间。 poll 阶段：轮询可用的 I/O 事件，执行与 I/O 相关的回调（几乎所有情况下，除了关闭的回调函数，由计时器和 setImmediate 调度的回调函数）。 check 阶段：在此阶段执行 setImmediate 的回调函数。 close callbacks 阶段：执行关闭的回调函数，如 socket.on(‘close’, …)。 微任务：包括process.nextTick()和其他微任务队列（例如 Promise 的回调函数）。 宏任务：timer queue：setTimeout/setIntervalpoll queue: IOcheck queue: setImmediateclose queue: socket.on(‘end’) process orders: nextTick micro task queue other micro task queue timer queue poll queue check queue close queue here is the demo code: 1234567891011121314151617181920212223242526272829303132const fs = require(&quot;fs&quot;);console.log(&quot;Start&quot;);// 异步文件系统操作fs.readFile(__filename, &quot;utf8&quot;, (err, data) =&gt; &#123; if (err) throw err; console.log(&quot;File read complete:&quot;, data.length);&#125;);// 使用setTimeout来延迟执行一个函数setTimeout(() =&gt; &#123; console.log(&quot;Timeout callback executed!&quot;);&#125;, 0); // 设置为0毫秒并不意味着会立即执行，而是将其放入事件队列等待执行// 使用setImmediate来在当前事件循环之后执行一个函数setImmediate(() =&gt; &#123; console.log(&quot;setImmediate callback executed!&quot;);&#125;);// 使用process.nextTick在当前操作完成后立即执行一个函数process.nextTick(() =&gt; &#123; console.log(&quot;Next tick callback executed!&quot;);&#125;);console.log(&quot;Scheduled all callbacks&quot;);// Start// Scheduled all callbacks// Next tick callback executed!// setImmediate callback executed!// Timeout callback executed!// File read complete: 1036 再一个 demo 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849async function async1() &#123; console.log(&quot;async1 start&quot;); await async2(); console.log(&quot;async1 end&quot;);&#125;async function async2() &#123; console.log(&quot;async2&quot;);&#125;console.log(&quot;start&quot;);setTimeout(function () &#123; console.log(&quot;setTimeout1&quot;);&#125;, 0); // setTimeout 队列setTimeout(function () &#123; console.log(&quot;setTimeout2&quot;);&#125;, 200); // check 队列setImmediate(() =&gt; console.log(&quot;setImmediate&quot;));process.nextTick(() =&gt; console.log(&quot;nextTick1&quot;));async1();process.nextTick(() =&gt; console.log(&quot;nextTick2&quot;));new Promise((resolve) =&gt; &#123; console.log(&quot;promise1&quot;); resolve(&quot;&quot;); console.log(&quot;promise2&quot;);&#125;).then(() =&gt; &#123; console.log(&quot;promise3&quot;);&#125;);console.log(&quot;script end&quot;);// start// async1 start// async2// promise1// promise2// script end// nextTick1// nextTick2// async1 end// promise3// setTimeout1// setImmediate// setTimeout2 10. Node 的全局异常处理process 对象来捕获全局异常。process 对象是一个全局变量，提供了与当前 Node.js 进程互动的接口。最佳实践是尽量避免依赖全局异常处理，而是在代码中尽可能明确地使用 try-catch 语句和 Promise 的错误处理机制来捕获和处理这些异常。在 process 里，可以监听以下事件来捕获全局异常： uncaughtExceptiona. 这种异常通常指的是在同步代码中未被 try-catch 语句捕获的错误，或者在异步回调中未被正确处理的错误。b. 常见的 JavaScript 错误类型，如 ReferenceError，SyntaxError 等c. 还包括系统级错误，如尝试打开不存在的文件时抛出的错误。 123456process.on(&quot;uncaughtException&quot;, (err) =&gt; &#123; console.error(&quot;捕获到未处理的异常：&quot;, err); // 在这里你可以记录异常信息，或者执行其他必要的操作&#125;);throw new Error(&quot;这是一个未捕获的异常&quot;); unhandledRejection这种异常特指与 Promise 相关的错误。当一个 Promise 被拒绝（rejected），且没有提供 .catch() 处理程序或在 async function 中没有使用 try…catch 语句来捕获错误时，就会触发 unhandledRejection 事件。 1234567process.on(&quot;unhandledRejection&quot;, (reason, promise) =&gt; &#123; console.error(&quot;捕获到未处理的 Promise 拒绝：&quot;, reason); // 在这里你可以记录异常信息，或者执行其他必要的操作&#125;);// 抛出一个未处理的 Promise 拒绝来测试全局异常捕获Promise.reject(new Error(&quot;这是一个未处理的 Promise 拒绝&quot;)); 11. Node 多核处理需要注意的是，开启多核处理并不是为了解决高并发问题，而主要是为了充分利用多核 CPU 的性能，提高应用程序的处理能力和响应速度。 cluster 模块demo 代码： 1234567891011121314151617181920212223242526272829const cluster = require(&quot;cluster&quot;);const os = require(&quot;os&quot;);const http = require(&quot;http&quot;);if (cluster.isMaster) &#123; // 获取CPU核心数 const cpuCount = os.cpus().length; console.log(`主进程 $&#123;process.pid&#125; 正在运行`); // 根据CPU核心数创建相应数量的工作进程 for (let i = 0; i &lt; cpuCount; i++) &#123; cluster.fork(); &#125; cluster.on(&quot;exit&quot;, (worker, code, signal) =&gt; &#123; console.log(`工作进程 $&#123;worker.process.pid&#125; 已退出`); &#125;);&#125; else &#123; // 工作进程中运行的代码 http .createServer((req, res) =&gt; &#123; res.writeHead(200); res.end(&quot;你好，这个响应来自进程 &quot; + process.pid); &#125;) .listen(8000); console.log(`工作进程 $&#123;process.pid&#125; 已启动`);&#125; child_process 模块childScript.js 文件: 1234567//process.on(&quot;message&quot;, (message) =&gt; &#123; console.log(&quot;Received message in child:&quot;, message); // 处理消息后发送回主进程 process.send(&#123; response: &quot;Message received&quot; &#125;);&#125;); 主进程文件： 1234567891011121314151617const &#123; fork &#125; = require(&quot;child_process&quot;);// 创建子进程const child = fork(&quot;./childScript.js&quot;);// 发送消息给子进程child.send(&#123; hello: &quot;world&quot; &#125;);// 监听来自子进程的消息child.on(&quot;message&quot;, (message) =&gt; &#123; console.log(&quot;Received message from child:&quot;, message);&#125;);// 监听子进程的退出事件child.on(&quot;exit&quot;, (code, signal) =&gt; &#123; console.log(`Child process exited with code $&#123;code&#125; and signal $&#123;signal&#125;`);&#125;); 第三方模块 workerpool线程池（Thread Pool）是一种多线程处理形式，它包含了一定数量的线程，这些线程都是处于等待状态，准备接收任务并执行。线程池的主要目的是复用线程，以减少在线程创建和销毁上的开销，并提高系统资源的利用率和响应速度。 1npm install workerpool 12345678910111213141516171819202122const WorkerPool = require(&quot;workerpool&quot;);const pool = new WorkerPool();// 定义一个将在工作线程中执行的函数pool .exec(&quot;fibonacci&quot;, [&quot;10&quot;], &#123; fibonacci: function (n) &#123; if (n &lt;= 1) return n; return fibonacci(n - 1) + fibonacci(n - 2); &#125;, &#125;) .then((result) =&gt; &#123; console.log(&quot;Fibonacci result:&quot;, result); &#125;) .catch((err) =&gt; &#123; console.error(err); &#125;) .finally(() =&gt; &#123; pool.terminate(); // 终止所有工作线程 &#125;);// 注意：在实际应用中，计算 Fibonacci 数列的更有效方法是使用动态规划来避免重复计算。 12. Node 如何处理监听内存的使用情况process.memoryUsage() 定期监听：12345678910111213const &#123; performance: any &#125; = require(&quot;perf_hooks&quot;);function monitorMemoryUsage() &#123; const memoryUsage = process.memoryUsage(); const now = performance.now(); console.log( `Time: $&#123;now.toFixed(3)&#125;ms - RSS: $&#123;(memoryUsage.rss / 1024 / 1024).toFixed( 2 )&#125; MB` );&#125;setInterval(monitorMemoryUsage, 1000); // 每秒监控一次 perf_hooks 模块：12345678910111213const &#123; performance &#125; = require(&quot;perf_hooks&quot;);function monitorMemoryUsage() &#123; const memoryUsage = process.memoryUsage(); const now = performance.now(); console.log( `Time: $&#123;now.toFixed(3)&#125;ms - RSS: $&#123;(memoryUsage.rss / 1024 / 1024).toFixed( 2 )&#125; MB` );&#125;setInterval(monitorMemoryUsage, 1000); // 每秒监控一次 13. Node 的垃圾回收机制Node.js 的垃圾回收机制主要基于 V8 引擎实现，而 V8 引擎的垃圾回收机制又主要基于分代式垃圾回收策略。这种策略根据对象的存活时间将内存分为不同的“代”，主要针对新生代（Young Generation）和老生代（Old Generation）进行不同的垃圾回收处理。 新生代（Young Generation）: 新生代是内存管理中的一块区域，专门用于存储生命周期较短的新创建的对象。 新生代内部通常采用复制(Copying)算法进行垃圾回收，如 Scavenge 算法，该算法将新生代内存一分为二，包括 From 空间和 To 空间。 当 From 空间快满时，垃圾回收器会遍历所有对象，将活跃对象从 From 空间复制到 To 空间，然后交换 From 和 To 的角色，准备下一轮的垃圾回收。 如果一个对象在新生代中经历了多次垃圾回收仍然存活，它将被认为是“长寿”对象，并被晋升到老生代中。 老生代（Old Generation）: 老生代是内存堆中的另一块区域，用于存储那些在多次新生代垃圾回收后仍然存活的对象，即生命周期较长的对象。 老生代内的垃圾回收相对不那么频繁，并且采用了不同的垃圾回收算法，如标记-清除（Mark-Sweep）算法。 在标记-清除算法中，垃圾回收器会从执行栈和全局对象上找到所有能访问到的对象，将它们标记为活跃对象。标记完成后，进入清除阶段，将没有被标记的对象清除，释放其占用的内存空间。 14. v8 引擎的内存泄露这个问题和浏览器端 JS 的内存泄露一样，都是由于对象没有被回收导致的。下面举例一些 demo 代码说明： 定时器设置后要及时释放： 12345678910function leakyTimer() &#123; const timerId = setInterval(() =&gt; &#123; console.log(&quot;This runs every second.&quot;); &#125;, 1000); // 清除： clearInterval(timerId);&#125;leakyTimer(); 闭包 12345678910111213function createLeakyClosure() &#123; let largeArray = new Array(1000000).fill(&quot;data&quot;); return function leakyFunction() &#123; console.log(&quot;This closure keeps the largeArray alive.&quot;); // 使用完后直接释放 largeArray = null; &#125;;&#125;const leakyClosure = createLeakyClosure();// 或者这里释放：// leakyClosure = null; 循环引用 123456789function createCircularReference() &#123; const objectA = &#123; name: &quot;Object A&quot; &#125;; const objectB = &#123; name: &quot;Object B&quot;, referenceToA: objectA &#125;; objectA.referenceToB = objectB; // 创建循环引用 // 即使没有其他代码引用这两个对象，由于它们之间存在循环引用，垃圾回收器可能无法正确释放它们&#125;createCircularReference(); 移除 DOM 节点的监听函数 12345678910111213const leakyButton = document.createElement(&quot;button&quot;);leakyButton.textContent = &quot;Click me&quot;;document.body.appendChild(leakyButton);function eventHandler() &#123; console.log(&quot;Button clicked!&quot;);&#125;// 添加事件监听器leakyButton.addEventListener(&quot;click&quot;, eventHandler);leakyButton.removeEventListener(&quot;click&quot;, eventHandler);document.body.removeChild(leakyButton); 全局对象未释放 12// 全局对象是指不用const 或 let 声明的变量，而又不释放他globalLargeObject = new Array(1000000).fill(&quot;unused data&quot;);","tags":["Nodejs"]},{"title":"Learn Nextjs with TodoList Demo Project","path":"/2024/02/29/【2024-02-29】Learn Nextjs with TodoList Demo Project/","content":"nextjs is a nodejs library that is a framework for building modern web apps from backend and frontend. Here I will share my experience of learning nextjs by coding a todo list demo project. Here is my project repository create a nextjs projectWe may create a floder for our project: 123mkdir nextjs-demo-todo-listcd todoList-demo-by-nextjsnpx create-next-app@latest . install dependenciesFor our simple demo project, we need to install prisma, that is a open-source ORM for nodejs. 1npm install prisma and we just use prisma to generate a sqlite database file: 1npx prisma init --datasouce-provider sqlite create the ORM model and migrate the db schemain prisma/schema.prisma file, we may updated as below: 1234567model Todo &#123; id String @id @default(uuid()) title String complete Boolean createAt DateTime @default(now()) updateAt DateTime @updatedAt&#125; run the migrate command: 1npx prisma migrate dev --name init we may see the prisma/migrations floder, and see the sql file. 12345678-- CreateTableCREATE TABLE &quot;Todo&quot; ( &quot;id&quot; TEXT NOT NULL PRIMARY KEY, &quot;title&quot; TEXT NOT NULL, &quot;complete&quot; BOOLEAN NOT NULL, &quot;createAt&quot; DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP, &quot;updateAt&quot; DATETIME NOT NULL); init the db seed datawe may refer to this prisma official tutorial to generate db seed data. 123touch prisma/seed.ts# using ts-node to run seed.ts file:npm i -D ts-node seed.ts: 1234567891011121314151617181920212223import &#123; PrismaClient &#125; from &quot;@prisma/client&quot;;const prisma = new PrismaClient();async function main() &#123; // generate the first todo data: await prisma.todo.create(&#123; data: &#123; title: &quot;Hello World&quot;, complete: false, &#125;, &#125;);&#125;main() .then(async () =&gt; &#123; await prisma.$disconnect(); &#125;) .catch(async (e) =&gt; &#123; console.error(e); await prisma.$disconnect(); process.exit(1); &#125;); in our project’s script, we may adding the config in tsconfig.json file: 12345&quot;ts-node&quot;: &#123; &quot;compilerOptions&quot;: &#123; &quot;module&quot;: &quot;CommonJS&quot; &#125;&#125; and then run the seed script: 1npx ts-node ./prisma/seed.ts startup the prisma UI pagethe prisma UI page is a web page that can help us to manage the db schema and data. we may run the command. it’s very easy to use. 1npx prisma studio it can be accessed by http://localhost:5555 create the db instance filewe may create a src/db.ts file to init the db instance:the boliplate code is from this prisma official tutorial : 12345678910111213import &#123; PrismaClient &#125; from &quot;@prisma/client&quot;;const prismaClientSingleton = () =&gt; &#123; return new PrismaClient(&#123; log: [&quot;query&quot;] &#125;);&#125;;declare global &#123; var prisma: undefined | ReturnType&lt;typeof prismaClientSingleton&gt;;&#125;export const prisma = globalThis.prisma ?? prismaClientSingleton();if (process.env.NODE_ENV !== &quot;production&quot;) globalThis.prisma = prisma; update the frontend pagesfor the homepage, we may update the src/page.tsx file: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import &#123; prisma &#125; from &quot;@/db&quot;;import Link from &quot;next/link&quot;;import TodoItem from &quot;./components/TodoItem&quot;;import &#123; redirect &#125; from &quot;next/navigation&quot;;const getTodos = () =&gt; prisma.todo.findMany();// &quot;use server&quot; field might be the nextjs way to handle the server side logic.const toggleItem = async (id: string, complete: boolean) =&gt; &#123; &quot;use server&quot;; await prisma.todo.update(&#123; where: &#123; id, &#125;, data: &#123; complete, &#125;, &#125;);&#125;;const deleteItem = async (id: string) =&gt; &#123; &quot;use server&quot;; await prisma.todo.delete(&#123; where: &#123; id, &#125;, &#125;); // here refresh the page again, we may see that the item deleted. redirect(&quot;/&quot;);&#125;;const Home = async () =&gt; &#123; // fetching the data from the db: const todos = await getTodos(); return ( &lt;&gt; &lt;header className=&quot;flex justify-between items-center mb-4&quot;&gt; &lt;h1 className=&quot;text-2xl&quot;&gt;Todo List&lt;/h1&gt; &lt;Link href=&quot;/new&quot; className=&quot;border border-slate-300 text-slate-300 px-2 py-1 rounded hover:bg-slate-700 focus-within:bg-slate-700 ouline-none&quot; &gt; New &lt;/Link&gt; &lt;/header&gt; &lt;ul className=&quot;pl-4&quot;&gt; &#123;todos.map((&#123; id, complete, title &#125;) =&gt; ( &lt;TodoItem key=&#123;id&#125; id=&#123;id&#125; title=&#123;title&#125; complete=&#123;complete&#125; toggleItem=&#123;toggleItem&#125; deleteItem=&#123;deleteItem&#125; /&gt; ))&#125; &lt;/ul&gt; &lt;/&gt; );&#125;;export default Home; nextjs rounteras above code, we may see that nextjs provide the Link component to handle the rounter logic: when we clik the Link, just like the &lt;a/&gt; label, just to the new page: 123import Link from &quot;next/link&quot;;&lt;Link href=&quot;/new&quot;&gt;New&lt;/Link&gt;; we may code the filesrc/new/page.tsx file: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import &#123; redirect &#125; from &quot;next/navigation&quot;;import Link from &quot;next/link&quot;;import &#123; prisma &#125; from &quot;@/db&quot;;const createTodo = async (data: FormData) =&gt; &#123; &quot;use server&quot;; const title = data.get(&quot;title&quot;)?.valueOf(); if (typeof title !== &quot;string&quot; || title.length === 0) throw new Error(&quot;Invalid title&quot;); await prisma?.todo.create(&#123; data: &#123; title, complete: false, &#125;, &#125;); redirect(&quot;/&quot;);&#125;;const Page = () =&gt; &#123; return ( &lt;&gt; &lt;header className=&quot;flex justify-between items-center mb-4&quot;&gt; &lt;h1 className=&quot;text-2xl&quot;&gt;New&lt;/h1&gt; &lt;/header&gt; &lt;form action=&#123;createTodo&#125; className=&quot;flex gap-2 flex-col&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;title&quot; className=&quot;border border-slate-300 bg-transparent rounded px-2 py-1 outline-none focus-within:border-slate-100&quot; /&gt; &lt;div className=&quot;flex gap-1 justify-end&quot;&gt; &lt;Link href=&quot;..&quot; className=&quot;border border-slate-300 text-slate-300 px-2 py-1 rounded hover:bg-slate-700 focus-within:bg-slate-700 ouline-none&quot; &gt; Cancel &lt;/Link&gt; &lt;button type=&quot;submit&quot; className=&quot;border border-slate-300 text-slate-300 px-2 py-1 rounded hover:bg-slate-700 focus-within:bg-slate-700 ouline-none&quot; &gt; Create &lt;/button&gt; &lt;/div&gt; &lt;/form&gt; &lt;/&gt; );&#125;;export default Page; TodoItem componentfor the TodoItem component, we may update the src/components/TodoItem.tsx file: 1234567891011121314151617181920212223242526272829303132333435363738394041&quot;use client&quot;;// TodoItem function is the server side function, so we must mark &quot;use client&quot; field for this componenttype TodoItemProps = &#123; id: string, title: string, complete: boolean, toggleItem: (id: string, complete: boolean) =&gt; void, deleteItem: (id: string) =&gt; void,&#125;;const TodoItem = (&#123; id, title, complete, toggleItem, deleteItem,&#125;: TodoItemProps) =&gt; &#123; return ( &lt;li className=&quot;flex gap-1 items-center&quot;&gt; &#123;/* here using the call back function toggleItem to pass the id and value: */&#125; &lt;input id=&#123;id&#125; type=&quot;checkbox&quot; className=&quot;cursor-pointer peer&quot; defaultChecked=&#123;complete&#125; onChange=&#123;(e) =&gt; toggleItem(id, e.target.checked)&#125; /&gt; &lt;label htmlFor=&#123;id&#125; className=&quot;peer-checked:line-through&quot;&gt; &#123;title&#125; &lt;/label&gt; &lt;div className=&quot;cursor-pointer rounded-full&quot; onClick=&#123;() =&gt; deleteItem(id)&#125; &gt; ❌ &lt;/div&gt; &lt;/li&gt; );&#125;;export default TodoItem;","tags":["nextjs","prisma","sqlite"]},{"title":"创建并发布的npm ui库(npm packages)","path":"/2024/02/17/【2024-02-17】创建自己的npm package步骤/","content":"这里分别介绍两种方法创建自己的 npm package，分别是最流行的两个框架 vite 和 react。 用 vite 创建 npm 库首先，确保你已经安装了 vite , vite 5+ 的版本直接用以下命令就可以创建一个项目： 1npm init vite VueButtonYy 运行后会在命令行里选择一个模板，选择 vue 即可。 创建一个 vue 的组件：创建文件夹项目创建完成后，我们将原来的 src 文件夹删除，然后新建一个 src 文件夹，然后在 src 文件夹下新建一个 index.js 文件和一个 components 文件夹，文件夹目录结构如下： 1234/src |__index.js |__/components |__VueButtonYy.vue 创建组件其中 VueButtonYy.vue 文件就是一个简单的 vue 组件。我这里随便写了一个 button 组件，代码如下： 1234567891011121314&lt;template&gt; &lt;button class&#x3D;&quot;vue-button-yy&quot;&gt; &lt;slot &#x2F;&gt; &lt;&#x2F;button&gt;&lt;&#x2F;template&gt;&lt;style scoped&gt;.vue-button-yy &#123; background: #43b883; color: white; outline: none; border: none;&#125;&lt;&#x2F;style&gt; 编写 vite 配置文件vite 的功能强大，可以通过配置文件 vite.config.js 来实现一些功能，比如打包成一个 npm package。这里我用 vite.config.js，配置文件 vite.config.js 代码如下： 123456789101112131415161718192021import &#123; defineConfig &#125; from &quot;vite&quot;;import vue from &quot;@vitejs/plugin-vue&quot;;import &#123; resolve &#125; from &quot;path&quot;;export default defineConfig(&#123; build: &#123; lib: &#123; entry: resolve(__dirname, &quot;src/index.js&quot;), name: &quot;VueButtonYy&quot;, // 输出文件的格式名：rollup是用 umd和es进行区分的： fileName: (format) =&gt; `vue-button-yy.$&#123;format&#125;.js`, &#125;, rollupOptions: &#123; external: [&quot;vue&quot;], globals: &#123; vue: &quot;Vue&quot;, &#125;, &#125;, &#125;, plugins: [vue()],&#125;); 这里需要注意 fileName 参数，用来指定输出文件的格式名，这里我用的是 vue-button-yy.$&#123;format&#125;.js，这样打包出来的文件名就是 vue-button-yy.cjs.js 和 vue-button-yy.esm.js。 vite 是用 rollup 打包的，所以需要配置 rollupOptions，配置 rollupOptions 的 external 参数，将 vue 的包名 vue 添加到 external 中，这样打包的时候，vue 的包不会打包进去，出来的文件会更小。 编写入口文件 index.js12345678910111213import VueButtonYy from &quot;./components/VueButtonYy.vue&quot;;// 具名导出：export &#123; VueButtonYy &#125;;// 默认导出：export default &#123; install: (app) =&gt; &#123; app.component(&quot;VueButtonYy&quot;, VueButtonYy); // 如有多个插件： // app.component(&#x27;Xxxx&#x27;, xxxx); &#125;,&#125;; 编写 package.json 文件1234567891011121314151617181920212223242526&#123; &quot;name&quot;: &quot;vue-button-yy&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;files&quot;: [&quot;dist&quot;], &quot;main&quot;: &quot;./dist/vue-button-yy.umd.js&quot;, &quot;module&quot;: &quot;./dist/vue-button-yy.es.js&quot;, &quot;exports&quot;: &#123; &quot;.&quot;: &#123; &quot;import&quot;: &quot;./dist/vue-button-yy.es.js&quot;, &quot;require&quot;: &quot;./dist/vue-button-yy.umd.js&quot; &#125;, &quot;./dist/style.css&quot;: &quot;./dist/style.css&quot; &#125;, &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;vite&quot;, &quot;build&quot;: &quot;vite build&quot;, &quot;preview&quot;: &quot;vite preview&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;vue&quot;: &quot;^3.4.15&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;@vitejs/plugin-vue&quot;: &quot;^5.0.3&quot;, &quot;vite&quot;: &quot;^5.1.0&quot; &#125;&#125; name: 这里我用的是 vue-button-yy，这个就是你创建的 npm 包的名称，这个名称在 npm 上不能重复，所以要自己取一个。 version: 这里我用的是 1.0.0，这个就是你创建的 npm 包的版本号，每次发布一个版本，都需要在这里修改版本号，然后在命令行里输入 npm publish，发布一个新版本。 files: 这里我用的是 dist，这个就是打包后的文件夹名称，打包后的文件会放在 dist 文件夹下。 main: 这里我用的是 ./dist/vue-button-yy.umd.js，这个就是打包后的入口文件，打包后的入口文件会放在 dist 文件夹下。vite 用的是 rollup.js 打包，rollup 默认的格式为 umd (require 导入) 和 es （import 导入） 两种文件名格式，写在 packge.json 里做一个说明，用的时候会根据 main 和 module 的文件名进行自动选择。 本地测试在一个包编写完成后，我们需要在本地进行测试，在包文件夹的根目录下跑命令 1npm link 生成一个本地全局软链接，再去另外一个 vue 的现成项目里，通过 1npm link vue-button-yy 进行引用即可。 比如我在另一个项目里跑了 npm link vue-button-yy，可以看到该项目的 package.json 文件里添加了 vue-button-yy 的依赖如下，这是一种本地引用的方式 123&quot;dependencies&quot;: &#123; &quot;vue-button-yy&quot;: &quot;file:../vueDemoComp&quot;&#125;, 然后在 main.js 里引用了 vue-button-yy 的组件，代码如下： 1234567import VueButtonYy from &quot;vue-button-yy&quot;;import &quot;vue-button-yy/dist/style.css&quot;;const app = createApp(App);app.use(VueButtonYy);app.mount(&quot;#app&quot;); 在 App.vue 里引用了 vue-button-yy 的组件，代码如下： 1234567891011&lt;script setup&gt;&lt;/script&gt;&lt;template&gt; &lt;vue-button-yy&gt; hello world &lt;/vue-button-yy&gt;&lt;/template&gt;&lt;style scoped&gt;&lt;/style&gt; 发布你的 npm 包12npm loginnpm publish --access=public 创建一个 react 的 npm package上面的步骤，已经用了一次 vite 作为打包工具，这里我直接用 rollup 作为打包工具，即 vite的底层打包工具，创建一个 react 的 npm package，步骤如下： 创建项目文件夹安装依赖123456789101112mkdir yuwing-react-ui &amp;&amp; cd yuwing-react-uinpm init -y# 安装 react 及 ts：npm i -D @types/react typescript react# 生成tsconfig.json 文件，配置ts检查规则npx tsc --init# rollup 所需的依赖：npm i -D rollup @rollup/plugin-node-resolve @rollup/plugin-typescript @rollup/plugin-commonjs rollup-plugin-dts tsconfig.json 文件，配置 ts 检查规则，代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&#123; &quot;compilerOptions&quot;: &#123; /* Language and Environment */ &quot;target&quot;: &quot;ESNext&quot;, &quot;jsx&quot;: &quot;react-jsx&quot;, /* Modules */ &quot;module&quot;: &quot;ESNext&quot; /* Specify what module code is generated. */, &quot;moduleResolution&quot;: &quot;Node&quot; /* Specify how TypeScript looks up a file from a given module specifier. */, /* JavaScript Support */ &quot;allowJs&quot;: false /* Allow JavaScript files to be a part of your program. Use the &#x27;checkJS&#x27; option to get errors from these files. */, &quot;maxNodeModuleJsDepth&quot;: 1 /* Specify the maximum folder depth used for checking JavaScript files from &#x27;node_modules&#x27;. Only applicable with &#x27;allowJs&#x27;. */, /* Emit */ &quot;declaration&quot;: true /* Generate .d.ts files from TypeScript and JavaScript files in your project. 将所有写在源码的types文件生成到types文件夹下 */, &quot;emitDeclarationOnly&quot;: true /* Only output d.ts files and not JavaScript files. */, &quot;sourceMap&quot;: true /* Create source map files for emitted JavaScript files. */, &quot;outDir&quot;: &quot;dist&quot; /* Specify an output folder for all emitted files. */, &quot;declarationDir&quot;: &quot;types&quot; /* Specify the output directory for generated declaration files. */, /* Interop Constraints */ &quot;allowSyntheticDefaultImports&quot;: true /* Allow &#x27;import x from y&#x27; when a module doesn&#x27;t have a default export. */, &quot;esModuleInterop&quot;: true /* Emit additional JavaScript to ease support for importing CommonJS modules. This enables &#x27;allowSyntheticDefaultImports&#x27; for type compatibility. */, &quot;forceConsistentCasingInFileNames&quot;: true /* Ensure that casing is correct in imports. */, /* Type Checking */ &quot;strict&quot;: true /* Enable all strict type-checking options. */, &quot;noUnusedLocals&quot;: true /* Enable error reporting when local variables aren&#x27;t read. */, &quot;noUnusedParameters&quot;: true /* Raise an error when a function parameter isn&#x27;t read. */, &quot;noImplicitReturns&quot;: true /* Enable error reporting for codepaths that do not explicitly return in a function. */, &quot;noFallthroughCasesInSwitch&quot;: true /* Enable error reporting for fallthrough cases in switch statements. */, &quot;noUncheckedIndexedAccess&quot;: true /* Add &#x27;undefined&#x27; to a type when accessed using an index. */, &quot;allowUnreachableCode&quot;: true /* Disable error reporting for unreachable code. */, /* Completeness */ &quot;skipLibCheck&quot;: true /* Skip type checking all .d.ts files. */ &#125;&#125; 创建 rollup.config.mjs 文件，配置 rollup 打包规则，代码如下： 12# 这里用 mjs 扩展名，因为我们文件里用到 import 语句，不再用require()touch rollup.config.mjs 1234567891011121314151617181920212223242526272829303132333435363738394041import commonjs from &quot;@rollup/plugin-commonjs&quot;;import resolve from &quot;@rollup/plugin-node-resolve&quot;;import typescript from &quot;@rollup/plugin-typescript&quot;;import dts from &quot;rollup-plugin-dts&quot;;import packageJson from &quot;./package.json&quot; assert &#123; type: &quot;json&quot; &#125;;export default [ &#123; input: &quot;src/index.ts&quot;, output: [ &#123; file: packageJson.main, format: &quot;cjs&quot;, sourcemap: true, &#125;, &#123; file: packageJson.module, format: &quot;esm&quot;, sourcemap: true, &#125;, ], external: [&quot;@types/node&quot;], plugins: [ resolve(), commonjs(), typescript(&#123; tsconfig: &quot;./tsconfig.json&quot;, &#125;), ], &#125;, &#123; input: &quot;dist/esm/types/index.d.ts&quot;, output: [ &#123; file: &quot;dist/index.d.ts&quot;, format: &quot;esm&quot;, &#125;, ], plugins: [dts()], &#125;,]; package.json 文件，配置打包规则，代码如下： 123456789101112131415161718192021222324252627&#123; &quot;name&quot;: &quot;@yuwing/react-ui&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;simple react compoent library&quot;, &quot;main&quot;: &quot;dist/cjs/index.js&quot;, &quot;module&quot;: &quot;dist/esm/index.js&quot;, &quot;type&quot;: &quot;module&quot;, &quot;types&quot;: &quot;dist/index.d.ts&quot;, &quot;files&quot;: [&quot;dist&quot;], &quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;rollup -c --watch&quot;, &quot;build&quot;: &quot;rollup -c&quot; &#125;, &quot;keywords&quot;: [&quot;react&quot;, &quot;react-ui&quot;, &quot;react-component&quot;], &quot;author&quot;: &quot;Yu Yi (Kyle Yu)&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;devDependencies&quot;: &#123; &quot;@rollup/plugin-commonjs&quot;: &quot;^25.0.7&quot;, &quot;@rollup/plugin-node-resolve&quot;: &quot;^15.2.3&quot;, &quot;@rollup/plugin-typescript&quot;: &quot;^11.1.6&quot;, &quot;@types/react&quot;: &quot;^18.2.58&quot;, &quot;react&quot;: &quot;^18.2.0&quot;, &quot;rollup&quot;: &quot;^4.12.0&quot;, &quot;rollup-plugin-dts&quot;: &quot;^6.1.0&quot;, &quot;typescript&quot;: &quot;^5.3.3&quot; &#125;&#125; 发布自己的包这一步和上面的 vue 发布一样，不过多说，这里就不写了。 值得注意，package.json 文件中可以加入 &quot;repository&quot; 字段，用来配置发布包的配置，可以在上传到 GitHub 后，直接发布到 npm 仓库： 123&#123; &quot;repository&quot;: &quot;https://github.com/ys558/yuwing-react-ui.git&quot;&#125; 我们可以在 GitHub 上配置，然后将 package 的压缩文件发布在 GitHub 上，必须先去 GitHub 上创建一个 token点击右上角的头像，选择 Settings -&gt; Developer Settings -&gt; Personal access tokens -&gt; Generate new token (classic) -&gt; Select scopes -&gt; repo -&gt; Generate token -&gt; Copy the token -&gt; 把生成的 token 粘贴到你的.npmrc 文件里，默认文件路径是 ~/.npmrc，并添加以下字段： 123registry=https://registry.npmjs.org/@YOUR_GITHUB_USERNAME:registry=https://npm.pkg.github.com///npm.pkg.github.com/:_authToken=&lt;YOUR_GITHUB_TOKEN&gt; 至此，我们 react 组件库的基本流程已完成。","tags":["react","npm","vite","rollup","storybook","npm packag"]},{"title":"TS几个罕见特性的应用","path":"/2023/12/16/【2023-12-16】TS几个罕见特性的应用/","content":"本文列举了 ts 的几种不常见用法，分别是： 函数重载 接口继承 类的内容 属性关键字 存储器 getter setter extends vs implements 泛型类 函数重载 ( Function Overloading )这种其实可以用可选参数 + 或者类型替代，但如果把所有函数返回类型都列出，会清晰点： 1234567891011121314151617181920212223242526272829303132// Overloading:interface Circle &#123; radius: number;&#125;interface Rectangle &#123; width: number; height: number;&#125;// 这里定义不同的函数入参及返回类型function calculateArea(shape: Circle): number;function calculateArea(shape: Rectangle): number;function calculateArea(shape: any) &#123;\tif ((&lt;Circle&gt;shape).radius !== undefined) &#123; return Math.PI * (&lt;Circle&gt;shape).radius ** 2;\t&#125; else if ( (&lt;Rectangle&gt;shape).width !== undefined &amp;&amp; (&lt;Rectangle&gt;shape).height !== undefined\t) &#123; return (&lt;Rectangle&gt;shape).width * (&lt;Rectangle&gt;shape).height;\t&#125; else &#123; throw new Error(&#x27;Unsupported shape type&#x27;);\t&#125;&#125;const circleArea = calculateArea(&#123; radius: 5 &#125;);console.log(circleArea); // Output: 78.53981633974483const rectangleArea = calculateArea(&#123; width: 10, height: 5 &#125;);console.log(rectangleArea); // Output: 50 接口继承 ( Interface Extend )12345678910111213141516171819interface Parent1 &#123; p1: string; p2: number;&#125;interface Parent2 &#123; p3: boolean;&#125;interface Child extends Parent1, Parent2 &#123; p4: string | number;&#125;const o: Child = &#123; p1: &quot;&quot;, p2: 0, p3: false, p4: &quot;&quot;,&#125;; 类 （ Class ）定义属性在ts里，所有属性需要在 constructor 之前规定其属性，如以下示例： 1234567891011121314151617class Article &#123; // 规定属性类型： title: string; content: string; // 这里有属性 a， 如果在.tsconfig里，设置了&quot;strict&quot;: true, 那么不设置 a 为可选属性则会报错。 a?: string; // tsconfig严格模式下，没有初始化的属性，必须设置属性为可选或给定默认值： b = &#x27;&#x27;; constructor(title: string, content: string) &#123; this.title = title; this.content = content; &#125;&#125;const a = new Article(&#x27;题目&#x27;, &#x27;内容&#x27;); public，private, protected, static, readonly 关键字1234567891011121314151617181920class Artical &#123; public title?: string; // private 只能在 当前类内部 进行访问 private content?: string; // protected 只能在 当前类内部 或 其子类内部 进行访问： protected innerData?: string; // static 设置给类本身，而不是设置给类实例，访问时应该： // Artical.author static author: string = &#x27;Jone&#x27;; // 只读属性, 不能被修改： readonly version?: string; // 多个修饰符连用： protected static readonly c: string = &#x27;&#x27; constructor(title: string, content: string) &#123; this.title = title; this.content = content; &#125;&#125; getter setter 和私有值 私有属性，不想被外部访问，命名一般用下划线区分 一般一个私有值，对应一个 getter, setter 存储器 1234567891011121314151617class User &#123; private _password: string = &#x27;&#x27;; get password(): string &#123; return &#x27;*&#x27; &#125; set password(newPassword: string) &#123; this._password = newPassword &#125;&#125;const u = new User();// 直接访问存储器getter： ⭕️console.log(u.password);// ❌：// console.log(u._password); 抽象类 abstract vs 实现接口implements interface abstract 用于给子类继承用，不单独做实例化 implements 和 abstract 的区别是，implements 可以实现多个接口 interface, 而 extends 只能继承一个抽象类 123456789101112131415161718192021222324252627282930abstract class Animal &#123; abstract name: string; abstract voice(): void;&#125;// 只能 extends 一个父类：class Cat extends Animal &#123; name: string = &#x27;Cat&#x27;; voice(): void &#123; console.log(&#x27;miao&#x27;) &#125;&#125;const c1 = new Cat();interface AnimalName &#123; name: string;&#125;interface AnimalVoice &#123; voice(): void;&#125;class Dog implements AnimalName, AnimalVoice &#123; name: string = &#x27;Dog&#x27;; voice() &#123; console.log(&#x27;wang&#x27;) &#125;&#125;const d1 = new Dog(); 当然，他们还能同时使用，但 extends 必须用在 implements 之前： 123456class Dog extends Animal implements AnimalName, AnimalVoice &#123; name: string = &#x27;Dog&#x27;; voice() &#123; console.log(&#x27;wang&#x27;) &#125;&#125; 泛型类泛型除了应用在函数，还可以放在类里应用： 12345678910111213141516class TestGenric&lt;T&gt; &#123; value: T; constructor(value: T) &#123; this.value = value; &#125; processValue (input: T): T &#123; return input &#125;&#125;const s = new TestGenric&lt;string&gt;(&#x27;string&#x27;);s.processValue(&#x27;string&#x27;);const n = new TestGenric&lt;number&gt;(123);n.processValue(123);","tags":["ts"]},{"title":"bun之初尝试","path":"/2023/12/09/【2023-12-09】Bun的初尝试/","content":"本篇是 Bun 1.0 推出后的初尝试。Bun 是一个集合所有 js 基础工具的运行时，以迄今为止最快的 js 运行时而著称 像 Node 一样，Bun是一个运行时(runtime), 而非什么新的语言。感觉 deno 的地位有点尴尬了。大家被他的宣传的速度所折服。 安装官网推荐的是运行 1curl -fsSL https://bun.sh/install | bash 但鉴于国内有墙的原因，bun 现在有 npm 包了，所以我更推荐另一种安装方法，更快更直接： 1npm i -g bun 用以下命令检查是否安装成功： 12(base) ➜ ~ bun -v1.0.12 启用项目初始化：123mkdir bun-learncd bun-learnbun init 可以看到 package.json 文件被 bun.lockb 文件替代，比起原来的 json 文件，这个文件写起来有点类似yml的语法，用了缩进和换行，不用花括号 直接生成了 tsconfig.json 文件, bun 原生支持了 ts 跑单个文件，和 node 用法类似，当然run可以省略： 1bun run index.ts 简单的服务我们在 index.ts 里写上： 12345678const server = Bun.serve(&#123; port: 5678, fetch(req) &#123; return new Response(&quot;hello Bun!&quot;); &#125;,&#125;);console.log(`listening on port $&#123;server.port&#125;`); 终端跑 index.ts , 浏览器可以看到 hello Bun! 的字样。当然，直接跑的话我们改 index.ts 要重启项目，可以加上 --watch 参数： 1bun --watch index.ts 进一步优化，创建一个 env 文件touch .env，将配置写在该文件里， 1PORT &#x3D; 8889 index.ts 文件里 port 参数改： 12--- port: 5678,+++ port: Bun.env.PORT || 5678, 可以见到，以前用node时，我们须安装 process 包，并且引入，才能用 process.env.PORT的，现在直接用Bun，课件Bun 把很多第三方库，如 process 也集成了, 无需二次下载。 处理路由把 fecth 函数改写如下： 123456fetch (req) &#123; const url = new URL(req.url); const &#123; pathname &#125; = url; if (pathname === &#x27;/&#x27;) return new Response(&#x27;home page!&#x27;) if (pathname === &#x27;/blog&#x27;) return new Response(&#x27;blog!&#x27;) return new Response(&quot;404&quot;)&#125; bunx类似 npx 的使用，直接运行二进制码，无须下载安装包，他自带了个 cowsay命令，可以体验 bunx的用法，命令行运行 bunx cowsay Hell Bun 123456789(base) ➜ bun-learn bunx cowsay Hello Bun ___________&lt; Hello Bun &gt; ----------- \\ ^__^ \\ (oo)\\_______ (__)\\ )\\/\\ ||----w | || || 前端脚手架react 官方脚手架，在 Bun 中使用如下： 123bun create react-app &lt;yourAppName&gt;# orbunx create-react-app &lt;yourAppName&gt; vite 的脚手架： 123bun create vite &lt;yourAppName&gt; --template vue# orbunx create-vite &lt;yourAppName&gt; --template vue 模块化引入bun 直接支持 es module 和 commonjs 两种模块引入，也不用在 package.json 里做出其他配置，解决了困扰了 node 多年的模块引入问题。 下面是一个简单的 demo，新建一个文件 module.ts 1touch module.ts 以下我们用 path 模块举例： 1234567import path from &quot;path&quot;;// const path = require(&#x27;path&#x27;); // commonjs also okconst filepath = path.join(&quot;foo&quot;, &quot;bar&quot;, &quot;img.png&quot;);const filename = path.basename(filepath);console.log(filename); 跑了后控制台可看到： 12(base) ➜ bun-learn bun module.tsimg.png 一些常用模块在 Bun 中的使用file 模块Bun.write() 写入文件：1touch file-demo.ts 写下： 12const data = &quot;I love Bun!&quot;;await Bun.write(&quot;file-demo.txt&quot;, data); 从以上代码可以看出，Bun 和 deno 一样，支持顶层的 await语法，无须像 node 一样包装在 async 函数里使用 await Bun.write() 接口可写入文件 跑 bun file-demo.ts 可以看到当前目录下生成了 file-demo.txt 文件，并在文件里写下了 data 的内容。 await Bun.file().text() 读取文件在上面的代码加上： 123const file = Bun.file(&quot;file-demo.txt&quot;);console.log(&quot;file-demo content：&quot;, await file.text()); 控制台输出 12(base) ➜ bun-learn bun file-demo.tsfile-demo content： I love Bun! 这里值得注意，Bun.file().text() 是异步接口，返回的是 Promise 对象，所以必须用上 await 关键字才能显示出内容 其他几个 file 的接口： 123console.log(await file.stream());console.log(await file.arrayBuffer());console.log(&quot;file size:&quot;, file.size); 测试模块bun 集成了 jest 的测试模块，我们在项目里直接创建测试文件： 1touch index.test.ts 1234567891011import &#123; describe, expect, test, beforeAll &#125; from &quot;bun:test&quot;;beforeAll(() =&gt; &#123; console.log(&quot;呵呵&quot;);&#125;);describe(&quot;math&quot;, () =&gt; &#123; test(&quot;addition&quot;, () =&gt; &#123; expect(2 + 1).toBe(3); &#125;);&#125;); 可以看出，所有的 jest 模块都集成在 &quot;bun:test&quot; 原生包里，控制台跑的结果： 1234567891011(base) ➜ bun-learn bun testbun test v1.0.12 (85c99751)index.test.ts:呵呵✓ math &gt; addition [0.19ms] 1 pass 0 fail 1 expect() callsRan 1 tests across 1 files. [11.00ms] bundle 打包我们来试试用 Bun 进行普通的 bundle 打包在项目根目录创建以下文件夹和文件： 123---src |__ githubApi.ts |__ index.ts githubApi.ts文件 前端 js 代码打包，所以暂时不用顶层 await 语法： 12345678import axios from &quot;axios&quot;;const fetchUser = async (user) =&gt; &#123; const res = await axios.get(`https://api.github.com/users/$&#123;user&#125;`); return res.data;&#125;;export default fetchUser; index.ts文件 123456import fetchUser from &quot;./githubApi&quot;;(async () =&gt; &#123; const userData = await fetchUser(&quot;ys558&quot;); document.querySelector(&quot;h1&quot;).innerHTML = JSON.stringify(userData);&#125;)(); 在命令行里运行： 1bun build ./src/index.ts --outfile=./dist/bundle.js 可以看到dist文件夹下生成了 bundle.js 将该文件放入 HTML 的 script 标签里则可使用 如果开发时，可以在 bun build 的命令加上 --watch, 则可以热加载模式 1bun build ./src/index.ts --outfile=./dist/bundle.js --watch react 在项目中的应用在我们原来的项目里添加 react 和 react-dom 1bun i react react-dom src 下创建 index.tsx , 写一个简单的计数器： 1234567891011121314151617import React from &quot;react&quot;;import &#123; createRoot &#125; from &quot;react-dom&quot;;const root = createRoot(document.getElementById(&quot;root&quot;));const App = () =&gt; &#123; const [count, setCount] = React.useState(0); return ( &lt;div&gt; &lt;h1&gt;Count: &#123;count&#125;&lt;/h1&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;() =&gt; setCount(count - 1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt; );&#125;;root.render(&lt;App /&gt;); 在 dist 目录下，创建一个根目录 index.html, 加上一下两行： 12&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;script src=&quot;./bun.js&quot;&gt;&lt;/script&gt; bash 下运行: 1bun build ./src/index.tsx --outfile=./dist/budle.js --watch 打开 index.html 就可以看到该计数器","tags":["bun"]},{"title":"react-18新特性","path":"/2023/10/29/【2023-10-29】react-18新特性/","content":"React 18 新特性 并发模式（Concurrent Mode）：这种新的渲染模式允许在浏览器下一帧空闲时进行更新，允许多个任务同时进行，提高了渲染性能。体现在代码上就是 Suspense 组件的应用： 12345678910111213import React, &#123; Suspense &#125; from &#x27;react&#x27;; const loadingComponent = () =&gt; &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125;; const App = () =&gt; &#123; return ( &lt;Suspense fallback=&#123;loadingComponent()&#125;&gt; &lt;AsyncComponent /&gt; &lt;/Suspense&gt; ); &#125;; 新的更新调度器（Update Scheduler）：这个新的更新调度器可以更细粒度地调度更新，以优化更新优先级和时间分片。 React 18引入了一个新的更新调度器，它可以更细粒度地调度更新。这个新的调度器允许React根据任务的优先级和时间分片来安排更新。这意味着React可以根据应用程序的状态和用户交互来优化更新顺序，从而提供更好的用户体验。 以下是一个示例，演示了如何使用新的更新调度器： 12345678910111213141516171819202122import React, &#123; useState &#125; from &#x27;react&#x27;; const Timer = () =&gt; &#123; const [time, setTime] = useState(Date.now()); const [count, setCount] = useState(0); useEffect(() =&gt; &#123; const timer = setTimeout(() =&gt; &#123; setTime(Date.now()); setCount(0); &#125;, 1000); return () =&gt; clearTimeout(timer); &#125;, []); return ( &lt;div&gt; &lt;p&gt;Current time: &#123;time&#125;&lt;/p&gt; &lt;p&gt;Count: &#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;Increment&lt;/button&gt; &lt;/div&gt; ); &#125;; 在这个示例中，我们使用了useState和useEffect来管理状态和执行副作用。在每一秒钟更新时间戳，并在每次点击按钮时增加计数器的值。由于新的更新调度器的引入，React可以根据优先级和时间分片来安排更新，从而提供更好的用户体验。 新的渲染API：React 18引入了新的渲染API，包括createRoot()函数和Concurrent Mode下的新的渲染函数。支持SSR for Suspense：React 18现在支持服务器端渲染（SSR）和Suspense的集成，以改善首屏加载时间和用户体验。 createRoot api 更新前后对比：用 createRoot 替换 render。这样 12345678910// Beforeimport &#123; render &#125; from &#x27;react-dom&#x27;;const container = document.getElementById(&#x27;app&#x27;);render(&lt;App tab=&quot;home&quot; /&gt;, container);// Afterimport &#123; createRoot &#125; from &#x27;react-dom/client&#x27;;const container = document.getElementById(&#x27;app&#x27;);const root = createRoot(container); // createRoot(container!) if you use TypeScriptroot.render(&lt;App tab=&quot;home&quot; /&gt;); 自动批处理（Automatic Batching）：在React 18中，当setState被调用后，并不会立即触发重新渲染。React会执行全部事件处理函数，然后触发一个单独的re-render，合并所有的更新。这样可以减少程序数据状态存在中间值导致的不稳定性，也可以提高渲染性能。 代码的体现也同样是 Suspence 组件： 1234567891011121314151617181920212223import React, &#123; Suspense &#125; from &#x27;react&#x27;; const loadingComponent = () =&gt; &#123; return &lt;div&gt;Loading...&lt;/div&gt;; &#125;; const App = () =&gt; &#123; return ( &lt;Suspense fallback=&#123;loadingComponent()&#125;&gt; &#123;async () =&gt; &#123; // 在这里执行一些异步操作，例如数据获取等。 const data = await fetchData(); // 假设fetchData是一个异步操作，返回一些数据。 return ( &lt;div&gt; &#123;data.map((item) =&gt; ( &lt;div key=&#123;item.id&#125;&gt;&#123;item.name&#125;&lt;/div&gt; ))&#125; &lt;/div&gt; ); &#125;&#125; &lt;/Suspense&gt; ); &#125;;","tags":["react","react Suspense"]},{"title":"Rust学习笔记（5）—— 枚举 enum","path":"/2023/10/08/【2023-10-08】Rust学习笔记（5）—— 枚举 enum/","content":"本文的参考代码在这里 枚举 enum基本概念枚举为您提供了一种表示某个值是一组可能的值之一的方法。 下面的代码定义了枚举 enum 类型，IpAddrKind v4和v6 绑定枚举值时，须用 :: 绑定 123456789101112131415161718#[derive(Debug)]enum IpAddrKind &#123; v4,\tv6&#125;fn main() &#123;\t// 创建变体实例, 用 :: 绑定值\tlet four = IpAddrKind::v4;\tlet six = IpAddrKind::v6;\troute(four); // ip_kind -&gt; v4\troute(six); // ip_kind -&gt; v6&#125;fn route(ip_kind: IpAddrKind) &#123;\tprintln!(&quot;ip_kind -&gt; &#123;:?&#125;&quot;, ip_kind); &#125; 我们创建一个上一节提到的 struct 结构体，对ip的实际地址用字符串进行存储： 123456789101112131415161718192021222324252627282930#[derive(Debug)]enum IpAddrKind &#123; v4,\tv6&#125;#[derive(Debug)]struct IpAddr &#123;\tkind: IpAddrKind,\taddress: String&#125;fn main() &#123;\tlet home = IpAddr &#123; kind: IpAddrKind::v4, address: String::from(&quot;127.0.0.1&quot;),\t&#125;;\tlet loopback = IpAddr &#123; kind: IpAddrKind::v6, address: String::from(&quot;::1&quot;),\t&#125;;\troute(home); // ip_kind -&gt; IpAddr &#123; kind: v4, address: &quot;127.0.0.1&quot; &#125;\troute(loopback); // ip_kind -&gt; IpAddr &#123; kind: v6, address: &quot;::1&quot; &#125;&#125;fn route(ip_kind: IpAddr) &#123;\tprintln!(&quot;ip_kind -&gt; &#123;:?&#125;&quot;, ip_kind);&#125; enum 可独自定义每个成员的数据类型但上面的代码可以让 enum 直接存储类型为 String, 省去更多代码，可以改写如下： 12345678910111213#[derive(Debug)]enum IpAddrKind &#123; v4(String),\tv6(String)&#125;fn main() &#123;\tlet home = IpAddrKind::v4(String::from(&quot;127.0.0.1&quot;));\tlet loopback = IpAddrKind::v6(String::from(&quot;::1&quot;));\tprintln!(&quot;home &#123;:?&#125;&quot;, home); // home v4(&quot;127.0.0.1&quot;)\tprintln!(&quot;loopback &#123;:?&#125;&quot;, loopback); // loopback v6(&quot;::1&quot;)&#125; 甚至可以再细化, 做到结构体无法完成的任务，例如ipv4一般是4个8 bit的 数值，定义类型时可和ipv6区分开来： 12345678910111213#[derive(Debug)]enum IpAddrKind &#123; v4(u8, u8, u8, u8),\tv6(String)&#125;fn main() &#123;\tlet home = IpAddrKind::v4(String::from(127, 0, 0, 1));\tlet loopback = IpAddrKind::v6(String::from(&quot;::1&quot;));\tprintln!(&quot;home &#123;:?&#125;&quot;, home); // home v4(&quot;127.0.0.1&quot;)\tprintln!(&quot;loopback &#123;:?&#125;&quot;, loopback); // loopback v6(&quot;::1&quot;)&#125; 其实我们在标准库里，可以看到一个专门定义ip的结构体，可以用来这样表达enum： 123456789101112struct Ipv4Addr &#123;\t// --snip--&#125;struct Ipv6Addr &#123;\t// --snip--&#125;enum IpAddr &#123;\tV4(Ipv4Addr),\tV6(Ipv6Addr),&#125; rust 里没有 null 值概念，null 的问题在于，如果您尝试将空值用作非空值，则会收到某种错误。所以用 None代替，即无值。他在标准库的定义如下： 1234enum Option&lt;T&gt; &#123; None, Some(T),&#125;","tags":["rust","enum"]},{"title":"Rust学习笔记（4）—— 结构体 struct","path":"/2023/10/02/【2023-10-02】Rust学习笔记（4）—— 结构体 struct/","content":"本文的参考代码在这里 定义及实例化结构 Structstruct 关键字，中文可以理解为结构体, 是一种自定义数据类型。 123456789101112131415struct User &#123; username: String, active: bool, email: String, sign_in_count: u64&#125;fn main() &#123; let mut user1 = User &#123; username: String::from(&quot;user1&quot;), email: String::from(&quot;user1@mail.com&quot;), active: true, sign_in_count: 1 &#125;;&#125; 改变实例中的值，可以直接用点 . 进行访问及赋值，如： 123456let name = user1.username;user1.username = String::from(&quot;John123&quot;);println!( &quot;username before: &#123;&#125;, username after: &#123;&#125;&quot;, name, user1.username); // username before: user1, username after: John123 Field Init 简写用函数生成实例：封装一个函数用于生成 User 对象，再生成一个 user2的实例 当生成 user3 时，如果其他属性不想列出，可以直接用 .. 的语法拿取 user2 中的参数直接使用： 1234567891011121314151617181920212223fn main() &#123; let user2 = build_user( String::from(&quot;kyle@mail.com&quot;), String::from(&quot;kyle123&quot;) ); println!(&quot;user2.username =&gt; &#123;&#125;, user3.email after =&gt; &#123;&#125;&quot;, user2.username, user2.email); // user2.username =&gt; kyle123, user3.email after =&gt; kyle@mail.com let user3 = User &#123; email: String::from(&quot;james@mail.com&quot;), username: String::from(&quot;james234&quot;), ..user2 &#125;; println!(&quot;user3.username &#123;&#125;, user3.email &#123;&#125;&quot;, user3.username, user3.email); // user3.username james234, user3.email james@mail.com&#125;fn build_user(email: String, username: String) -&gt; User &#123; User &#123; email, username, active: true, sign_in_count: 1 &#125;&#125; tuple struct 使用元组结构创建不同类型123// tuple structstruct Color(i32, i32, i32);struct Point(i32, i32, i32); 以下的代码是一个普通的计算长方形面积的函数： 12345678910fn main() &#123; let width1 = 30; let height1 = 50; println!(&quot;area of the reactangle is &#123;&#125;&quot;, area(width1, height1)); // area of the reactangle is 1500&#125;fn area(width: u32, height: u32) -&gt; u32 &#123; width * height&#125; 将其传参改为元组，则可以改写成： 12345678fn main() &#123; let rect = (30, 50); println!(&quot;area of the reactangle is &#123;&#125;&quot;, area_by_tuple(rect)); // area of the reactangle is 1500&#125;fn area_by_tuple(dimensions: (u32, u32)) -&gt; u32 &#123; dimensions.0 * dimensions.1&#125; 将元组的部分提炼成 struct, 改写成： 1234567891011121314151617struct Rectangle &#123; width: u32, height: u32&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!(&quot;rect1 &#123;:?&#125;&quot;, rect1); // rect1 Rectangle &#123; width: 30, height: 50 &#125; println!(&quot;the area of the reactangle is &#123;&#125;&quot;, area_by_struct(&amp;rect1)); // the area of the reactangle is 1500&#125;fn area_by_struct(rectangle: &amp;Rectangle) -&gt; u32 &#123; rectangle.width * rectangle.height&#125; tips：在我们定义了 let rect1 后我们是无法直接打印出来的，会报错，这时，我们需要在 struct Rectangle 上加一个修饰符 #[derive(Debug)]，而且打印里的{}也需要加上，才能正确打印出 rect1，如： 123456789101112131415161718#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32&#125;fn main() &#123; let rect1 = Rectangle &#123; width: 30, height: 50 &#125;; println!(&quot;rect1 &#123;:?&#125;&quot;, rect1); // rect1 Rectangle &#123; width: 30, height: 50 &#125; println!(&quot;rect1 &#123;:#?&#125;&quot;, rect1); // rect1 Rectangle &#123; // width: 30, // height: 50, // &#125;&#125; 以上涉及到 trait 特征的概念，我们后面的章节会讲到 方法 Method Syntax定义方法上面的 struct 由于有固定的公式，即width*height 我们可以把他简化为 impl, 将area的计算公式定义在其内部，少写了一个函数 1234567891011121314151617181920212223242526272829303132333435#[derive(Debug)]struct Rectangle &#123; width: u32, height: u32&#125;impl Rectangle &#123; fn area_by_impl(&amp;self) -&gt; u32 &#123; self.width * self.height &#125; fn can_hold(&amp;self, other: &amp;Rectangle) -&gt; bool &#123; self.width &gt; other.width &amp;&amp; self.height &gt; other.height &#125;&#125;fn main() &#123; let rect2 = Rectangle &#123; width: 33, height: 55 &#125;; println!(&quot;the area of the reactangle is &#123;&#125;&quot;, rect2.area_by_impl()); // the area of the reactangle is 1815 let rect3 = Rectangle &#123; width: 22, height: 33 &#125;; let rect4 = Rectangle &#123; width: 66, height: 77 &#125;; println!(&quot;rect2 can hold rect3 &#123;&#125;&quot;, rect2.can_hold(&amp;rect3)); // rect2 can hold rect3 true println!(&quot;rect2 can hold rect4 &#123;&#125;&quot;, rect2.can_hold(&amp;rect4)); // rect2 can hold rect4 false &#125; 关联函数尽管官方文档有很多解释，但简单来说就是 impl 能直接像普通函数一样传入参数，我们来看一个例子 1234567891011121314impl Rectangle &#123; fn square(size: u32) -&gt; Self &#123; Self &#123; width: size, height: size &#125; &#125;&#125;fn main() &#123; let rect5 = Rectangle::square(22); println!(&quot;rect5 &#123;:?&#125;&quot;, rect5); // rect5 Rectangle &#123; width: 22, height: 22 &#125;&#125; 需要注意，关联函数需要用 :: 进行函数传值，而不是点。","tags":["rust","struct"]},{"title":"Rust学习笔记（3）—— 核心概念：所有权","path":"/2023/10/01/【2023-10-01】Rust学习笔记（3）—— 核心概念：所有权/","content":"本文的参考代码在这里 所有权（Ownership）Rust的所有权（Ownership）是一个核心概念，它帮助Rust在没有垃圾回收机制的情况下进行内存管理。在Rust中，每个值都有一个与之关联的变量，这个变量被称为该值的所有者（owner）。 以下是关于Rust所有权的一些关键规则： 一个值在任何时刻只能有一个所有者。 当值的所有者超出其作用域时，该值将被销毁。 这意味着Rust在运行时内存管理方面与许多其他编程语言不同。在某些语言中（如C），开发人员需要显式地分配（allocate）和回收（deallocate）内存。而在其他具有垃圾回收功能的语言（如Java）中，垃圾回收器会在程序运行时不断寻找不再使用的内存。但Rust的所有权系统允许它无需这些额外的机制就能保证内存安全。 垃圾回收器：在其他一些具有垃圾回收机制的语言中，由于垃圾回收器自动管理内存，可能会导致程序运行速度更快但性能表现更加不可预测。此外，大型程序会更大，手动管理内存可能会增加错误处理和管理的成本。然而，Rust没有使用垃圾回收器，因此不会出现这些问题。 内存控制：使用Rust可以更好地控制内存的使用，从而避免内存泄漏或内存溢出等问题。此外，由于没有垃圾回收器，写入时间会更快，但大型程序的大小可能会导致更高的运行时延迟。 所有权模型：Rust拥有所有权模型，这有助于减少内存错误并提高代码的可靠性。然而，这也会导致学习曲线变得更加陡峭，因为需要更多地了解内存管理和内存分配策略。 内存管理：Rust具有更好的内存管理能力，这有助于优化性能。然而，这也会增加错误处理和维护成本。 学习曲线：由于Rust的内存管理和内存控制的复杂性，需要更多的学习和练习才能掌握它们。 所有权代码示例： 123456789101112fn main() &#123; // ------ 所有权规则 -------- // 1. 每个值在Rust中都有一个被称为其所有者的变量。 // 2. 在任何时候，一个值只能有一个所有者。 // 3. 当所有者超出其作用域时，该值将被丢弃（drop）。 &#123; // s 还未被声明。 let s: &amp;str = &quot;hello&quot;; // s 被定义，开始生效 println!(&quot;x value is &#123;&#125;&quot;, x); // 当包含&#x27;s&#x27;的作用域结束时（即大括号 &#x27;&#123;&#125;&#x27; 结束时），&#x27;s&#x27;将不再有效。因为在这个时刻，&#x27;s&#x27;的所有者已经超出了其作用域，所以Rust会安全地删除&#x27;s&#x27;所引用的内存中的数据。 &#125;&#125; 移动（Move）操作的数据交互Rust的移动（Move）概念，类似别的语言里的复制（copy），其原理在引用值复制上有着本质区别，这也是Rust语言独特的地方。 原始值复制这种和其他语言的copy区别不大 1234// 原始值的复制// 将值绑定5到x；然后复制 中的值x并将其绑定到ylet x = 5;let y = x; // copy 引用值复制先看一段rust代码： 12let s1 = String::from(&quot;hello&quot;);let s2 = s1; // 移动（Move），而非浅拷贝（shallow copy） 如果按照其他语言的copy操作 s1被创建后，其指针、长度和容量存在于栈（Stack）中，其值”hello”存在于堆（Heap）中。 s2复制s1，s2创造出一块新的栈（Stack），存储其指针、长度和容量等属性，但共用堆中的”hello” 值。 rust 对以上的操作做了优化，正如前面所说的，当s2被绑定了s1的堆（Heap）引用值后，s1已超出范围（scope），rust认为s1的值不再有效，直接丢弃（drop）了，示例图： 1234let s1 = String::from(&quot;hello&quot;);let s2 = s1;println!(&quot;&#123;&#125;, world!&quot;, s1); // 报错❌ 以上的print会报错如下：因为s1的值已经移动（Move）到s2 12345678910111213141516171819202122$ cargo run Compiling ownership v0.1.0 (file:///projects/ownership)error[E0382]: borrow of moved value: `s1` --&gt; src/main.rs:5:28 |2 | let s1 = String::from(&quot;hello&quot;); | -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait3 | let s2 = s1; | -- value moved here4 |5 | println!(&quot;&#123;&#125;, world!&quot;, s1); | ^^ value borrowed here after move | = note: this error originates in the macro `$crate::format_args_nl` which comes from the expansion of the macro `println` (in Nightly builds, run with -Z macro-backtrace for more info)help: consider cloning the value if the performance cost is acceptable |3 | let s2 = s1.clone(); | ++++++++For more information about this error, try `rustc --explain E0382`.error: could not compile `ownership` due to previous error 按照以上的报错，如果还需要用到s1, rust也保留了copy操作，我们必须用.clone()进行拷贝，代码修改如下： 1234let s1 = String::from(&quot;hello&quot;);--- let s2 = s1;+++ let s2 = s1.clone();println!(&quot;&#123;&#125;&quot;, s1); // hello Move 在函数中的应用1234567891011fn main() &#123; let s3: String = String::from(&quot;xxxxx&quot;);\ttakes_ownership(s3);\t// println!(&quot;s3 &#123;&#125;&quot;, s3); // 报错❌&#125;fn takes_ownership(some_str: String) &#123; println!(&quot;some_str &#123;&#125;&quot;, some_str); // 变量 some_str 的作用域move到这里为止&#125; 上述代码中， 因s3值已经move 到函数takes_ownership(s3);里，其值已经不存在s3上，而跳到了函数里 函数里的 some_str 传进来后，被限制在函数的作用域里后被销毁（drop） 所以 println!(&quot;s3 &#123;&#125;&quot;, s3); 则会报错，因为 s3的值已被销毁在函数 takes_ownership的作用域里 而原始值则没有这个问题： 123456789fn main() &#123;\tlet x = 5;\tmakes_copy(x);\tprintln!(&quot;x -&gt; &#123;&#125;&quot;, x); // x -&gt; 5&#125;fn makes_copy(some_int: i32) &#123;\tprintln!(&quot;some_int &#123;&#125;&quot;, some_int); &#125; 回到引用值的移动（move）的问题，如果要避免move后带来的影响，则须将引用值直接放函数里作为返回值即可，如： 123456789fn main() &#123;\t// 引用值改为可用状态，将引用值放函数里作为返回值即可：\tlet s4 = gives_overship();\tprintln!(&quot;s4 &#123;&#125;&quot;, s4); // s4 hello&#125;fn gives_overship() -&gt; String &#123;\tString::from(&quot;hello&quot;)&#125; 或如下，变量 ss2 传入函数 takes_and_gives_back 后，仍要使用 ss2，则须再写一个函数 takes_and_gives_back 将其值困 12345678910111213fn main() &#123;\tlet ss1 = gives_overship();\tlet ss2 = String::from(&quot;ss2 pass in string&quot;);\tprintln!(&quot;ss1 = &#123;&#125;, takes_and_gives_back = &#123;&#125;&quot;, ss1, takes_and_gives_back(ss2)); // ss1 = hello, ss3 = ss2 pass in string&#125;fn gives_overship() -&gt; String &#123;\tString::from(&quot;hello&quot;)&#125;fn takes_and_gives_back(a_string: String) -&gt; String &#123;\ta_string&#125; &amp; 引用及借用 (References and Borrowing)rust 允许使用 返回元组的解构 例如以下例子，x1传入了函数 calculate_str_length(x1) 里，已经被移动了， 在外面如果要再获取x1，则需返回其原值并将其解构出来，但这样返回值就复杂了，传入的同时还需返回他 12345678910fn main() &#123;\tlet x1 = String::from(&quot;kkkkkk&quot;);\tlet (y, len) = calculate_str_length(x1);\tprintln!(&quot;the length of &#123;&#125; is &#123;&#125;&quot;, y, len);&#125;fn calculate_str_length(s: String) -&gt; (String, usize) &#123;\tlet length = s.len();\t(s, length)&#125; 如果传进的函数的值 x1 要在外面获取，但又不需要将其传回作为返回值，就需要用到引用： 1234567891011fn main() &#123;\tlet str1 = String::from(&quot;uuuuuuuuu&quot;);\tlet length = str_length(&amp;str1);\tprintln!(&quot;the length of &#123;&#125; is &#123;&#125;&quot;, str1, length); // the length of uuuuuuuuu is 9&#125;fn str_length(s: &amp;String) -&gt; usize &#123;\t// s.push_str(&quot;ooops&quot;); // err ❌\tlet length = s.len();\tlength&#125; 上面的代码中，调用str1时，加入了 &amp; 符号，即引用 函数里的引用变量会自行寻找值，而不是获取他的所有权，从而让进入函数的变量，在后续能被继续使用。 同样的，借用的变量 s 则不能进行其他操作，因为仅仅是借用。 可变引用（Mutable References）上面代码解决的办法就是将 str1 定义为可迭代操作 mut，以下是修改后的代码： 1234567891011fn main() &#123;\tlet mut str1 = String::from(&quot;uuuuuuuuu&quot;);\tlet length = str_length(&amp;mut str1);\tprintln!(&quot;the length of &#123;&#125; is &#123;&#125;&quot;, str1, length); // the length of uuuuuuuuuooops is 14&#125;fn str_length(s: &amp;mut String) -&gt; usize &#123;\ts.push_str(&quot;ooops&quot;);\tlet length = s.len();\tlength&#125; 而引用有严格的限制, 例如以下代码： 12345let mut str2 = String::from(&quot;kkkkkkkk&quot;);let r1 = &amp;str2;let r2 = &amp;str2;// let r3: = &amp;mut str2; // 错误 ❌println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2); 上面定义的 r3 会报错，是因为： r3 前定义的 r1 和 r2 已定义为非 mut变量，他们还未被使用 要解决以上报错，则须将其移动到 print 之后即可，因 r1, r2 定义后已被使用过 修改后： 123456let mut str2 = String::from(&quot;kkkkkkkk&quot;);let r1 = &amp;str2;let r2 = &amp;str2;println!(&quot;&#123;&#125;, &#123;&#125;&quot;, r1, r2); let r3 = &amp;mut str2; // 正确 r1, r2定义后已被使用过，out of scopeprintln!(&quot;r3 &#123;&#125;&quot;, r3); // r3 kkkkkkkk 悬空引用（Dangling References）在函数内部，引用值不能作为返回值！这是因为引用值 s 已超出范围, s 值已被丢弃，以下是错误❌代码示范： 1234567fn dangle() -&gt; &amp;String &#123; // dangle returns a reference to a String\tlet s = String::from(&quot;hello&quot;); // s is a new String\t&amp;s // we return a reference to the String, s&#125; // Here, s goes out of scope, and is dropped. Its memory goes away.// Danger! ❌ 字符串切片类型（The Slice Type）Rust 的切片是一种比较特殊的形式，这里我们单独讨论。以下是官方文档对切片所有权的总结： Slices let you reference a contiguous sequence of elements in a collection rather than the whole collection. A slice is a kind of reference, so it does not have ownership. 切片允许您引用集合中连续的元素序列，而不是整个集合。切片是一种引用，因此它没有所有权。 让我们看一个切片的例子， 12345let str3: String = String::from(&quot;hello world&quot;);let hello3: &amp;str = &amp;str3[..5];let world3: &amp;str = &amp;str3[6..];println!(&quot;str3 第一个词 &#123;&#125;&quot;, hello); // str3 第一个词 hello 上面的而切片有着一个特殊的类型 &amp;str, 同样的，定义字符串时，也可将其定义为 &amp;str，就像下面的例子： 1234567let str4: &amp;str = &quot;hello rust&quot;;let hello4: &amp;str = &amp;str4[..5];let rust4: &amp;str = &amp;str4[6..];let hello_rust = &amp;str[..];println!(&quot;str4 第一个词 &#123;&#125;&quot;, hello4); // str4 第一个词 helloprintln!(&quot;str4 第二个词 &#123;&#125;&quot;, rust4); // str4 第二个词 rustprintln!(&quot;整个词 &#123;&#125;&quot;, hello_rust); // 整个词 hello rust 封装寻找第一个词的函数： 12345678910111213141516171819fn main() &#123;\tlet str3: String = String::from(&quot;hello world&quot;);\tlet word = first_word(&amp;str3);\tprintln!(&quot;word -&gt; &#123;&#125;&quot;, word);&#125;fn first_word (s: &amp;str) -&gt; &amp;str &#123;\tlet bytes = s.as_bytes();\tfor (i, &amp;item) in bytes.iter().enumerate() &#123; if item == b&#x27; &#x27; &#123; // 如果该句子有空格，则返回第一个元素 return &amp;s[0..i]; &#125;\t&#125;\t// 如果没有空格则返回整个句子\t&amp;s[..]&#125; 可以看出，我们传入和返回的类型均为 &amp;str","tags":["rust","ownership"]},{"title":"Rust学习笔记（2）—— 编程基础概念, 变量、数据类型、流程控制","path":"/2023/09/30/【2023-09-30】Rust学习笔记（2）—— 编程基础概念, 变量、数据类型、流程控制/","content":"本文的具体代码在这里 编程基础概念在 Rust 中的体现变量 定义变量后，如果赋值后要改变，必须加上 mut 关键字，否则则不能改变其值。同样的，定义了 const 之后的常量，则不能加上 mut 数字较大时，可以用下划线替代千分号分隔数字 12345678// variables and constancelet mut x:i32 = 5;println!(&quot;x value is &#123;&#125;&quot;, x);x = 6;println!(&quot;x value is changed: &#123;&#125;&quot;, x);const COUNT: u32 = 1_000_000;println!(&quot;COUNT value is &#123;&#125;&quot;, COUNT); 变量遮蔽(variable shadowing)，同一个作用域内，允许对同一变量名进行二次定义 这样做的好处是方便，坏处是后期代码量大会使得代码难以维护，所以使用时应谨慎 12345// variable shadowing:let y: u32 = 7;println!(&quot;y value is &#123;&#125;&quot;, y);let y: &amp;str = &quot;eight&quot;;println!(&quot;y value is changed: &#123;&#125;&quot;, y); 数据类型Intergers分为有符号（i）和无符号（u）： Length Signed Unsigned 8-bit i8 u8 16-bit i16 u16 32-bit i32 u32 64-bit i64 u64 128-bit i128 u128 arch isize usize 其取值范围分别是：2的8、16、32、64、128次方 Signed的数由于有负数的取值范围，所以比 Unsigned 取值范围减半 Type Range i8 -128~127 u8 0~255 i16 -32768~32767 u16 0~65535 i32 -2147483648~2147483647 u32 0~4294967295 i64 -9223372036854775808~9223372036854775807 u64 0~18446744073709551615 i128 -170141183460469231731687303715884105728~170141183460469231731687303715884105727 u128 0~340282366920938463463374607431768211455 进制：| Number literals | Example || :–: | :–: || Decimal | 98_222 || Hex | 0xff || Octal | 0o77 || Binary | 0b1111_0000 || Byte (u8 only) | b’A’ | Floating12let x1 = 2.45; // f64println!(&quot;&#123;&#125;&quot;, x1); Boolean12let t = false;println!(&quot;&#123;&#125;&quot;, t); Charactor (字符型)123456let ch = &#x27;z&#x27;;println!(&quot;char z: &#123;&#125;&quot;, ch); // char z: zlet z_char: char = &#x27;ℤ&#x27;; // with explicit type annotationprintln!(&quot;char z: &#123;&#125;&quot;, z_char); // char z: ℤlet heart_eyed_cat = &#x27;😻&#x27;;println!(&quot;heart_eyed_cat: &#123;&#125;&quot;, heart_eyed_cat); // heart_eyed_cat: 😻 tuple （元组）1let tup0 = (11,22); 123456789// 可对元组里的每个元素单独定义：let tup1: (&amp;str, i32, f32) = (&quot;let&#x27;s get Rusty!&quot;, 1_000_000, 0.45);// 解构：let (channel, sub_count, float_num) = tup;println!(&quot;&#123;&#125; &#123;&#125; &#123;&#125;&quot;, channel, sub_count, float_num); // let&#x27;s get Rusty! 1000000 0.45// 索引：let sub_count: i32 = tup.1;println!(&quot;sub_count: &#123;&#125;&quot;, sub_count); Array1234let arr = [1, 2, 3, 4, 5];// 定义类型：[数据类型，数组长度]let arr1: [i32; 5] = [1, 2, 3, 4, 5]; Funtion 定义与调用： 1234567fn main() &#123; my_function(12, 34);&#125;fn my_function (x: i32, y: i32) -&gt; i32 &#123; println!(&quot;my function: &#123;&#125;, y: &#123;&#125;&quot;, x, y);&#125; 函数返回值，可省 return 关键字，且返回的语句或变量无需加 ; 函数如有返回值，则须用 -&gt; 定义返回值类型 12345678fn main() &#123; let result = my_function(12, 34);\tprintln!(&quot;result: &#123;&#125;&quot;, result);&#125;fn my_function (x: i32, y: i32) -&gt; i32 &#123;\tx + y&#125; Control Flowif-else if-else分支的条件无需套括号 ()12345678let number: i32 = 5;if number &lt; 10 &#123; println!(&quot;1 true&quot;);&#125;else if number &lt; 22 &#123; println!(&quot;2 true&quot;);&#125;else&#123; println!(&quot;false&quot;);&#125; if-else 条件可写在一行：12let condition: bool = true;let num:i32 = if condition &#123; 1 &#125; else &#123; 2 &#125;; while12345678let mut n = 3;while n != 0 &#123; println!(&quot;&#123;&#125;!&quot;, n); n -= 1;&#125;// 3!// 2!// 1! loop和while循环有点类似： 12345678910111213loop &#123; println!(&quot;again!&quot;); break&#125;let mut counter = 0;let loop_result = loop &#123; counter += 1; if counter == 10 &#123; break counter; &#125;&#125;; println!(&quot;loop_result: &#123;&#125;&quot;, counter); // loop_result: 10 for1234567let arr_for = [11,22,33,44,55];for item in arr_for.iter() &#123; println!(&quot;the arr value is: &#123;&#125;&quot;, item);&#125;// the arr value is: 11// the arr value is: 22// the arr value is: 33 类似 python 的 range 和 scala的 Range ，在rust里使用.. 表示数值范围： .. 的取值范围包括开始值，不包括终止值：123456for value in 1..4 &#123; println!(&quot;&#123;&#125;!!&quot;, value);&#125;// 1!!// 2!!// 3!!","tags":["rust","cargo"]},{"title":"Rust学习笔记（1）—— 安装、cargo、crate","path":"/2023/09/30/【2023-09-30】Rust学习笔记（1）—— 安装、cargo、crate/","content":"很久没有更新博客了，最近自学 rust, 这里记录一下。本文参考了Rust Book写的 Rust 语言初探安装见文档，十分简单，这里不赘述 hello worldtouch main.rs 创建文件，并写下： 123fn main() &#123; println!(&quot;Hello world&quot;);&#125; rust是需要静态编译的语言，所以先执行 rustc main.rs 编译为二进制码后再执行，可看到控制台打印 hello world: 12345# mac./main# windows.\\main.exe cargo 的使用rustc 只能试用在一些比较简单的程序，复杂的程序需用到rust自带的项目管理工具 cargo，本仓库使用讲的每个章节均用一个项目的方式, 每个项目均能独立跑起, 下面是几个常用命令： 123456789101112131415# 新建项目：cargo new &lt;ProjectName&gt;# 编译构建项目，构建完成的项目会放在 target/debug 目录cd &lt;ProjectName&gt;cargo build # 为发布的编译，须加上 --release，会对编译的代码进行优化，构建完的项目会放在 target/release 目录cargo build --release# 编译构建并运行项目：cargo run# 检查是否能通过编译：效率比 cargo build 快很多cargo check 注释1234// 单行注释/*多行注释*/ 变量123456789101112131415fn main() &#123; let x = 88; // 报错： // x = 99; // 如要使其可变，则应加上 mut 关键字，immutable缩写： let mut y = 99; y = 100; println!(&quot;x is &#123;&#125;, y is &#123;&#125;&quot;, x, y) // 定义一个空字符串, // 中间两个冒号:表明String的关联函数，针对类型本身而实现的，而非针对字符串某特定实例实现的 let mut guess = String::new();&#125; crate 库的使用 rust的库叫 crate, 需要用的lib包可在 crate 官网 里找到。这次我们用随机生成数字的库, 在项目目录里添加： 12345...# 前面的 ^ 表示任何与0.8.4兼容的版本均可以下载[dependencies]rand = &quot;^0.3.23&quot; 添加完成后，返回终端，输入 cargo check 或 cargo build，则可以下载该lib包, 如： 1234567891011ziyouzhiyi@zyzy: ~/Documents/code/rust-learn/test-project main ⚡$ cargo check [11:57:13]Updating crates.io indexDownloaded rand v0.4.6Downloaded rand v0.3.23Downloaded 2 crates (87.7 KB) in 1.38sCompiling libc v0.2.126Checking rand v0.4.6Checking rand v0.3.23Checking test-project v0.1.0 (/Users/ziyouzhiyi/Documents/code/rust-learn/test-project)Finished dev [unoptimized + debuginfo] target(s) in 5.74s Cargo.lock 文件：当第一次安装lib包成功后，会将该包 rand v0.3.23 所依赖包所有lib包版本号放入 Cargo.lock 文件中，以后每次重新构建，均会按照里面列举的版本进行安装，除非自己手动进行 rand v0.8.4 版本升级。 cargo update 命令：如要更新b版本以上的版本，须手动在 toml 文件里重新写上版本号再执行update命令，此时，cargo 会忽略 Cargo.lock 文件直接更新","tags":["rust","cargo"]},{"title":"【2022-05-15】typescript泛型的应用","path":"/2022/05/15/【2022-05-15】typescript泛型的应用/","content":"本文介绍泛型一些基础用法。 泛型数组里泛型的运用如下代码，如果传入的数值为string，则须把number改为any, 但这样一来就失去了类型检查的意义。此时泛型（generics）排上用场 123456const last = (arr: Array&lt;number&gt;) =&gt; &#123; return arr[arr.length - 1]&#125;const l = last([1,2,3,4])const l1 = last([&#x27;1&#x27;, 2]) // 错误 last 函数须改为 123456789101112const last = &lt;T&gt;(arr: Array&lt;T&gt;): T =&gt; &#123; return arr[arr.length - 1]&#125;// orconst last = &lt;T&gt;(arr: T[]): T =&gt; &#123; return arr[arr.length - 1]&#125;// 调用的地方类型检验也可写上，当然不写也行：const l = last([1,2,3,4])const l1 = last&lt;string | number&gt;([&#x27;1&#x27;, 2]) // 错误 当然，也可定义于多个参数 12345678const makeArr = &lt;X, Y&gt;(x: X, y: Y): [X, Y] =&gt; &#123; return [x, y]&#125;const v = makeArr(5, 6)const v1 = makeArr(&#x27;a&#x27;,&#x27;b&#x27;)// 调用时也写上类型，也可省略const v2 = makeArr&lt;string, number&gt;(&#x27;a&#x27;, 5) 以上代码还有骚操作写法： 123456789// 类似es6的默认值写法：Y泛型指定了泛型默认值，const makeArr = &lt;X, Y = number&gt;(x: X, y: Y): [X, Y] =&gt; &#123; return [x, y]&#125;// 调用时的第二个泛型可省略：const v3 = makeArr&lt;string | null&gt;(null, 5)// 当然，和es6的默认值语法一样，虽指定了默认值为number，但要传入string也一样可以，这时则不能再指定类型，否则报错：const v4 = makeArr(null, &#x27;5&#x27;) 对象里泛型的应用如下，指定了{}的两个属性，如果有多个属性一起传入，则会报错： 12345678const fullName = (obj: &#123; firstName: string, lastName: string&#125;) =&gt; &#123; return &#123; ...obj, fullName: obj.firstName + &#x27; &#x27; + obj.lastName &#125;&#125;const v4 = fullName(&#123; firstName: &#x27;bob&#x27;, lastName: &#x27;junior&#x27;, age: 15&#125;) 此时可以用泛型的 extends 关键字，扩展了原有obj，改写如下： 1234567const fullName = &lt;T extends &#123; firstName: string, lastName: string &#125;&gt; (obj: T): T =&gt; &#123; return &#123; ...obj, fullName: obj.firstName + &#x27; &#x27; + obj.lastName &#125;&#125; 接口中泛型的应用如下例子，可在 interface 里直接传入一个泛型 T，定义时利用 type 类型定义传入类型 12345678interface Tab&lt;T&gt; &#123; id: string position: number date: T&#125;type NumberTab = Tab&lt;number&gt;type StringTab = Tab&lt;string&gt;","tags":["type script"]},{"title":"umijs-qiankun微前端实践","path":"/2022/03/27/【2022-03-27】umijs-qiankun微前端实践/","content":"umijs推出的微前端框架qiankun，是国内比较流行的微前端方案，其官方文档有配置的方法，但是说的比较模糊，这里亲自实践一下 创建项目微前端分位主应用和若干个微应用，分别独立运行。所以分别创建以下目录解构： 1234&lt;project root&gt; |__main |__app1 |__app2 根据umijs文档，分别在每个项目里生成对应的umijs项目，并都安装umijs乾坤插件 @umijs/plugin-qiankun 1234npm i yarn tyarn -gtyarn create @umijs/umi-apptyarn add @umijs/plugin-qiankuntyarn 修改.umirc配置这个是文档没说清楚的地方，所有umijs的配置，均要在.umirc里修改，在main项目添加以下配置： 12345678910111213141516171819202122232425262728293031 routes: [ &#123; path: &#x27;/&#x27;, component: &#x27;@/pages/index&#x27;, routes: [ &#123; path: &#x27;/app1&#x27;, microApp: &#x27;app1&#x27;, &#125;, &#123; path: &#x27;/app2&#x27;, microApp: &#x27;app2&#x27;, &#125;, ], &#125;,],qiankun: &#123; master: &#123; // 注册子应用信息 apps: [ &#123; name: &#x27;app1&#x27;, // 唯一 id entry: &#x27;//localhost:7701&#x27;, // html entry &#125;, &#123; name: &#x27;app2&#x27;, // 唯一 id entry: &#x27;//localhost:7702&#x27;, // html entry &#125;, ], &#125;,&#125;, 在 app1 和 app2 的 .umirc 分别写： 123qiankun: &#123; slave: &#123;&#125;,&#125;, 在 app1 和 app2 的 package.json 分别指定app名字，否则qiankun插件认不出来： 12345// app1 package.json &quot;name&quot;: &quot;app1&quot;// app2 package.json &quot;name&quot;: &quot;app2&quot; 这里注意，微服务要跑在不同端口，根据在.env文件中定义，我们可在 main app1 app2 下分别创建 .env 文件并写下端口号，如： 12345678# mainPORT=7700# app1PORT=7701# app2PORT=7702 这样，当每个项目各自跑的时候，就能按要求跑在指定的端口号 子项目配置 app.ts 文件这个是关键一步，每个子项目都要配置对应的子项目生命周期函数，否则报错： 12345678910111213141516171819202122232425262728293031// app1/src/app.tsexport const qiankun = &#123; // 应用加载之前 async bootstrap(props: any) &#123; console.log(&#x27;app1 bootstrap&#x27;, props); &#125;, // 应用 render 之前触发 async mount(props: any) &#123; console.log(&#x27;app1 mount&#x27;, props); &#125;, // 应用卸载之后触发 async unmount(props: any) &#123; console.log(&#x27;app1 unmount&#x27;, props); &#125;,&#125;;// app2/src/app.tsexport const qiankun = &#123; // 应用加载之前 async bootstrap(props: any) &#123; console.log(&#x27;app2 bootstrap&#x27;, props); &#125;, // 应用 render 之前触发 async mount(props: any) &#123; console.log(&#x27;app2 mount&#x27;, props); &#125;, // 应用卸载之后触发 async unmount(props: any) &#123; console.log(&#x27;app2 unmount&#x27;, props); &#125;,&#125;; 更改界面走到这一步, app1 和 app2 均会配置到主应用 main 的props.children里了，我们将主应用界面更改如下： 12345678910111213&#x2F;&#x2F; main&#x2F;src&#x2F;pages&#x2F;index.tsximport styles from &#39;.&#x2F;index.less&#39;;export default function IndexPage(props) &#123; console.log(&#39;props-----&gt;&#39;, props.children.props.children); return ( &lt;div&gt; &lt;h1 className&#x3D;&#123;styles.title&#125;&gt;Main App&lt;&#x2F;h1&gt; &lt;div&gt;&#123;props.children&#125;&lt;&#x2F;div&gt; &lt;&#x2F;div&gt; );&#125; 最终效果如下，通过/app1 可达 app1 应用，/app2可达 app2 应用：","tags":["umijs","qiankun"]},{"title":"用esbuild创建自己的js类库npm包","path":"/2022/03/20/【2022-03-20】用esbuild创建自己的js类库npm包/","content":"很久没有更新, 这次趁着周末有空, 赶紧把工作中碰到的问题进行一次总结. 并记录下来.最近碰到需要创建npm包的需求, 这里把他形成文档记录下来. 前端的变化实在是快, 1年多前仍是babel的天下, 现在杀出个 esbuild , babel用js编写, 而 esbuild用更快的go语音编写, 他俩在webpack中均有对应的插件关于新的打包工具 esbuild, 他支持最原生的es module语法.在我的这篇文章里已有将其配置于CRA热更新的操作, 大家可以做参考.写这篇文章的目的在于结合esbuild官网, 走一遍自己的配置的过程, 顺便把webpack的配置进一下对比. 最基础的webpack及esbuild配置 从最基础的配置开始, yarn init 生成 package.json 文件, 并安装 yarn add esbuild webpack webpack-cli 两个工具. 将包名改为mylib, 加上 script , 配置 &quot;type&quot;: &quot;module&quot;为可以用esm语法 1234567891011121314151617&#123; &quot;name&quot;: &quot;mylib&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;author&quot;: &quot;ys558&quot;, &quot;scripts&quot;: &#123; &quot;wp-build&quot;: &quot;webpack --mode=production&quot;, &quot;es-build&quot;: &quot;esbuild --bundle src/index.js --outfile=dist/myLib.esbuild.bundle.js --minify&quot; &#125;, &quot;devDependencies&quot;: &#123; &quot;esbuild&quot;: &quot;^0.14.27&quot;, &quot;webpack&quot;: &quot;^5.70.0&quot;, &quot;webpack-cli&quot;: &quot;^4.9.2&quot; &#125;, &quot;type&quot;: &quot;module&quot;&#125; 新建 scr/index.js 和 src/moduleA.js, 随便写下一些东西, 用上esm语法: 123// src/moduleA.jsconst moduleA = &#x27;module A&#x27;export default moduleA 1234567891011121314151617181920// src/index.jsimport moduleA from &quot;./moduleA.js&quot;;const valueA = &quot;function A&quot;, valueB = &quot;function B&quot;;export function functionA() &#123; return valueA;&#125;class ClassA &#123; constructor(param)&#123; this.param = param; &#125;&#125;const A = new ClassA(&#x27;a&#x27;);console.log(functionA())console.log(moduleA)console.log(&#x27;param of classA&#x27;, A.param) 分别跑 yarn run wp-build 和 yarn run es-build, 可看到打包出来dist的两个文件, 123dist |__main.js |__myLib.esbuild.bundle.js 无论webpack还是esbuild, 均默认生成dist/main.js . 所以两个命令分别运行, 会覆盖掉原来的dist/main.js文件 myLib.esbuild.bundle.js 文件由我们指定的es script生成的, 而webpack的配置是要写在 webpack.config.js 里去配置. 配置 webpack.config.js 文件如下: 1234567891011121314151617181920// path 和 url 均属于node的内置模块, 均是 commonJS 模块, 所以 这里里不支持直接解构导入: // import &#123; fileURLToPath &#125; from &#x27;url&#x27;; &lt;-- 错误// 只能写成以下形式: 先整体导入再解构:import url from &#x27;url&#x27;;import path from &#x27;path&#x27;;const &#123; fileURLToPath &#125; = urlconst &#123; dirname &#125; = pathconst __filename = fileURLToPath(import.meta.url);const __dirname = dirname(__filename);const webpackConfig = &#123; entry: &#x27;./src/index.js&#x27;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;myLib.webpack.bundle.js&#x27;, &#125;,&#125;;export default webpackConfig 再跑 yarn run wp-build 可发现打包出了两个文件: 123dist |__myLib.webpack.bundle.js |__myLib.esbuild.bundle.js","tags":["esbuild","webpack"]},{"title":"Mono Repo 简介及实现方法","path":"/2021/11/09/【2021-11-09】MonoRepo简介及实现方法/","content":"本文介绍私有仓库包的管理模式 mono repo mono repo的好处mono repo的好处来源于这篇文章，我用自己直白点的话总结了以下几点： 多个内部模块可以集中管理 只需在根目录安装 node_modules 即可，无须所有模块都安装 例如，一个有多端的项目，而且每个端都饮用了共有的模块，我们可以把所有项目或包放到一个packages中集中管理 例如我们平时熟悉的react，babel等库的源码，都是采用mono repo进行仓库管理。 我们需要用到两个库，yarn workspace 和 lerna， 以下的项目示例里，前者用于依赖管理，后者用于处理发布问题，在版本发布这块，使用lerna更方便，可用于替代一部分的git的功能。 当然 lerna 也可以直接替代 yarn workspace 的功能。 yarn workspace 管理依赖123mkdir common servercd common &amp;&amp; yarn init -y &amp;&amp; touch index.jscd ../server/ &amp;&amp; yarn init -y &amp;&amp; touch index.js package.json 配置 workspacespackage.json，将 common, server 两个文件夹视为两个package包 1234&#123; &quot;private&quot;: true, &quot;workspaces&quot;: [ &quot;packages/*&quot; ]&#125; 建一个简单的目录结构如下： 1234567root |__package.json |__packages |__common |__package.json |__server |__package.json 假设在common包里安装react和react-dom，则直接执行： 1yarn workspace common add react react-dom --dev yarn workspace 的具体用法，可以看官方文档 自己写的包要相互引用的方法我们把上面的目录结构 common 包和 server 各自添加index.js，如下： 123456789root |__package.json |__packages |__common |__index.js |__package.json |__server |__index.js |__package.json packages\\common\\index.js 里写点简单的东西： 1module.exports = () =&gt; console.log(&#x27;hello fr common&#x27;) packages\\server\\index.js 12// 这里的 &quot;common&quot; 对应 common\\package.json 里的 &quot;name&quot;，即直接引用common作为依赖包const commonFn = require(&quot;@mono-repo-by-yarn-lerna/common&quot;); common\\package.json 里，社区里的习惯性做法是加上前缀@项目名称/，如： 123456789&#123; &quot;name&quot;: &quot;@mono-repo-by-yarn-lerna/common&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;main&quot;: &quot;index.js&quot;, &quot;license&quot;: &quot;MIT&quot;, &quot;dependencies&quot;: &#123; &quot;@mono-repo-by-yarn-lerna/common&quot;: &quot;1.0.0&quot; &#125;&#125; server\\package.json 运行 yarn install，会看到以下，证明在server文件夹成功安装common文件夹作为依赖 12345678$ yarnyarn install v1.22.10[1/4] Resolving packages...[2/4] Fetching packages...[3/4] Linking dependencies...[4/4] Building fresh packages...success Saved lockfile.Done in 0.16s. 返回根目录运行 ls node_modules/ 可以看到多了 ‘@mono-repo-by-yarn-lerna’ / 为项目的东西 12$ ls node_modules/&#x27;@mono-repo-by-yarn-lerna&#x27;/ 运行 node server/index.js 可以看到运行的结果： 12$ node packages/server/index.js hello fr common 如果此时我们再在 server 文件夹里添加其他模块，例如 babel，运行 yarn add babel， 会发现 server 文件夹里的 node_modules 只放了 babel 的一些执行文件，其余 babel 的核心文件全部被移动到根目录里的 node_modules，以此达到集中管理依赖的目的 Lerna A tool for managing JavaScript projects with multiple packages. Lerna 是希腊神话里一多头怪物，估计作者想他多头处理多个包 在我们上面项目的基础上，根目录添加lerna，yarn add -D -W lerna，-W表示跟在本项目的 workspace 里直接安装，即根目录 npx lerna init packages\\common\\package.json 和 packages\\server\\package.json 均加上test命令 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;echo testing server with version: $npm_package_version&quot;&#125; 12345678&#123; &quot;packages&quot;: [ &quot;packages/*&quot; ], &quot;version&quot;: &quot;0.0.0&quot;, + &quot;npmClient&quot;: &quot;yarn&quot;, + &quot;useWorkspaces&quot;: true&#125; 如果要执行单个 package.json 里的命令，则需加上 --scope=@包名，如 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;lerna run test --scope=@mono-repo-by-yarn-lerna/common&quot;&#125; 如指定多个模块，只需放在&#123;&#125;里，如： 123&quot;scripts&quot;: &#123; &quot;test-since&quot;: &quot;lerna run test --scope=&#123;@mono-repo-by-yarn-lerna/common,@mono-repo-by-yarn-lerna/server&#125;&quot;&#125; lerna version 发布版本接上面，用 new-version 命令进行发版，执行的是 lerna version。后面的参数 convential commits 是一个用于优化 git commit 内容的库，可以添加commits标题正文注脚什么的，挺有趣，vs code 里也有同名的插件 test 脚本加上 --since 参数可以看到提交版本的历史： 123&quot;scripts&quot;: &#123; &quot;test&quot;: &quot;lerna run test --since&quot;&#125;","tags":["mono repo","yarn","lerna","conventional commit"]},{"title":"esbuil用于create-react-app项目的热更新开发","path":"/2021/10/28/【2021-10-28】用esbuil创建React项目/","content":"webpack 用于大型项目中，特别是开发时候的热更新，速度太慢，原因是webpack 采用了整个项目所有文件一起打包的方案。 自从 vite 推出以来，打包这块做到了性能上的超越。vite 的原理是在SPA项目中，基于入口文件打包的，由于只打包一个文件，所以速度就上来了。 而无论是 vite 和 webpack 均是基于 esbuild 开发的。所以研究一下 esbuild 的配置是比较有价值的。 本项目是基于 create-react-app 创建项目，再用 es-build 作为开发热更新打包。 不改动CRA生成的基础结构下的改动用 create-react-app 生成项目后，然后对原来的项目作了如下改动： 生成 devBuild.js 文件，进行如下改动： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import browserSync from &quot;browser-sync&quot;;import chalk from &quot;chalk&quot;;import commandLineArgs from &quot;command-line-args&quot;;import del from &quot;del&quot;;import esbuild from &quot;esbuild&quot;;import getPort from &quot;get-port&quot;;import svgrPlugin from &quot;esbuild-plugin-svgr&quot;;// 创建服务器。const bs = browserSync.create();// 解构环境变量const &#123; dev &#125; = commandLineArgs(&#123; name: &quot;dev&quot;, type: Boolean &#125;);// 删除文件夹 public 中的打包文件夹del.sync(&quot;./public/dist&quot;);// 开始 esbuild 打包(async () =&gt; &#123; const buildResult = await esbuild .build(&#123; format: &quot;esm&quot;, // 设置生成的 JavaScript 文件的输出格式。 target: &quot;es2017&quot;, // 编译转化版本 entryPoints: [&quot;./src/index.jsx&quot;], // 打包入口 outdir: &quot;./public/dist&quot;, // 输出目录 chunkNames: &quot;chunks/[name].[hash]&quot;, // 打包出来的文件名 incremental: dev, // 因为我们监听文件的改变重新打包，而且我们要开发环境使用esbuild 所以 dev 为 true loader: &#123; // 此选项更改给定输入文件的解释方式。 &quot;.svg&quot;: &quot;text&quot;, &quot;.png&quot;: &quot;dataurl&quot;, &#125;, bundle: true, // 捆绑文件意味着将任何导入的依赖项内联到文件本身中。 splitting: true, // 代码拆分目前仅适用于esm输出格式。 plugins: [svgrPlugin()], inject: [&quot;./public/react-shim.js&quot;], // 将 React 作为全局变量导入esbuild &#125;) .catch((err) =&gt; &#123; console.error(chalk.red(err)); process.exit(1); &#125;); console.log(chalk.green(&quot;The build has finished! 📦 &quot;)); // 获取可以使用的端口号 const port = await getPort(&#123; port: getPort.makeRange(4000, 4999), &#125;); console.log( chalk.cyan( `Launching the Shoelace dev server at http://localhost:$&#123;port&#125;! 🥾 ` ) ); // 服务器初始化 bs.init(&#123; startPath: &quot;/&quot;, // 初始路径 port, // 端口号 logLevel: &quot;silent&quot;, // 日志级别 logFileChanges: true, // 日志文件更改 notify: true, // 浏览器中的小弹出通知 single: true, // 提供单独的 index.html server: &#123; baseDir: &quot;public&quot;, // 基础文件夹 index: &quot;index.html&quot;, // 设置服务器的入口文件 &#125;, files: &quot;src/&quot;, // 监听 src 下的文件 &#125;); // 监听 src 文件夹下的更改 bs.watch([&quot;src/&quot;]).on(&quot;change&quot;, async (filename) =&gt; &#123; console.log(`Source file changed - $&#123;filename&#125;`); // 重新打包 buildResult.rebuild(); &#125;);&#125;)(); 依赖安装： 核心: esbuild,esbuild-plugin-svgr用于创建服务渲染打包文件： browser-sync解析命令行参数: command-line-args打包文件删除：del获取当前可用端口：get-port美化：chalk package.json 的 script 增加了 dev 命令，为跑 devBuild.js 文件 package.json 增加了 &#123;&quot;type&quot;: &quot;module&quot;&#125; 让 node 可以编译 esm 语法 将 public/index.html 文件增加如下： 123456...&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;./dist/index.css&quot; /&gt;...&lt;script type=&quot;module&quot;&gt; import &#x27;./dist/index.js&#x27;&lt;/script&gt; 增加 public/react-shim.js 文件，并在 devBuild.js写入相应配置，在src中就不用到处引入React了： 12import * as React from &#x27;react&#x27;export &#123; React &#125; 源码在这里","tags":["React","esbuild","webpack"]},{"title":"Web性能优化（最后更新时间：2021-10-26）","path":"/2021/10/26/【2021-05-30】Web性能优化（持续更新）/","content":"本文根据这篇文章：Best Practices for Speeding Up Your Web Site，被称作”雅虎35条军规”，虽里面有的东西虽说也已经过时，但可以由此窥探前端发展的历程，一些过时的建议会略去解释。 一道面试题引发的前端性能优化思考相信大家都碰过这道经典面试题：在浏览器输入url到看到页面的展示，这中间发生了什么？ 总体答案是这样： 浏览器输入域名（Domain） ——&gt; DNS服务器解析成IP地址 （如：12.220.12.123） 通过局域网 ——&gt; 交换机 ——&gt; 路由器 ——&gt; 主干网 ——&gt; 服务端 建立TCP连接 服务器接收请求，查库，读文件等， 拼接好response，即返回的HTTP响应 浏览器收到首屏html页面，开始渲染 解析 html 为 DOM-tree 解析 CSS 为 CSS-tree DOM-tree + CSS-tree 生成 render-tree 绘图 根据页面节点的改变，样式的改变等，发生重绘与回流 所谓的性能优化，就是上面的步骤加在一起，时间尽可能短，所以在这个过程种3点关键的优化因素： 减少http请求，缩小http请求大小 减少静态文件大小 减少渲染 大概优化点，实际工作种还要结合场景才能做出优化： DNS 通过缓存减少DNS查询时间 网络请求过程走最近的网络环境 相同静态资源是否可缓存 减小http请求大小 减少http请求 服务的渲染 网页性能检测工具首先应明确检测网页所需的工具，这里列举了3种方法： 谷歌推出的性能检测网站web.dev从三个指标对网站性能进行评估 Largest Contentful Paint (LCP) ：最大内容绘制，测量加载性能。为了提供良好的用户体验，LCP 应在页面首次开始加载后的2.5 秒内发生。 First Input Delay (FID) ：首次输入延迟，测量交互性。为了提供良好的用户体验，页面的 FID 应为100 毫秒或更短。 Cumulative Layout Shift (CLS) ：累积布局偏移，测量视觉稳定性。为了提供良好的用户体验，页面的 CLS 应保持在 0.1. 或更少。 该网站可以输入网址后进行测试，给出一份详细的 lighthouse 报告 Navigator.sendBeacon() 埋点传输数据给服务器记录时间依据google以上3原则，可以在前端进行埋点，进行统计 12345678910import &#123; getCLS, getFID, getLCP &#125; from &#x27;web-vitals&#x27;function sendToAnalytics(metric) &#123; const body = JSON.stringify(metric); navigator.sendBeacon(&#x27;/analytics&#x27;, body))&#125;getCLS(sendToAnalytics);getFID(sendToAnalytics);getLCP(sendToAnalytics); window.performance打开任意网页，控制台输入以下代码，可以看到 window.performance 所获取到的东西，我们主要看他的timing属性，用开始时间减去结束时间得出各种资源加载的时间。以下的数值都算是比较粗略的数值 12345678const t = window.performance.timing;console.log(&#123; &quot;DNS&quot;: t.domainLookupEnd - t.domainLookupStart, &quot;TCP&quot;: t.connectEnd - t.connectStart, &quot;获得首字节耗费时间，TTFB&quot;: t.responseStart - t.navigationStart, &quot;domReady时间&quot;: t.domContentLoadedEventStart - t.navigationStart, &quot;DOM资源下载&quot;: t.responseEnd - t.responseStart&#125;) 第一字节响应时间（TTFB）= 从发送请求到WEB服务器的时间 + WEB服务器处理请求并生成响应花费的时间 + WEB服务器生成响应到浏览器花费的时间 第一字节响应时间（TTFB）要考虑的问题：步骤1：从发送请求到WEB服务器的时，即向站点地址提交首次请求 DNS 响应时间（终端用户侧解析 DNS 请求有多块） 网站服务器到终端用户的距离，越短越好 网络稳定性 步骤2：WEB服务器处理请求并生成响应花费的时间，即由 web 服务器解析本次请求 物理硬件响应时间 （web 服务器解析请求有多快） 既有的服务器操作负载 数据中心任何网络相关的延迟 步骤3：WEB服务器生成响应到浏览器花费的时间， 即向客户端发送首个响应的时间 终端用户的网速 连接稳定性 Chrome自带的performance检测工具自动化检测利器—— lighthouse —— 自动生成网页性能报告，并有优化建议符合谷歌的 PWA 标准的检测，关于PWA的概念，点击这里 方法一，直接安装 npm 库 1npm i -g lighthouse 使用起来超级简单 1lighthouse &lt;需要测试的网页链接&gt; 方法二，浏览器也自带 lighthouse 功能，以下是 Edge 浏览器 浏览器的重绘与回流资源合并与压缩：现代化的前端跑不掉资源压缩这一步，平时工程化用的 webpack 就是一款压缩工具 HTML压缩原理：将HTML里的空格，换行符，制表符等去掉 方法： node作为构建工具，提供了 html-minifier 工具，webpack的 HTMLMinifierWebpackPlugin 中内置了该构建工具 后端模板引擎渲染压缩，如ejs模板，express 的 renderFile() CSS压缩原理： 除了像HTML一样删除空格，换行符等之外 删除无效代码 css语义合并 方法： html-minifier 可以对html中的内联css样式进行压缩，需配置其中的选项 clean-css 对 css 的压缩 Webpack 的 CssMinimizerWebpackPlugin JS压缩与混乱原理： 删除无效字符 删除注释 代码语义化的缩减和优化 代码保护 方法： html-minifier 可以对html中的js进行压缩，需配置其中的选项 uglifyjs3 JS文件合并如果不合并请求会有以下影响 但合并请求也不是万能的，其缺点体现在： 首屏渲染的问题现在的前端都用类似react或者vue等前端框架，如果使用vue或者react没有进行服务端渲染的操作，而且服务端合并请求的JS文件又比较大，那么请求回来的JS加载完成后，才会执行react或vue的框架代码在客户端加载渲染，那么首屏白屏的时间就会比较久 缓存失效的问题现在的打包用webpack都会加上md5戳，用于标识单个js文件是否发生改变，如果JS合并了，就会使原先的md5戳失效，就得重新加载 针对合并带来的负面效果，应遵循以下原则： 公共库合并公共库代码比较少做频繁变动，应单独打包为一个js文件，和业务代码的js文件分开，避免公共库的缓存失效 不同页面的合并这种发生在vue或react的单页面应用，通常我们打包出来的单页应用只有一个js文件，但这种方法在效率提升来说有阻碍，最好的方法是每个页面打包为一个js文件，当某页面被路由到加载到时，才去加载对应页面的js文件，这种方式在webpack中有相应的解决方案，就是 loadable 异步加载组件 传输方面：CDN缓存http2充分利用HTTP缓存压缩html，js，css文件体积，用gzip/brotli对 JS、CSS、HTML 等文本资源均有效，但是对图片效果不大。 gzip 通过 LZ77 算法与 Huffman 编码来压缩文件，重复度越高的文件可压缩的空间就越大。 brotli 通过变种的 LZ77 算法、Huffman 编码及二阶文本建模来压缩文件，更先进的压缩算法，比 gzip 有更高的性能及压缩率 可在浏览器的 Content-Encoding 响应头查看该网站是否开启了压缩算法，目前知乎、掘金等已全面开启了 brotli 压缩。 12345678# Request HeaderAccept-Encoding: gzip, deflate, br# gzipContent-Encoding: gzip# gzipContent-Encoding: br 压缩混淆工具 terser swc html-minifier-terser JS压缩 上述提到的 gzip/brotli 和 terser webpack 打包 webpack-bundle-ananlyze分析打包体积 使用一些更小体积的库，如 moment -&gt; dayjs 一些库进行按需加载，如 import lodash -&gt; import lodash-es 雅虎35条的链接， 从中挑出一些点来讲，如下：Image *之所以把图片放在最前，因为优化图片的效率是比较大的 Optimize Images * 图片优化 各种图片格式的应用场景： 1.1 png 大部分需要使用透明的场景 pngcrush 或其他工具压缩png。在线压缩工具 https:/ tinypng.com/ 1.2 jpg 大部分不需要透明的场景 jpegtran或其它工具压缩jpeg，大图用jpg 1.3 SVG矢量图，类似XML语法，内嵌在html里的代码图片（用来绘制地图，股票K线图等），可使用 阿里的iconfont 解决icon问题 SVG的教程 例如画一个长方形： 1234567&lt;svg width=&quot;100%&quot; height=&quot;100%&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt; &lt;rect width=&quot;300&quot; height=&quot;100&quot; style=&quot;fill:rgb(0,0,255);stroke-width:1; stroke:rgb(0,0,0)&quot; /&gt;&lt;/svg&gt; 1.4 Webp 可全用 google在2010年开发的一种全能的图片，但safari浏览器 和 webview 的兼容性不太好 1.5 png ——&gt; Webp 格式网站：智图 webp 比 jpeg/png 更小，而 avif 又比 webp 小一个级别 为了无缝兼容，可选择 picture/source 进行回退处理 12345&lt;picture&gt; &lt;source srcset=&quot;img/photo.avif&quot; type=&quot;image/avif&quot;&gt; &lt;source srcset=&quot;img/photo.webp&quot; type=&quot;image/webp&quot;&gt; &lt;img src=&quot;img/photo.jpg&quot; width=&quot;360&quot; height=&quot;240&quot;&gt;&lt;/picture&gt; Image inline，即将图片内容内嵌到html里，减少网站的HTTP请求数量，多用于移动端和小图标： 如何将图片转换为base64编码内嵌到html中，有一个在线转换网站，在html文件图片所在的src=””中添加data:image/jpg;base64,（注：这里是jpg格式，你可以改写成你编码图片的类型），将你编码的Base64代码复制到image/jpg;base64, 的后面，然后用浏览器运行即可。 当然还可以像taobao主页一样，嵌入到css的属性中使用： Optimize CSS Sprites实际上，随着带宽的普遍提高，现在不少网站都不用雪碧图了，特别是PC端，移动端用的还相对比PC端多些。但仍有网站在使用他。而雪碧图在应用上也有缺点，如果过多图标集合在一个图的话，则会出现如果该图片请求后读取不出，所有应用到该图片的图标全部会失效 Arranging the images in the sprite horizontally as opposed to vertically usually results in a smaller file size. Combining similar colors in a sprite helps you keep the color count low, ideally under 256 colors so to fit in a PNG8. “Be mobile-friendly” and don’t leave big gaps between the images in a sprite. This doesn’t affect the file size as much but requires less memory for the user agent to decompress the image into a pixel map. 100x100 image is 10 thousand pixels, where 1000x1000 is 1 million pixels 雪碧图最好竖放，避免横放，达到最小尺寸 相似图片合并，颜色相近的合并，颜色数会更少 移动端的雪碧图减少空隙 雪碧图的生成，用这个网站 选择器性能内联样式 (style=””) &gt; ID 选择器 (id) &gt; 类选择器 (class) = 属性选择器 ( a[href], input[type=”text”] 等 ) = 伪类选择器 (nth-child(n), :hover, :active 等) &gt; 元素（类型）选择器 = 伪元素选择器 Do Not Scale Images in HTML If you need &lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt;then your image (mycat.jpg) should be 100x100px rather than a scaled down 500x500px image. 不要在HTML中缩放图片，如果你需要 &lt;img width=&quot;100&quot; height=&quot;100&quot; src=&quot;mycat.jpg&quot; alt=&quot;My Cat&quot; /&gt; 的图片，直接做一张 100*100 的图即可，而不是拿一张 500*500 的图片进行缩放 Make favicon.ico Small and Cacheable使得 favicon.ico 图片可以缓存，如果不进行缓存，不关心他，浏览器还是会请求他 ContentMake Fewer HTTP Requests *减少 HTTP 请求 Reduce DNS Lookups减少DNS查询 Avoid Redirects *避免重定向 Postload Components * 懒加载组件图片进入可视区域后再请求图片资源。适用于电商等图片很多，页面很长的业务场景减少无效资源的加载并发加载的资源过多会阻塞js的加载，影响网站正常使用 案例可以看我的另一篇文章，关于JS IntersectionObserver Api，可以这个将这个api用于懒加载 下面结合react 写一个懒加载案例 123456789101112131415161718192021222324252627282930313233343536373839import React from &#x27;react&#x27;import &#x27;./Lazyload.css&#x27;import &#123; v4 as uuidv4 &#125; from &#x27;uuid&#x27;/* 总体思路：1. 先创建图片占位符2. 创建 IntersectionObserver 对象监听这些图片占位符*/const refs = [] // 图片的 ref（操作dom时用）const images = []for (let i=0; i&lt;4; i++) &#123; const ref = React.createRef() refs.push(ref) images.push(&lt;div className=&#x27;image-box&#x27; key=&#123;uuidv4()&#125;&gt; &lt;img ref=&#123; ref &#125; data-src=&#123;`https://pschina.github.io/src/assets/images/$&#123;i&#125;.jpg`&#125; /&gt; &lt;/div&gt;)&#125;const LazyLoadPage = ()=&gt;&#123; const io = new IntersectionObserver( entries =&gt;&#123; entries.forEach((item)=&gt;&#123; if (item.intersectionRatio &lt;= 0 ) return // intersectionRatio 是可见度 如果当前元素不可见就结束该函数。 item.target.src = item.target.dataset.src &#125;) // [0.01] 这是触发时机 0.01代表出现 1%的面积出现在可视区触发一次回掉函数 // threshold = [0, 0.25, 0.5, 0.75] 表示分别在0% 25% 50% 75% 时触发回掉函数 &#125;, [0.01] ); const onload = ()=&gt; refs.forEach( i =&gt; io.observe(i.current) ) return &lt;div className=&#x27;box&#x27;&gt; &#123;images&#125; &lt;img onError=&#123;onload&#125; src=&quot;&quot; /&gt; &lt;/div&gt;&#125;export default LazyLoadPage Preload Components * 预加载组件方法一，加载时另 display 为 none 1&lt;img src=&quot;http://xxx.xxx&quot; style=&quot;display: none&quot; /&gt; 方法二，利用 new Image() 12var img = new Image()img.src = &#x27;http://xxx.xxx/&#x27; 方法三，XHLHttpRequest 对象，这种方法有跨域问题 12345678910111213141516171819var xmlhttprequest = new XMLHttpRequest()xmlhttprequest.onreadystatechange = callbackxmlhttprequest.onprogress = progressCallbackxmlhttprequest.open(&#x27;GET&#x27;, &#x27;http://image.baidu.com/mouse.jpg&#x27;, true)xmlhttprequest.send()function callback () &#123; if (xmlhttprequest.readyState == 4 &amp;&amp; xmlhttprequest.status == 200 ) &#123; var reponseText = xmlhttprequest.responseText &#125;else&#123; console.log(&#x27;Request was unsuccessful:&#x27; + xmlhttprequest.status) &#125;&#125;function progressCallback (e) &#123; e = e || event if ( e.lengthComputable) console.log(`Receievd $&#123;e.loaded&#125; of $&#123;e.total&#125; bytes`)&#125; 方法四，使用库 PreloadJS 进行预加载 12345678910111213var queue = new createjs.LoadQueue(false)queue.on(&#x27;complete&#x27;, handleComplete, this)queue.loadManifest([ &#123;id: &#x27;myImg&#x27;, src:&#x27;http://pic26.nipic.com/20121213/6168183_004444903000_2.jpg&#x27;&#125;, &#123;id: &#x27;myImg2&#x27;, src:&#x27;http://pic9.nipic.com/20100814/2839526_193147158170_2.jpg&#x27;&#125;,])function handleComplete () &#123; var img = queue.getResult(&#x27;myImg&#x27;) document.body.appendChild(img)&#125; Server 服务端优化Use a Content Delivery Network (CDN) *CDN，内容分发网络，用于静态资源的加载，选择离用户近的服务器节点，节省物理上的距离，让资源到达用户的物理距离缩短 那么请求CDN内容时，如果请求头携带cookie是没用的，所以请求CDN时，cookie最好去掉，CDN的域名如果和主站域名一样，就会携带Cookie过去，所以找CDN时最好不要和主站的域名一样 例如淘宝的页面，直接在头部加DNS script标签即可。 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//g.alicdn.com&quot; /&gt; Add Expires or Cache-Control Header * There are two aspects to this rule: For static components: implement “Never expire” policy by setting far future Expires &gt; header For dynamic components: use an appropriate Cache-Control header to help the browser &gt; with conditional requests 雅虎建议将 Expires 字段用于所有组件，不单止于图片： Expires headers are most often used with images, but they should be used on all components including scripts, stylesheets, and Flash components. 静态文件，请求头可以设置永不过期或者把时间设置的长一些 1234expires: never# orExpires: Thu, 15 Apr 2099 20:00:00 GMT 对于动态组件，利用请求头的Cache-Control 控制，例如 1cache-control: max-age&#x3D;2592000 Cache-Control的值有以下几种情况： no-cache 直接要服务的新内容，不拿缓存的no-store 不缓存请求或响应的任何内容max-age 响应的最大Age值min-fresh 期望在指定时间内的响应扔有效only-if-chache 从缓存获取资源max-stale 接收已过期响应min-fresh 期望在指定时间内的响应仍有效no-transform 代理不可更改媒体类型cache-extension 新指令标记（token） 其中，最常用的是 no-cache，no-store，max-age 3个值 Gzip Components *网页中重复的内容，会用Gzip压缩，显著减少文件大小，在 Nginx 里有Nigix配置Gzip的介绍 请求头中添加： 1Accept-Encoding: gzip, deflate 相应头中添加： 1Content-Encoding: gzip Configure ETags Entity tags (ETags) are a mechanism that web servers and browsers use to determine whether the component in the browser’s cache matches the one on the origin server. ETags 是一种机制，用来确定浏览器的缓存内容和服务器的是否匹配，如匹配，则用浏览器的内容，如不匹配，则请求服务器新的内容 请求时的头部字段： 12Last-Modified: Tue, 12 Dec 2006 03:03:59 GMTETag: &quot;10c24bc-4ab-457e1c1f&quot; 响应的头部字段： 123If-Modified-Since: Tue, 12 Dec 2006 03:03:59 GMTIf-None-Match: &quot;10c24bc-4ab-457e1c1f&quot;HTTP/1.1 304 Not Modified Browser Storage * 浏览器存储优化Reduce Cookie Size * Eliminate unnecessary cookiesKeep cookie sizes as low as possible to minimize the impact on the user response &gt; timeBe mindful of setting cookies at the appropriate domain level so other &gt; sub-domains are not affectedSet an Expires date appropriately. An earlier Expires date or none removes the cookie sooner, improving the user response time Cookie是请求头的一个字段，如果存储的信息过多过大，必然会影响性能，减少Cookie体积大小，只存储用户id等简单信息 设置合适的 expire 字段让cookie过期 设置cookie时，应注意设置头部字段 Set-Cookie：httponly，只允许http通信，这样才不会被js篡改 cookie由于是种在域名下的，请求头的一个字段，所以单独带在域名中会造成CDN的流量产生不必要的损耗，解决方法是 CDN域名和主站域名独立开来 LocalStorage * HTML5专门设计出来用于浏览器存储的 大小为5Mb左右，比cookie的4kb大很多 不进行通信 接口封装相较于cookie较好 浏览器本地缓存方案 SessionStorage * 会话级别的浏览器存储 大小5M左右 不进行通信 接口封装相 对于表单信息的维护，关闭浏览器的标签页，SessionStorage会自动清空优化点： 例如用户注册页面，需要填写很多东西，如果用户还没提交但刷新了该页面，用户体验会不好 而此时可将用户所填的信息存储到SessionStorage里，用户刷新页面时，所填写的东西也不会清空。 IndexDB 是一种低级API，用于客户端存储大量结构化数据。说白了，就是浏览器的数据库 使用的网站较少 Service Worker * Service Worker 是运行在浏览器背后的独立线程，一般可以用来实现缓存功能。 使用 Service Worker的话，传输协议必须为 HTTPS。因为 Service Worker 有拦截和处理网络请求的能力，所以必须使用 HTTPS 协议来保障安全。 简单点说，就是缓存js文件到浏览器里，让客户端有大量处理js的能力。 例如，现在的Three.js 或 WebGL可以用于3D的渲染，但3D图的js脚本及数据占用资源比较多，一个脚本可达几Mb，可以用Service Worker将其缓存起来执行。 利用拦截和处理网络请求的能力，可以实现离线应用功能。 检查工具：在chrome浏览器输入chrome://serviceworker-internals/ 检查所有 service worker chrome://inspect/#service-workers 检查正在运行的 service worker Progressive Web Apps 渐进式 Web 应用 PWA 标准由 谷歌提出的移动端的标准。例如，在移动端的弱网环境下，你站点的加载速度。离线环境下，能不能有基本的页面访问 可靠：在没有网络环境中也能提供基本的页面访问 快速：因为Web App是一个增量加载的过程，不同于iOS或者安卓的原生开发，Web App加载必受到网络条件的制约 融入（Engaging）：将其能力对标原生APP，应用可以被添加到手机桌面，并和普通应用一样有全屏，推送等特性 CSSCSS是存在CSS阻塞的， css 如果在 head 中以 link 方式引入会阻塞页面的渲染 css 阻塞js的执行 但 css 不阻塞外部脚本的加载 Put Stylesheets at Top * While researching performance at Yahoo!, we discovered that moving stylesheets to the document HEAD makes pages appear to be loading faster. This is because putting stylesheets in the HEAD allows the page to render progressively. 将样式表放在头部，可以让页面逐步呈现 Choose &lt;link&gt; Over @import In IE @import behaves the same as using at the bottom of the page, so it’s best not to use it. 在IE浏览器中 @import 和 &lt;link&gt; 是一样的，位于底部执行，这和我们推荐的CSS放在HEAD中执行背道而驰，所以少用 @import JavaScriptJS 阻塞 直接引入js阻塞页面的渲染，所以才有后面 js不阻塞资源加载 js按顺序执行，阻塞后续js逻辑执行 Put Scripts at Bottom * The problem caused by scripts is that they block parallel downloads. While a script is downloading, however, the browser won’t start any other downloads, even on different hostnames. JS的加载本身就是一种阻塞，所以尽量让HTML+CSS先把页面渲染出来，再执行 底部的&lt;script&gt;&lt;/script&gt; 标签 1234567891011&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt; &lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt;&lt;/div&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;&quot;&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; Make JavaScript and CSS External if the JavaScript and CSS are in external files cached by the browser, the size of the HTML document is reduced without increasing the number of HTTP requests. (除了主页) 使用CSS或JS的外部链接，浏览器会缓存 JavaScript 和 CSS 文件，而不会增加 HTTP 请求数。 12&lt;link rel=&quot;stylesheet&quot; href=&quot;/static/css/xxx.min.css&quot;&gt;&lt;script nonce=&quot;b3/zKeoFCfru0lTFQr8Dyg==&quot; src=&quot;https://s.yimg.com/ss/rapid-3.41.3.js&quot;&gt;&lt;/script&gt; Minify JavaScript and CSS * Minification is the practice of removing unnecessary characters from code to reduce its size thereby improving load times. 最小化 JS 和 CSS，现在我们多用 webpack等打包工具来做到这一步 Minimize DOM Access * Accessing DOM elements with JavaScript is slow so in order to have a more responsive page, you should: Cache references to accessed elements Update nodes “offline” and then add them to the tree Avoid fixing layout with JavaScript 最小化DOM访问，尽可能少的进行DOM操作，这点可以从现在的React Vue等MVVM框架体现出来 渲染优化preload/prefetch dns-prefetchpreload/prefetch 可控制 HTTP 优先级，从而达到关键请求更快响应的目的。 如当页面出现 Link，可 prefetch 当前 Link 的路由资源。 12&lt;link rel=&quot;prefetch&quot; href=&quot;style.css&quot; as=&quot;style&quot;&gt;&lt;link rel=&quot;preload&quot; href=&quot;main.js&quot; as=&quot;script&quot;&gt; 1&lt;link rel=&quot;dns-prefetch&quot; href=&quot;//shanyue.tech&quot;&gt; 防抖与节流 防抖：防止抖动，单位时间内事件触发会被重置，避免事件被误伤触发多次。代码实现重在清零 clearTimeout。防抖可以比作等电梯，只要有一个人进来，就需要再等一会儿。业务场景有避免登录按钮多次点击的重复提交。 节流：控制流量，单位时间内事件只能触发一次，与服务器端的限流 (Rate Limit) 类似。代码实现重在开锁关锁 timer=timeout; timer=null。节流可以比作过红绿灯，每等一个红灯时间就可以过一批。 无论是防抖还是节流都可以大幅度减少渲染次数，在 React 中还可以使用 use-debounce 之类的 hooks 避免重新渲染。 123456789101112131415161718192021import React, &#123; useState &#125; from &#x27;react&#x27;;import &#123; useDebounce &#125; from &#x27;use-debounce&#x27;;export default function Input() &#123; const [text, setText] = useState(&#x27;Hello&#x27;); // 一秒钟渲染一次，大大降低了重新渲染的频率 const [value] = useDebounce(text, 1000); return ( &lt;div&gt; &lt;input defaultValue=&#123;&#x27;Hello&#x27;&#125; onChange=&#123;(e) =&gt; &#123; setText(e.target.value); &#125;&#125; /&gt; &lt;p&gt;Actual value: &#123;text&#125;&lt;/p&gt; &lt;p&gt;Debounce value: &#123;value&#125;&lt;/p&gt; &lt;/div&gt; );&#125; 虚拟列表优化这又是一个老生常谈的话题，一般在视口内维护一个虚拟列表(仅渲染十几条条数据左右)，监听视口位置变化，从而对视口内的虚拟列表进行控制。 在 React中可以用下列库 react-virtualized react-window","tags":["面试","Web性能优化"]},{"title":"创建自己的node cli","path":"/2021/10/17/【2021-10-17】创建自己的node-cli/","content":"经常使用create-react-app作为命令行生成项目，总想着自己能配置一个属于自己的命令行工具，很酷炫的样子。最近有时间，终于来实现了 初始化项目12mkdir y-cli &amp;&amp; cd y-clinpm init -y 核心步骤 npm link新建一个文件 ./bin/yyt.js，并写一点简单的东西 1234// 这里告诉系统要以node环境执行：#!/usr/bin/env nodeconsole.log(&#x27;hello,node cli!&#x27;) 再在 package.json 里添加 bin 配置，需要指定一个自定义命令，如 y-cli 123&quot;bin&quot;: &#123; &quot;y-cli&quot;: &quot;./bin/yyt.js&quot;&#125; 在命令行里运行： 123npm link# 或者在全局install：npm install . -g 可以看到如下，npm将命令作为软链接连接至对应的js文件 123456789xxx@xxxMBP y-cli % sudo npm linknpm WARN y-cli@1.0.0 No descriptionnpm WARN y-cli@1.0.0 No repository field.up to date in 0.832sfound 0 vulnerabilities/usr/local/bin/yyt -&gt; /usr/local/lib/node_modules/y-cli/bin/yyt.js/usr/local/lib/node_modules/y-cli -&gt; /Users/xxx/Documents/code/y-cli 所用到的库cli需要获取用户的输入，选择并做相应的事情，就需要使用到一些库来帮忙我们更方便的写cli 核心： commander - 处理核心命令 主要模块，在终端输出各种信息全靠这个模块 download-git-repo - 下载git模块 美化： chalk — 美化终端字符显示 figlet — 在终端输出大型字符 inquirer — 命令行参数输入交互 shelljs — 在js文件写命令行 ora - 实行loading效果 让我们来把这些库全部安装一遍 commander根据commander文档的一些参数，我们来编写脚本 yyt.js 12345678#!/usr/bin/env nodeconst program = require(&#x27;commander&#x27;)// 获取package.json中的版本信息program.version(require(&quot;../package.json&quot;).version)// 解析指令，这点很重要 不解析指令则无效program.parse(process.argv) commander自带 -V 和 -h 两个命令，运行 yyt -h可看到： 123456xxx@xxxdeMacBook-Pro y-cli % yyt -hUsage: yyt [options]Options: -V, --version output the version number -h, --help display help for command .option() 加入自定义命令 1program.option(&#x27;-d, --description&#x27;, &#x27;yyt 脚手架简介：。。。。&#x27;) 可以发现已经加上该命令： 1234567xxx@xxxdeMacBook-Pro y-cli % yyt -hUsage: yyt [options]Options: -V, --version output the version number -d, --description yyt 脚手架简介：。。。。 -h, --help display help for command .command() 自定义命令， 基础格式： 1program.option(&#39;hello &lt;param1&gt; [param2]&#39;) 值得注意的是，尖括号&lt;&gt;里的参数是必填参数，方括号[]里的参数是可选参数 利用.command()写一个简单的demo，弄清整个基础流程： 123456789program\t.command(&#x27;hello &lt;param1&gt; [param2]&#x27;) // 命令里利用.usage()参数化，供后面的.action()回调使用：\t.usage(&#x27;&lt;command&gt; &lt;param1&gt; [param2]&#x27;) // 回调处理：\t.action((param1, param2)=&gt;&#123; console.log(param1); console.log(param2);\t&#125;) 12345678ziyouzhiyi@ziyouzhiyideMacBook-Pro y-cli % yyt helloerror: missing required argument &#x27;param1&#x27;ziyouzhiyi@ziyouzhiyideMacBook-Pro y-cli % yyt hello t tundefinedziyouzhiyi@ziyouzhiyideMacBook-Pro y-cli % yyt hello t yty 上面这些参数也可通过.option()来实现，但需要加上-，如-react，如以下的例子，利用参数创建项目： 12345678910111213141516program.command(&#x27;create &lt;projectName&gt;&#x27;)\t.option(&#x27;-react&#x27;)\t.option(&#x27;-vue&#x27;)\t.action((projectName, option) =&gt; &#123; const type = Object.keys(option)[0] switch(type) &#123; case &quot;Vue&quot;: console.log(&quot;创建vue项目&quot;) break; case &quot;React&quot;: console.log(&quot;创建react项目&quot;) break; default: console.log(&quot;未添加参数，不能下载&quot;) &#125;\t&#125;) 执行命令后可以看到打印： 12ziyouzhiyi@ziyouzhiyideMacBook-Pro y-cli % yyt create test -react创建react项目 download-git-repo下载的步骤把他替换成真的仓库，需要用到 download-git-repo 库 把console.log替换成真实的git仓库 1234567891011121314151617... case &quot;React&quot;: download( // 此处应加上 #main 分支名称，否则控制台会显示报错 &#x27;direct:git@github.com:ys558/yyt-template.git#main&#x27;, projectName, &#123; clone: true &#125;, (err, x) =&gt; &#123; // 错误回调： if (err) console.log(err) console.log(`$&#123;projectName&#125; 项目创建成功`) &#125; ) break; default: console.log(&quot;未添加参数，不能下载&quot;)... inquirer👆的步骤下载的仓库是在命令行下直接完成的，如果要像vue一样能让用户输入生成的，可以用该库，我们把代码改造一下，实际上就是在 .action() 的回调中进行处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556const questions = [\t&#123; type: &#x27;input&#x27;, name: &#x27;projectName&#x27;, message: &#x27;请输入项目名称&#x27;,\t&#125;,\t&#123; type: &#x27;list&#x27;, name: &#x27;frameWork&#x27;, message: &#x27;请选择框架&#x27;, default: &#x27;React&#x27;, choices: [&#x27;React&#x27;,&#x27;Vue&#x27;]\t&#125;,]program\t.command(&#x27;create&#x27;)\t.action(() =&gt; &#123; inquirer.prompt(questions) .then((&#123;projectName, frameWork&#125;) =&gt; &#123; switch (frameWork) &#123; case &#x27;React&#x27;: download( &#x27;direct:git@github.com:ys558/yyt-template.git&#x27;, projectName, &#123; clone: true &#125;, (err) =&gt; &#123; // 错误回调： if (err) &#123; console.log(err) return &#125;else&#123; console.log(`$&#123;projectName&#125; 项目创建成功`) &#125; &#125;) break; case &#x27;Vue&#x27;: download( &#x27;direct:git@github.com:ys558/yyt-template.git&#x27;, projectName, &#123; clone: true &#125;, (err) =&gt; &#123; // 错误回调： if (err) &#123; console.log(err) return &#125;else&#123; console.log(`$&#123;projectName&#125; 项目创建成功`) &#125; &#125;) break; default: break; &#125; &#125;)\t&#125;) 美化chalk，figlet美化终端字体，如 chalk: 123456if (err) &#123;\tconsole.log(chalk.bgYellow(err))\treturn&#125;else&#123;\tconsole.log(`$&#123;chalk.bgGrey(projectName)&#125; $&#123;chalk.greenBright(&#x27;项目创建成功&#x27;)&#125;`)&#125; figlet: 1234figlet.defaults(&#123;font: &#x27;Standard&#x27;&#125;)function logo()&#123;\tconsole.log(figlet.textSync(&#x27;hi yyt!&#x27;))&#125; ora这是一个比较麻烦的模块，他是 es module 类型的import导入模块，而 node 用的是commonjs 的 require 导入模块，而且须在 package.json 里添加 &#123; &quot;type&quot; : &quot;module&quot; &#125; 才能正常加载，下面贴上相关代码： 123456const spinner = ora(&quot;下载初始化模板中...&quot;)spinner.start()spinner.succeed(`$&#123;chalk.bgGrey(projectName)&#125; $&#123;chalk.greenBright(&#x27;项目创建成功&#x27;)&#125;`)spinner.stop() 完整代码仓库","tags":["node cli"]},{"title":"react-ssr服务端渲染","path":"/2021/08/27/【2021-08-27】react-ssr服务端渲染/","content":"服务端渲染能解决首屏加载过慢的问题，近年来这是一个趋势，这里写一个react的demo，以免忘了。 本文涉及的 react api如下： ReactDOM.hydrate(&lt;App /&gt;,document.getElementById(&#39;root&#39;) ReactDOMServer.renderToString(&lt;App/&gt;) 用脚手架初始化项目这部分不解释，用脚手架快速生成一个app ！注意: create-react-app 新版本生成的 App.js 已经没有 import React from &#39;react&#39;，我们必须把它加回来，否则服务端渲染会报错： 123456789101112131415+ import React from &#x27;react&#x27;import &#123; useState &#125; from &#x27;react&#x27;;import &#x27;./App.css&#x27;;function App() &#123; const [count, setCount] = useState(0) return &lt;div className=&quot;App&quot;&gt; &lt;p&gt;&#123;count&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt; setCount(count + 1 )&#125;&gt;+&lt;/button&gt; &lt;button onClick=&#123;()=&gt; setCount(count-1)&#125;&gt;-&lt;/button&gt; &lt;/div&gt;&#125;export default App; 添加服务端1234yarn add express# 首页须进行打包操作给服务端做渲染：yarn buildmkdir server &amp;&amp; cd server &amp;&amp; touch server.js server\\server.js 1234567891011121314151617181920212223242526272829import express from &#x27;express&#x27;import fs from &#x27;fs&#x27;import path from &#x27;path&#x27;import React from &#x27;react&#x27;import ReactDOMServer from &#x27;react-dom/server&#x27;import App from &#x27;../src/App&#x27;const app = express()app.use(&#x27;^/$&#x27;, (req, res, next) =&gt;&#123; fs.readFile(path.resolve(&#x27;../build/index.html&#x27;), &#x27;utf-8&#x27;, (err, data) =&gt; &#123; if (err) &#123; console.log(err) return res.status(500).send(&#x27;smoe error happened&#x27;) &#125; return res.send(data.replace( &#x27;&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&#x27;, `&lt;div id=&quot;root&quot;&gt;$&#123;ReactDOMServer.renderToString(&lt;App/&gt;)&#125;&lt;/div&gt;` )) &#125; )&#125;)app.use(express.static(path.resolve(__dirname, &#x27;..&#x27;, &#x27;build&#x27;)))const PORT = 8888app.listen(PORT, ()=&gt;console.log(`listen on PORT $&#123;PORT&#125;`)) 把 express 跑起来 src\\index.js 改造12- ReactDOM.render(&lt;App /&gt;,document.getElementById(&#x27;root&#x27;))+ ReactDOM.hydrate(&lt;App /&gt;,document.getElementById(&#x27;root&#x27;) 添加 babel 让node认识jsx语法1yarn add @babel/preset-env @babel/preset-react @babel/register ignore-styles 在 server 文件夹添加运行 babel 机制执行touch server/index.js node原生的必须用 require 的写法导入模块，如下： 12345678require(&#x27;ignore-styles&#x27;)require(&#x27;@babel/register&#x27;)(&#123; ignore: [/(node_module)/], presets: [&#x27;@babel/preset-env&#x27;, &#x27;@babel/preset-react&#x27;]&#125;)require(&#x27;./server&#x27;) 添加 package.json 里的脚本后再运行 yarn ssr 1&quot;ssr&quot;: &quot;node server/index.js&quot; 我们会发现顺利解析了 jsx 语法： 12345yuyi@home-pc MINGW64 /e/study/code/react-ssr-demo (main)$ yarn ssryarn run v1.22.10$ node server/index.jslisten on PORT 8888","tags":["react","ssr"]},{"title":"node处理ES6模块及动态模块导入","path":"/2021/08/14/【2021-08-14】node处理ES6模块及动态模块导入/","content":"本文阐述了两个方面的内容。1. node处理ES6模块，大部分参考了阮一峰老师的文章 2. 动态模块导入 node（CJS）处理ES6模块（ESM）我们知道node只能通过 require() 加载模块， module.exports输出，是同步操作，这套语法规则称作commonjs，即CJS。 而ES6则是另一套语法规则，ECMA Script Module，简称ESM。通过import加载，export输出，是异步操作。 如果要在node里用上 ESM 语法规则，则得做一些必要的改变： 通过改变文件名。将带有 ESM 语法规则的文件 $\\color{CadetBlue} {后缀名改为 .mjs} $，node则可正常执行。 不改变文件后缀名，$\\color{CadetBlue}在 package.json 里添加 “type”:”module” 。$ 相对的，如果这时想用回 require() 语法，则要把文件后缀名改为cjs。$\\color{red} 但两种语法规则强烈不建议混用。$ CommonJS 模块加载 ES6 模块require() 命令不能加载 ES6 模块，会报错，node里只能使用import()这个方法加载，如 123(async () =&gt; &#123; await import(&#x27;./index.mjs&#x27;)&#125;)() ES6 模块内部可以使用顶层 await命令，导致无法被同步加载。 ES6模块加载 CommonJS 模块import 可以加载CJS模块，不能单独解构加载。这是因为 ES6 模块需要支持静态代码分析，而 CommonJS 模块的输出接口是module.exports，是一个对象，无法被静态分析，所以只能整体加载。 12345// 正确import packageMain from &#x27;commonjs-package&#x27;;// 报错import &#123; method &#125; from &#x27;commonjs-package&#x27;; 可以改成单一输出项，写成下面这种： 12345678import packageMain from &#x27;commonjs-package&#x27;;const &#123; method &#125; = packageMain;// 或 直接export 时带 &#123; &#125;， node则会认为是一个整体，如：import &#123; method &#125; from &#x27;./other.js&#x27;function method (user) &#123; &#125;export &#123; method &#125; 而 class 则不受 default 关键字限制： 123import DefaultClass from &#x27;./other.js&#x27;export default class DefaultClass &#123; &#125; 两种格式支持模块 如果原始模块是CJS，可以加一个包装层 12import cjsModule from &#x27;./index.js&#x27;export const foo = cjsModle.foo 上面代码先整体输入 CommonJS 模块，然后再根据需要输出具名接口。 你可以把这个文件的后缀名改为.mjs，或者将它放在一个子目录，再在这个子目录里面放一个单独的package.json文件，指明&#123; type: &quot;module&quot; &#125; 另一种做法是在package.json文件的exports字段，指明两种格式模块各自的加载入口。 1234&quot;exports&quot;：&#123; &quot;require&quot;: &quot;./index.js&quot;， &quot;import&quot;: &quot;./esm/wrapper.js&quot; &#125; 上面代码指定require()和import，加载该模块会自动切换到不一样的入口文件。 模块动态导入import 普通同步模块导入：这里开始本篇第二个内容，模块动态导入。这里以ESM写法为例，用node运行在 package.json 文件里加上：&quot;type&quot;: &quot;module&quot; 下面举个简单的翻译的例子来说明， ./tranlate/en-translation.js 12const translations = &#123; HI: &#x27;hello&#x27; &#125;export const enTranslations = translations ./tranlate/sp-translation.js 12const translations = &#123; HI: &#x27;hola&#x27; &#125;export const spTranslations = translations ./locale.js 12345678910111213import &#123;enTranslations&#125; from &#x27;./translate/en-translation.js&#x27;import &#123;spTranslations&#125; from &#x27;./translate/sp-translation.js&#x27;const user = &#123; locale: &#x27;sp&#x27;&#125;let translationsswitch (user.locale) &#123; case &#x27;sp&#x27;: translations = spTranslations break default: translations = enTranslations break&#125;console.log(translations.HI) // hola 运行 node locale.js 可以发现打印出 hola 的内容。 以上是我们平时import的做法，这种是同步的写法，import完后所有的文件会被加载一遍，如果文件一大的话，则会影响效率。 import() 异步模块导入，按需加载，CJS写法：对以上翻译模块的代码进行改动， 由于node里除了 class，函数和{} 均没有 defalut 关键字，所以只能具名进行解构：./locale.js 123456const user = &#123; locale: &#x27;sp&#x27;&#125;import(`./translate/$&#123;user.locale&#125;-translation.js`) .then((&#123; enTranslations=&#123;&#125;, spTranslations=&#123;&#125; &#125;) =&gt; &#123; console.log(spTranslations.HI) &#125;) 此时可以看到控制台打印 hola： 1234567yuyi@home-pc MINGW64 /e/study/code/dynamic-import-module (master)$ npm run l&gt; dynamic-import-module@1.0.0 l E:\\study\\code\\dynamic-import-module&gt; node locale.jshola 我们刚刚改造之前的 switch 函数的 default 分支改写，则用 catch替代：如果传入为找不到的语言，则会默认输出英文的翻译 123456789// 默认只有en和sp，找不到的语言 cn：const user = &#123; locale: &#x27;cn&#x27; &#125; ... // 利用catch替代了switch函数的default分支： .catch(()=&gt; import(&#x27;./translate/en-translation.js&#x27;).then( module =&gt; &#123; console.log(module.enTranslations.HI) // hello &#125;)) import() 的ESM写法：将以上的代码改为在浏览器中的ESM写法，在浏览器中运行，改写如下： locale.html 123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; &lt;!-- 浏览器也得在script标签上仍要规定 type=&quot;module&quot; --&gt; &lt;script type=&quot;module&quot; src=&quot;./loacleEMS.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ./translate/ESM-en-translation.js 12const translations = &#123; HI: &#x27;hello&#x27; &#125;export default translations ./translate/ESM-sp-translation.js 12const translations = &#123; HI: &#x27;hola&#x27; &#125;export default translations ./loacleEMS.js 12345678910111213141516import enTranslations from &#x27;./translate/ESM-en-translation.js&#x27;import spTranslations from &#x27;./translate/ESM-sp-translation.js&#x27;const user = &#123; locale: &#x27;sp&#x27;&#125;let translationsswitch (user.locale) &#123; case &#x27;sp&#x27;: translations = spTranslations break; default: translations = enTranslations break;&#125;console.log(translations.HI) // hola 改写为 import() 方法的 ./loacleEMS.js。值得注意的是，由于ESM export 的关键字属性对所有函数object等都有效，能匿名到处，所以写起来更加简洁 1234567const user = &#123; locale: &#x27;sp&#x27;&#125;import(`./translate/ESM-$&#123;user.locale&#125;-translation.js`) // 可直接解构匿名 default 的值： .then((&#123; default: translations &#125;) =&gt; console.log(translations.HI) // hola ) 这种情况下我们怎么改写 switch-default 分支呢？答案是利用 .catch()，并且我们把 const user = &#123; locale: &#39;sp&#39;&#125; 改写为 const user = &#123; locale: &#39;cn&#39;&#125;，一个文件里没有的语言 12345678910const user = &#123; locale: &#x27;cn&#x27;&#125;import(`./translate/ESM-$&#123;user.locale&#125;-translation.js`)// 将.then() 放置于.catch() 里的回调 import() 之后执行，// 这样，控制台报错找不到 &#x27;cn&#x27;，但程序仍会往下走：.catch(()=&gt; import(&#x27;./translate/ESM-en-translation.js&#x27;) .then( (&#123; default: translations&#125;) =&gt; &#123; console.log(translations.HI) // hello &#125;))","tags":["node","ES6","ESM","CJS"]},{"title":"react组件变外控的几种方式：eventEmitter、ref、props_this","path":"/2021/08/14/【2021-08-14】react组件变外控的几种方式：eventEmitter、ref、props_this/","content":"最近很忙，搁了很久没更新了，趁着今天空闲来更新一波。组件外控的好处是能使得React最近解锁了组件传值的新模式，EventEmitter，fb也封装了一个fbemitter的组件，用于fb网站间的传值。用过vue的小伙伴对event emitter肯定不陌生。这里结合react的使用来简单说明一下用法。 eventEmitter引入12import &#123; EventEmitter &#125; from &#x27;fbemitter&#x27;;var emitter = new EventEmitter(); 定义事件写两个没有层级关系的组件： 12345678910111213141516171819202122232425262728293031import React, &#123; Component &#125; from &#x27;react&#x27;import &#123; EventEmitter &#125; from &#x27;fbemitter&#x27;export default class EventEmitterDemo extends Component &#123; render() &#123; // 0. 可用于无层级关系组件传值： return &lt;&gt; &lt;Child1 /&gt; &lt;Child2 /&gt; &lt;/&gt; &#125;&#125;// 1. 初始化const emitter = new EventEmitter()class Child1 extends Component &#123; state = &#123; show:　&#x27;&#x27; &#125; componentDidMount() &#123; // 2. 定义 this.eventEmitter = emitter.addListener( &#x27;event&#x27;, (x,y)=&gt; this.setState(&#123; show: &lt;&gt;&#123;x&#125;,&#123;y&#125;&lt;/&gt; &#125;) ) &#125; render()&#123; return &lt;div&gt; &#123;this.state.show&#125; &lt;/div&gt; &#125;&#125; 发出并触发事件12345678class Child2 extends Component &#123; // 3. 发出事件名称及参数： render()&#123; return &lt;div&gt; &lt;button onClick=&#123;()=&gt; emitter.emit(&#x27;event&#x27;, 12, 22)&#125;&gt;eventEmitter发出，见控制台&lt;/button&gt; &lt;/div&gt; &#125;&#125; 效果 once(eventType, callback)只调用一次的eventEmitter，如： 123456789componentDidMount() &#123; this.eventEmitter = emitter.once( &#x27;event&#x27;, (x,y)=&gt; console.log(x,y) )&#125;emitter.emit(&#x27;event&#x27;, 13); // 10 //再次触发emitter.emit(&#x27;event&#x27;, 12); // 不会输出 remove(eventType) 及 removeAllListeners(eventType)删除事件，一般我们在组件卸载时应该执行remove进行删除，而removeAllListeners则可以一次性删除所有监听事件，如： 123456componentWillUnmount()&#123; // 3. 当组件卸载时要将其删除 this.eventEmitter.remove(); // 或： this.removeAllListeners()&#125; 子组件接收整个父组件this实例，达到子组件控制父组件的目的这种原理类似HOC和装饰器函数，但比HOC写法更简洁明了，直接上代码 12345678910111213141516171819202122export class ByPropsThis extends Component &#123; state = &#123; count: 0&#125; render()&#123; return &lt;&gt; Father count: &#123;this.state.count&#125; &lt;Child thisFrFather=&#123;this&#125; /&gt; &lt;/&gt; &#125;&#125;class Child extends Component &#123; render()&#123; console.log(this.props.thisFrFather.state) return &lt;div&gt; &lt;p&gt;&#123;this.props.count&#125;&lt;/p&gt; &lt;button onClick=&#123;()=&gt; this.props.thisFrFather.setState((&#123;count&#125;) =&gt; (&#123;count: count + 1&#125;))&#125;&gt; child + &lt;/button&gt; &lt;/div&gt; &#125;&#125; Ref 父控制子的事件1234567891011121314151617181920212223242526272829export class ByRef extends Component &#123; testFunc = null // 自动去寻找 ChildToPlus里的 plus() 函数执行： handleChildPlus = () =&gt; this.testFunc.plus() render()&#123; return &lt;&gt; &lt;button onClick=&#123;this.handleChildPlus&#125;&gt;plus fr father&lt;/button&gt; &#123;/* 整个ChildToPlus都被打上ref标记 */&#125; &lt;ClickToPlus ref=&#123; ref =&gt; this.testFunc = ref &#125; /&gt; &lt;/&gt; &#125;&#125;class ClickToPlus extends Component &#123; constructor(props)&#123; super(props) this.state = &#123;count : 0&#125; &#125; plus = () =&gt; this.setState((&#123; count &#125;) =&gt; (&#123; count: count + 1 &#125;)) render() &#123; return ( &lt;div&gt; &lt;p&gt;&#123;this.state.count&#125;&lt;/p&gt; &lt;button onClick=&#123;this.plus&#125;&gt;child +&lt;/button&gt; &lt;/div&gt; ) &#125;&#125;","tags":["react","eventEmitter"]},{"title":"发布自己的npm-package流程","path":"/2021/07/07/【2021-07-07】发布自己的npm-package流程/","content":"最近工作需要，需发布自己的npm包，这里写一个简单的demo，做一个简单的记录。 1. 注册一个自己的npm账号这个没什么好解释的 2. 建一个github仓库这个没什么好解释的 3. 项目结构12|__&#x2F;package&#x2F;|__&#x2F;test-folder&#x2F; /package 文件夹用于存放我们写的包/test-folder 文件夹用于引用并测试 /package 里的包 编写包 my-package-publish-test 在 /package 里初始化项目 npm init 并写一些关于该 package 的名字，如my-package-publish-test 和描述等东西像写普通文件一样，新建/package/index.js 并写下一些简单功能，如 12const isTest = string =&gt; string === &#x27;test&#x27;module.exports = isTest 4. 通过软链接在本地使用包/package如不上传包到npm，本地使用可以直接使用软链接，可以用于本地调试等工作，方法如下。如要直接上传可跳过该步骤 在当前目录 ./package/ 下运行创建软链接 1npm link 返回 ./test-folder/ 下运行软链接，软链接后的名必须对应 package/package.json 的 &quot;name&quot; 12cd ../test-folder/npm link my-package-publish-test 5. 登录并发布返回 ./package/ 并执行登录，运行 12cd ../package/npm login 输入一些 npmjs.org的用户名密码等，登录npm账号 123456$ npm loginUsername: ys558Password:Email: (this IS public)Email: (this IS public) yuyi.gz@163.comLogged in as ys558 on https://registry.npmjs.org/. ！！如出现以下报错需要登录自己的邮箱是否通过 npmjs.org 的验证邮件 1234567npm ERR! code E403npm ERR! 403 403 Forbidden - PUT http://registry.npmjs.org/my-package-publish-test - Forbiddennpm ERR! 403 In most cases, you or one of your dependencies are requestingnpm ERR! 403 a package version that is forbidden by your security policy.npm ERR! A complete log of this run can be found in:npm ERR! C:\\Users\\yuyi\\AppData\\Roaming pm-cache\\_logs\\2021-07-04T12_02_21_879Z-debug.log 最后运行以下命令，即可发布成功属于自己的npm package 1npm publish 发布成功： 1234567891011121314151617$ npm publishnpm notice npm notice package: my-package-publish-test@1.0.0npm notice === Tarball Contents ===npm notice 85B index.jsnpm notice 564B package.jsonnpm notice 21B README.mdnpm notice === Tarball Details ===npm notice name: my-package-publish-testnpm notice version: 1.0.0npm notice package size: 509 Bnpm notice unpacked size: 670 Bnpm notice shasum: 98b90c3ab222a573f0379802cc3d59d43ffcb402npm notice integrity: sha512-Fz/SDMr5vgoAe[...]UD5J4OP0rFtFA==npm notice total files: 3npm notice+ my-package-publish-test@1.0.0 6. 发布具有命名空间的package所谓的命名空间，就是以 @ 开头的包，例如我们熟悉的 @babel/core，一般这种需要创建组织organization，步骤如下： 6.1 在自己的npm页面申请成立一个组织，organization我把几个关键步骤进行了截图，如下 如果有条件可以选择收费的，其实也不贵，一个月也就7美刀，40多软妹币；也可以直接将你的账号转换为组织账号，我这里为了演示，选择免费公开账号第二个选项： 6.2 重新用组织的名进行登录执行 npm login scope=&lt;组织名称&gt; ，用户名也和组织名称一样： 12345$ npm login scope=zyzy-orgUsername: zyzy-orgPassword:Email: (this IS public) yuyi.gz@163.comLogged in as zyzy-org on https://registry.npmjs.org/. 6.3 在发布的包前加上 @组织名将该项目的 package\\package.json 里 &quot;name&quot; 的属性改为如下，前面加个 @zyzy-org/ 123&#123; &quot;name&quot;: &quot;@my-test-package/my-package-publish-test&quot;,&#125; 6.4 运行 npm publish --access=public即可见到发布成功： 1234567891011121314151617$ npm publish --access=publicnpm notice npm notice package: @zyzy-org/my-package-publish-test@1.0.0npm notice === Tarball Contents ===npm notice 69B index.jsnpm notice 574B package.jsonnpm notice 21B README.mdnpm notice === Tarball Details ===npm notice name: @zyzy-org/my-package-publish-testnpm notice version: 1.0.0npm notice package size: 503 Bnpm notice unpacked size: 664 Bnpm notice shasum: ddc493df353964be87f43d14e5f7fd877b7b4c04npm notice integrity: sha512-XFE19u9gFMcI1[...]1/LA3ocSzHZ8Q==npm notice total files: 3npm notice+ @zyzy-org/my-package-publish-test@1.0.0 6.5 新项目初始化时，须运行 npm init scope=zyzy-org7 删除已发布的包1npm unpublish @zyzy-org/my-package-publish-test --force","tags":["npm package"]},{"title":"JWT自学笔记","path":"/2021/06/21/【2021-06-21】JWT自学笔记/","content":"JWT是一种跨域鉴权技术，现广泛运用于各大网站，本文结合demo代码简单阐述，本篇的概念部分1到4点搬运了阮大神的这篇文章，第5点结合我自己写的一个Demo来实现具体的JWT业务 1. JWT是什么？JSON Web Token (jwt)是一个开放标准(RFC 7519)，它定义了一种紧凑的、自包含的方式，用于作为JSON对象在各方之间安全地传输信息。该信息可以被验证和信任，因为它是数字签名的。 简单来说就是用于跨域鉴权。一般来说我们鉴权的过程如下： 1、用户向服务器发送用户名和密码。2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。3、服务器向用户返回一个 session_id，写入用户的 Cookie。4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。 上述过程如果单机当然没有问题，如果是集群，或跨域的服务导向架构，就要求 session 数据共享，每台服务器都能够读取 session。举例来说，A 网站和 B 网站是同一家公司的关联服务。现在要求，用户只要在其中一个网站登录，再访问另一个网站就会自动登录，请问怎么实现？一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。 另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。 jwt 就是这种方案的一个代表。 2. JWT的结构我们可以在官网看到他的结构 JWT结构 可以看到分为以下3部分： Header（头部）Payload（负载）Signature（签名） Header 头部1234&#123; &quot;alg&quot;: &quot;PS384&quot;, &quot;typ&quot;: &quot;JWT&quot;&#125; 以上分别代表 &quot;typ&quot; 表示这个令牌（token）的类型（type） &quot;alg&quot; 表示该token的算法类型，默认为HMAC SHA256（写成 HS256） Payload 负载以下为官方规定的可选字段： iss (issuer)：签发人exp (expiration time)：过期时间sub (subject)：主题aud (audience)：受众nbf (Not Before)：生效时间iat (Issued At)：签发时间jti (JWT ID)：编号 注意，这部分是不加密的，是简单的Base64转码过程，所以密文信息不能放在这部分，除非你的文字本身加密过 Signature 签名这部分是对前两部分的签名，防止数据篡改。 需指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。 1HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload), secret) 算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。 Header 和 Payload 串型化的算法是 Base64URL。这个算法跟 Base64 算法基本类似，但有一些小的不同。 JWT 作为一个令牌（token），有些场合可能会放到 URL（比如 api.example.com/?token=xxx）。Base64 有三个字符+、/和=，在 URL 里面有特殊含义，所以要被替换掉：=被省略、+替换成-，/替换成_ 。这就是 Base64URL 算法。 3. JWT使用方法：客户端收到服务器返回的 JWT，可以储存在 Cookie 里面，也可以储存在 localStorage。 此后，客户端每次与服务器通信，都要带上这个 JWT。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP 请求的头信息Authorization字段里面。 1Authorization: Bearer &lt;token&gt; 另一种做法是，跨域的时候，JWT 就放在 POST 请求的数据体里面。 4. 使用时几个注意点（1）JWT 默认是不加密，但也是可以加密的。生成原始 Token 以后，可以用密钥再加密一次。 （2）JWT 不加密的情况下，不能将秘密数据写入 JWT。 （3）JWT 不仅可以用于认证，也可以用于交换信息。有效使用 JWT，可以降低服务器查询数据库的次数。 （4）JWT 的最大缺点是，由于服务器不保存 session 状态，因此无法在使用过程中废止某个 token，或者更改 token 的权限。也就是说，一旦 JWT 签发了，在到期之前就会始终有效，除非服务器部署额外的逻辑。 （5）JWT 本身包含了认证信息，一旦泄露，任何人都可以获得该令牌的所有权限。为减少盗用，JWT 的有效期应该设置得比较短。对于一些比较重要的权限，使用时应该再次对用户进行认证。 （6）为了减少盗用，JWT 不应该使用 HTTP 协议明码传输，要使用 HTTPS 协议传输。 5. Demo 代码 及实际使用场景完整代码可点击标题可见git仓库，下面按照我编写代码的顺序阐述几个注意点， 代码里一些配置的解析 .env 文件中的两个token生成可以按照以下办法，利用node REPL的crypto模块生成： 123456789yuyi@home-pc MINGW64 /e/study/code/2021/jwt-learn (master)$ nodeWelcome to Node.js v14.14.0. Type &quot;.help&quot; for more information.&gt; require(&#x27;crypto&#x27;).randomBytes(64).toString(&#x27;hex&#x27;)&#x27;6dedc49577ebb7c685246241533dc068ee43cba49d01b34d243b6b8924786a69d6637c4335e508343ba4c27a1fec1d2f11ea5eea173bd4af04c0f263a4ee98b5&#x27;&gt; require(&#x27;crypto&#x27;).randomBytes(64).toString(&#x27;hex&#x27;)&#x27;4f3ea9c60d55b2a8a58f559ae76e133353a973708d6575daa10ac4bd28f6314d261a4458703be1333f65eddb29a1b58e21ebe493fede5c198952863f1f97e023&#x27;&gt; 发送请求检测时不需要安装postman，只需在 vs code 上安装神器 REST Client ，不仅可以测普通的接口，最新的 GraphQL 语法也支持，其测试文件以 rest 结尾，如 request.rest dotenv 是个不需要依赖就能读取项目中 .env 文件的配制的库，只需在 文件开始引用即可，如： 12345678910111213// dotenv库引用：require(&#x27;dotenv&#x27;).config()...app.post(&#x27;/login&#x27;, (req,res) =&gt; &#123; // 登录token鉴权 const username = req.body.username const user = &#123; name: username &#125; const accessToken = jwt.sign(user, process.env.ACCESS_TOKEN_SECRET) res.json(&#123; accessToken &#125;)&#125;) 解析及测试主代码 npm run dev-start 把服务跑起后，点击 request.rest 文件的这里下面的位置，这些最基础的功能在 01_base 分支的这些代码就能实现，测试接口返回的正确与否 鉴权部分抽离为单独的中间件函数，02_authenticate_token_modulize 分支的这些代码， 1234567891011function authenticateToken (req, res, next) &#123; const authHeader = req.headers[&#x27;authorization&#x27;] const token = authHeader &amp;&amp; authHeader.split(&#x27; &#x27;)[1] if (token == null) return res.sendStatus(401) jwt.verify(token, process.env.ACCESS_TOKEN_SECRET, (err, user) =&gt; &#123; if (err) return res.sendStatus(403) req.user = user // 交给下个中间件： next() &#125;)&#125; 将其放入app.get(&#39;/posts&#39;)的第二个参数即可调用： 1234// authenticateToken 为鉴权中间件：app.get(&#x27;/posts&#x27;, authenticateToken, (req, res) =&gt; &#123; res.json(posts.filter(post =&gt; post.username === req.user.name))&#125;) 将鉴权部分，即token的分发，拆分为单独一个模块。集中管理各个路由，包括/login, /logout的token，在后端属于微服务的架构 单独把颁发token这部分内容封装一个单独文件，新建文件 authServer.js 及更新命令 auth 123&quot;scripts&quot;: &#123; &quot;auth-start&quot;: &quot;nodemon authServer.js&quot;&#125;, Refresh Token 上面是正常流程的注册登录所用的token，但实际业务中，Access Token 设置的时间不可能很长，比如说10分钟，而10分钟对于用户体验来说肯定不好，一过期的话就要重新登录，所以大多数业务采用了另一种折中的方案，即多生成一个 Refresh Token，这种的过期时间比较长，例如7天免登录 如果携带 Access Token 访问需要认证的接口时鉴权失败（例如返回 401 错误），则客户端使用 Refresh Token 向刷新接口申请新的 Access Token 如果 Refresh Token 没有过期，服务端向客户端下发新的 Access Token 客户端使用新的 Access Token 访问需要重新认证的接口 下面解析 Refresh Token 的制作过程：authServer.js文件中把生成Token封装成一个函数，并在 app.post(&#39;/login&#39;, (req,res) =&gt; &#123; 里应用 1234567891011121314app.post(&#x27;/login&#x27;, (req,res) =&gt; &#123; const username = req.body.username const user = &#123; name: username &#125; const accessToken = generateAccessToken(user) const refreshToken = jwt.sign(user, process.env.REFRESH_TOKEN_SECRET) refreshTokens.push(refreshToken) res.json(&#123; accessToken: accessToken, refreshToken: refreshToken &#125;)&#125;)function generateAccessToken(user)&#123; return jwt.sign(user, process.env.ACCESS_TOKEN_SECRET, &#123; expiresIn: &#x27;15s&#x27; &#125;)&#125; 再次测试，能看到 Refresh Token 的返回结果，但我们发现直接用/posts 接口请求，会出现 Forbidden 报错： 此时，我们再写多个函数控制 token 更新： 12345678910111213// 这里的 refreshTokenslet refreshTokens = []app.post(&#x27;/token&#x27;, (req, res) =&gt; &#123; const refreshToken = req.body.token if (refreshToken == null) return res.sendStatus(401) if (!refreshTokens.includes(refreshToken)) return res.sendStatus(403) jwt.verify(refreshToken, process.env.REFRESH_TOKEN_SECRET, (err, user) =&gt; &#123; if (err) return res.sendStatus(403) const accessToken = generateAccessToken(&#123; name: user.name &#125;) res.json(&#123; accessToken &#125;) &#125;)&#125;) request.rest 文件添加一个 /token 进行测试，body的 &quot;token&quot; 暂且留空 1234567###POST http:&#x2F;&#x2F;localhost:3001&#x2F;tokenContent-Type: application&#x2F;json&#123; &quot;token&quot;: &quot;&quot;&#125; 进行以下操作，可以看到效果： 但上述的 GET /posts 操作，因 function generateAccessToken(user)&#123; 函数里过期时间只设置了 15秒，所以15秒后，需要 POST /token 重新获得一个 refresh token 才能继续维持登录状态 登出模块 完整代码在这里 1234app.delete(&#x27;/logout&#x27;, (req, res)=&gt;&#123; refreshTokens = refreshTokens.filter( token =&gt; token !== req.body.token) res.sendStatus(204)&#125;) 用 delete 方法，删除 let refreshTokens = [] 里原本存在的 refresh token，再次请求 /posts 时，会发现已经变为 Forbidden 状态","tags":["JWT","Token"]},{"title":"RenderProps和高阶组件的反向继承","path":"/2021/06/19/【2021-06-19】RenderProps和高阶组件的反向继承/","content":"这两种方法是React里的简单技术，但在具体业务中占有相应的使用场景，十分实用，下面简要的说明一下 Render Props这是一种简单的技术，官网也有解释，简单理解就是将一个组件里的属性attribute作为jsx语法的实现。如以下代码 1234567891011121314151617181920212223242526272829// 父组件export class RenderPropsDemo extends Component &#123; render()&#123; // 1. render 作为组件 &lt;ToggleRenderProps/&gt; 的属性 // 3. 反向在render的回调函数里解构出子组件的属性出来用 return &lt;ToggleRenderProps render=&#123;(&#123;on, toggle, str&#125;) =&gt; &lt;div&gt; &#123; on &amp;&amp; &lt;h1&gt;Hey zidea&lt;/h1&gt; &#125; &#123; on &amp;&amp; &lt;h2&gt;&#123;str&#125;&lt;/h2&gt; &#125; &lt;button onClick=&#123;toggle&#125;&gt;隐藏/显示&lt;/button&gt; &lt;/div&gt; &#125;/&gt; &#125;&#125;// 子组件：class ToggleRenderProps extends Component &#123; state = &#123; on:false &#125; toggle = () =&gt; this.setState(&#123; on:!this.state.on &#125;) render() &#123; // 2. 在子组件设置render里面的属性： const &#123; render &#125; = this.props; return render(&#123; str: &#x27;hehe&#x27;, on: this.state.on, toggle: this.toggle, &#125;) &#125;&#125; 从上面的例子可以看出，子组件 ToggleRenderProps 仅负责单一的传值和控制值和状态的功能，类似回调函数，把该控制的值回传给父组件 RenderPropsDemo 去使用。 当然属性 render 这词不是固定的 任何被用于告知组件需要渲染什么内容的函数 prop 在技术上都可以被称为 “render prop”. 所以，你可以给属性取任意名字，例如 data 1234567891011121314151617// 父组件export class RenderPropsDemo extends Component &#123; render()&#123; return &lt;ToggleRenderProps data=&#123;(&#123;on, toggle, str&#125;) =&gt; &lt;&gt; ... &lt;/&gt;&#125;/&gt;&#125;&#125;// 子组件：class ToggleRenderProps extends Component &#123; ... render() &#123; return this.props.data(&#123; ... &#125;) &#125;&#125; 父组件还可以写为元素内部的模式，如 123456789export class RenderPropsDemo extends Component &#123; render()&#123; return &lt;ToggleRenderProps&gt; &#123;data=&#123;(&#123;on, toggle, str&#125;) =&gt; &lt;&gt; ... &lt;/&gt;&#125; &lt;/ToggleRenderProps&gt; &#125;&#125; 而子组件调用时，就是另一种概念了，可利用 this.props.children 的react自带api进行回传 123456789101112class ToggleRenderProps extends Component &#123; state = &#123; on:false &#125; toggle = () =&gt; this.setState(&#123; on:!this.state.on &#125;) render() &#123; return this.props.children(&#123; str: &#x27;hehe&#x27;, on: this.state.on, toggle: this.toggle, &#125;) &#125;&#125; 以上两种情况，一种在属性上定义的，类似具名函数，而包裹在元素内部，利用 children 进行调用的，类似匿名函数 Rener Props的应用场景就很广泛了，很多库例如路由库React Router，表单校验formik都用了该方法。 正向代理HOC在说反向代理之前，我们先说说正向代理，正向代理其实就是高阶组件 HOC，我们看看两者的区别：普通HOC，即正向代理，简言之就是把一个组件外面包裹了一层新的组件，使其成为一个新组件关于React的HOC和反向代理也可以参考这篇文章 123456789101112131415161718192021222324// 父组件class AAA extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; num: 111 &#125; &#125; render() &#123; return &lt;div num=&#123;this.state.num&#125;&gt;父组件AAA：&#123; this.state.num &#125;&lt;/div&gt; &#125;&#125;// 子组件// 普通HOC，AAA =&gt; props 这部分，代表了 class AAA及其里面的props属性// 相当于把原来的 AAA 提高了一层状态变成了 HOCconst HOC = function (AAA) &#123; return class extends React.Component &#123; render () &#123; return &lt;div style=&#123;&#123;border: &#x27;solid 1px black&#x27;&#125;&#125;&gt; &lt;AAA &#123;...this.props&#125;/&gt; &lt;/div&gt; &#125; &#125;&#125; 子组件也可改写为函数式写法：12345678// 子组件const HOC = AAA =&gt; props =&gt; &#123; return &lt;div style=&#123;&#123;border: &#x27;solid 1px black&#x27;&#125;&#125;&gt; &lt;AAA &#123;...props&#125;/&gt; &lt;/div&gt;&#125;export const Foo = HOC(AAA) 子组件改为装饰器写法，可以省略一步命名的操作，但实际项目中还需要在babel中单独另行配制装饰器语法12345678910@InheritanceInversionHOCexport const HOC = function (AAA) &#123; return class extends React.Component &#123; render () &#123; return &lt;div style=&#123;&#123;border: &#x27;solid 1px black&#x27;&#125;&#125;&gt; &lt;AAA &#123;...this.props&#125;/&gt; &lt;/div&gt; &#125; &#125;&#125; 反向代理 Inheritance Inversion HOC相对于正向代理，则是继承组件自己本身进行重写将上面的子组件进行重写 1234567891011121314151617181920212223242526272829303132333435363738394041// 父组件，即原来的组件class AAA extends React.Component &#123; constructor(props) &#123; super(props) this.state = &#123; num: 111 &#125; &#125; componentDidMount() &#123; console.log(&quot;child component Did Mount&quot;) &#125; clickComponent = () =&gt; console.log(&#x27;clickComponent func&#x27;) render() &#123; return &lt;div num=&#123;this.state.num&#125;&gt;父组件AAA：&#123; this.state.num &#125;&lt;/div&gt; &#125;&#125;// 子组件，即反向继承后的组件const IIHOC = AAA =&gt; class extends AAA &#123; constructor(props) &#123; super(props) this.state = &#123; num: 222 &#125; &#125; componentDidMount() &#123; console.log(&#x27;IIHOC componentDidMount&#x27;) this.clickComponent() // 直接调用 this.clickComponent() 即可，无需通过props进行传参 &#125; render()&#123; return &lt;div&gt; &lt;button onClick=&#123;this.clickComponent&#125;&gt;IIHoc点击见控制台，AAA组件的函数clickComponent在控制台执行了&lt;/button&gt; &#123;/* 下面的&lt;AAA /&gt;会显示父组件的num值， 111 */&#125; &lt;div&gt;&lt;AAA /&gt;&lt;/div&gt; &#123;/* 下面的 &#123;super.render()&#125; 为渲染劫持， 会显示本组件里的值，222 */&#125; &lt;h1&gt;&#123;super.render()&#125;&lt;/h1&gt; &lt;/div&gt; &#125;&#125;export const InheritanceInversionHOC = IIHOC(AAA) 反向代理的解析及实际作用 const IIHOC = AAA =&gt; class extends AAA &#123; 中，extends AAA是继承自己 AAA =&gt;本身 当然，AAA =&gt; 的名字AAA是可以任意替换的，如Comp 生命周期函数 componentDidMount() &#123; &#125;，因为是继承于自身，所以无论父子组件的生命周期函数均会执行 子组件里使用父组件的this.clickComponent()，直接使用即可，无需通过 props 进行传参 反向代理这种做法乍一看好像没有具体用途，但实际操作中，我们可用来做一个原来的复杂页面的多人同时开发，在一些在原有代码基础上开发，不能改变原来旧的代码，则可用反向继承实现二次渲染进行开发，能使新的功能独立成一个模块，方便维护","tags":["React","HOC"]},{"title":"Electron配置React或Vue实践（Vue部分待更新）","path":"/2021/06/08/【2021-06-08】Electron配置React或Vue实践/","content":"本篇介绍在 Electron 中配置 React 或者 Vue 框架开发，毕竟现在前端多是用框架开发，其实已早有现成的模板配置，自己动手用 Webpack 来搭建能更好的熟悉配置的过程。 Electron 基础配置12mkdir &lt;project name&gt; &amp;&amp; cd &lt;project name&gt;npm init -y &amp;&amp; npm install electron@11.1.1 国内直接安装 electron 会比较慢，可以配置淘宝源安装，直接输入： 1npm set registry http://registry.npm.taobao.org 但下载完成后记得改回来npm官方的源，要不然会影响自己 npm 模块的发布： 1npm config set registry https://registry.npmjs.org 可用 npm get registry 查看本地所属的源 项目基础架构package.json 修改改如下： 12345678910111213&#123; &quot;name&quot;: &quot;electron-template&quot;, &quot;version&quot;: &quot;0.0.1&quot;, &quot;description&quot;: &quot;Electron + React 配置项目&quot;, &quot;author&quot;: &quot;余翼&quot;, &quot;main&quot;: &quot;./app/main/electron.js&quot;, &quot;scripts&quot;: &#123; &quot;start:main&quot;: &quot;electron ./app/main/electron.js&quot; &#125;, &quot;dependencies&quot;: &#123; &quot;electron&quot;: &quot;^13.1.1&quot; &#125;&#125; 创建目录结构如下： 123456electron-template |__app |__main # 主进程文件夹，即跑起 Electron 的进程，只有一个， 控制浏览器窗口的操作等 |__electron.js |__index.html |__renderer # 渲染进程文件夹，即渲染页面的进程，前端的界面的js文件,可以有多个文件 让我们修改以下两个文件： 用于启动Electron的窗口：app\\main\\electron.js 12345678910111213141516171819const path = require(&#x27;path&#x27;);const &#123; app, BrowserWindow &#125; = require(&#x27;electron&#x27;);const createWindow = () =&gt; &#123; const mainWindow = new BrowserWindow(&#123; width: 1000, height: 600, // 集成node webPreferences: &#123; nodeIntegration: true, &#125;, &#125;) mainWindow.loadFile(&#x27;index.html&#x27;)&#125;app.whenReady().then(() =&gt; &#123; createWindow() app.on(&#x27;activate&#x27;, () =&gt; if (BrowserWindow.getAllWindows().length === 0) createWindow())&#125;) app\\main\\index.html 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Electron template&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;hello world&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 运行 npm run start:main 可以看到界面： React12npm install reactnpm install react-router react-router-dom react-dom 配置 babelbabel 用来编译es6及jsx代码： 123456789# 核心 babel 插件：npm install -S @babel/polyfillnpm install -D @babel/core @babel/cli# 处理 jsxnpm install -D @babel/preset-env @babel/preset-react @babel/preset-typescript # 缩小 @babel/polyfill 引入时的的库，进行按需引入npm install @babel/plugin-transform-runtime --save --dev# 将ES modules转换为 CommonJSnpm install @babel/plugin-transform-modules-commonjs --save --dev 编写 babel.config.js ，babel官网推荐的这种写法替换以前的 .babelrc，api.cache(true);据官网的说法，可缓存传进来的api，效率更高 12345678910111213141516171819202122232425module.exports = function (api) &#123; api.cache(true); const presets = [ &#x27;@babel/preset-env&#x27;, // 允许使用最新的JS语法，而无须考虑环境的影响 &#x27;@babel/preset-react&#x27;, &#x27;@babel/preset-typescript&#x27;, ] const plugins = [ &#x27;@babel/plugin-transform-runtime&#x27;, [ &#x27;@babel/plugin-transform-modules-commonjs&#x27;, &#123; allowTopLevelThis: true, loose: true, lazy: true &#125; ] ] return &#123; presets, plugins &#125;&#125; 配置 webpack！注意，截至到我写该文为止，安装最新的webpack5和webpack-cli4，并不兼容，运行时会报很多莫名其妙的错误，所以必须指定webpack4和webpack-cli3的版本，其他版本我也试过了，只有这两个版本相容较为稳定 1234# 基础npm i -D webpack@4 webpack-cli@3# 热更新npm i -D webpack-dev-server 我们会配置3个webpack文件，分别是 webpack.base.js – 基础配置 webpack.render.js – 主进程配置 webpack.main.js – 渲染进程配置 所以安装这款插件，用于将下面两个个文件引入 webpack.base.js 中，减少webpack配置的代码: 1npm i -D webpack-merge 安装各种loader，plugin 123npm i -D html-webpack-plugin@4 # 用于读取入口HTML文件npm i -D clean-webpack-plugin # 主进程只编译每次打包好的文件，要这个插件可以每次自动清除上次留下来的文件npm i babel-loader 配置 cross-env 插件，用于执行不同环境的脚本： 1npm i cross-env webpack配置文件webpack.base.js123456789101112131415161718const path = require(&#x27;path&#x27;)const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)module.exports = &#123; resolve: &#123; extensions: [&#x27;.js&#x27;, &#x27;.jsx&#x27;, &#x27;.ts&#x27;, &#x27;.tsx&#x27;], alias: &#123; // 路径别名，可将 import A from &#x27;../../../../../A&#x27;这种导入路径，变成 import A from &#x27;@src/A&#x27; &#x27;@src&#x27;: path.join(__dirname, &#x27;../&#x27;, &#x27;app/renderer&#x27;) &#125; &#125;, module: &#123; rules: [ &#123; test: /\\.(jsx?|tsx?)$/, exclude: /node_modules/, use: &#123; loader: &#x27;babel-loader&#x27;,&#125;&#125;, ] &#125;, plugins: [ new CleanWebpackPlugin(), ],&#125; webpack.main.dev.js123456789101112131415161718192021222324const path = require(&#x27;path&#x27;)const webpack = require(&#x27;webpack&#x27;)const baseConfig = require(&#x27;./webpack.base.js&#x27;)const webpackMerge = require(&#x27;webpack-merge&#x27;)const mainConfig = &#123; entry: path.resolve(__dirname, &#x27;../app/main/electron.js&#x27;), // 构建出不同运行环境的代码 target: &#x27;electron-main&#x27;, output: &#123; filename: &#x27;electron.js&#x27;, path: path.resolve(__dirname, &#x27;../dist&#x27;), &#125;, devtool: &#x27;inline-source-map&#x27;, mode: &#x27;development&#x27;, plugins: [ // 👇 根据启动命令的 node_env，指定构建变量 new webpack.DefinePlugin(&#123; &#x27;process.env.NODE_ENV&#x27;: &#x27;&quot;development&quot;&#x27; &#125;) ],&#125;module.exports = webpackMerge.merge(baseConfig, mainConfig) webpack.render.dev.js1234567891011121314151617181920212223242526272829303132333435const path = require(&#x27;path&#x27;)const webpackMerge = require(&#x27;webpack-merge&#x27;)const baseConfig = require(&#x27;./webpack.base.js&#x27;)const HtmlWebPackPlugin = require(&#x27;html-webpack-plugin&#x27;)const devConfig = &#123; mode: &#x27;development&#x27;, entry: &#123; // app.jsx 入口文件 index: path.resolve(__dirname, &#x27;../app/renderer/App.jsx&#x27;), &#125;, output: &#123; filename: &#x27;[name].[hash].js&#x27;, path: path.resolve(__dirname, &#x27;../dist&#x27;), &#125;, target: &#x27;electron-renderer&#x27;, devtool: &#x27;inline-source-map&#x27;, devServer: &#123; contentBase: path.join(__dirname, &#x27;../dist&#x27;), compress: true, host: &#x27;127.0.0.1&#x27;, port: 7001, hot: true, &#125;, plugins: [ new HtmlWebPackPlugin(&#123; // 以此为模板，自动生成HTML template: path.resolve(__dirname, &#x27;../app/renderer/index.html&#x27;), filename: path.resolve(__dirname, &#x27;../dist/index.html&#x27;), chunks: [&#x27;index&#x27;], &#125;) ]&#125;module.exports = webpackMerge.merge(baseConfig, devConfig) 重组项目结构由于react是在渲染进程中执行，所以，我们将入口文件 index.html 移动到 .app/render/ 文件夹， 并创建 app.jsx文件作为react的入口文件 12mv ./app/main/index.html ./app/renderer/touch ./app/renderer/App.jsx index.html 更改如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;title&gt;Electron Platform&lt;/title&gt; &lt;style&gt; * &#123; margin: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;root&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; App.jsx 1234567891011121314151617import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import &#123; HashRouter as Router, Route, Switch &#125; from &#x27;react-router-dom&#x27;function App() &#123; return ( &lt;Router&gt; &lt;Switch&gt; &lt;Route path=&#x27;/&#x27;&gt; &lt;div&gt;可视化开发平台&lt;/div&gt; &lt;/Route&gt; &lt;/Switch&gt; &lt;/Router&gt; )&#125;ReactDOM.render(&lt;App/&gt;, document.getElementById(&#x27;root&#x27;)) 修改electron主线程配置，配合react做单页面应用既然基础文件结构改了，那么 .app/main/electron.js 也得跟着增加以下配置： 12345678910111213141516...const isDev = () =&gt; &#123; // 对应 webpack.main.dev.js里的 webpack.DefinePlugin的定义 return process.env.NODE_ENV === &#x27;development&#x27;;&#125;...const createWindow = () =&gt; &#123; ... // 利用 if (isDev()) &#123; mainWindow.loadURL(&#x27;http://127.0.0.1:7001&#x27;) &#125; else &#123; mainWindow.loadURL(`file://$&#123;path.join(__dirname, &#x27;./dist/index.html&#x27;)&#125;`) &#125;&#125; package.json 的 script 修改如下 1234&quot;scripts&quot;: &#123; &quot;start:main&quot;: &quot;cross-env NODE_ENV=development webpack --config ./webpack.main.dev.js &amp;&amp; electron ./dist/electron.js&quot;, &quot;start:render&quot;: &quot;webpack-dev-server --config ./webpack.renderer.dev.js&quot;&#125;, 报错处理 如果出现报错：Uncaught ReferenceError: require is not defined，请检查你是否在主进程中添加这行代码，如果添加了，请确保你搭建项目的 Electron 与本应用的版本一致(当前项目的 Electron@^11.1.1) 请自检查一下你的版本是否正确，进入 node_modules，找到 electron，看看 package.json 中的 version 是否是 11.1.1。 Vue现成模板：electron-react-boilerplate 和 electron-vueVue 或 React 均有一个现成的模板可用，这两个该模板共同好处是，只需要一个终端，便可跑起ELectron的主进程和渲染进程，集成度更高，下面我们来看一下这两个模板的配置。 electron-react-boilerplate 两个终端集成原理electron-react-boilerplate 集成两个终端是使用了webpack的一个api webpack deverserve before api，在其源码文件webpack.config.renderer.dev.babel.js里可以看到配置 12345678910111213141516import &#123; spawn, execSync &#125; from &#x27;child_process&#x27;export default merge(baseConfig, &#123; ... before() &#123; console.log(&#x27;Starting Main Process...&#x27;); // 利用node的 spawn api 跑一个 start:main 的子进程 spawn(&#x27;npm&#x27;, [&#x27;run&#x27;, &#x27;start:main&#x27;], &#123; shell: true, env: process.env, stdio: &#x27;inherit&#x27;, &#125;) .on(&#x27;close&#x27;, (code) =&gt; process.exit(code)) .on(&#x27;error&#x27;, (spawnError) =&gt; console.error(spawnError)); &#125;,&#125; 其实很简单，利用了node的child_process api 新开了个进程，让渲染进程跑在该进程之上 webpack.devserver.before api 类似于 webpack 的生命周期函数，还有一个 webpack.devserver.after electron-vue 两个终端集成原理electron-vue 是因为这个的脚本dev-runner.js，利用 Promise.all()，函数进行调用，把两个终端操作融合到一起： 12345678910111213141516...function init () &#123; greeting() // startRender() 利用 Promise.all([startRenderer(), startMain()]) .then(() =&gt; &#123; startElectron() &#125;) .catch(err =&gt; &#123; console.error(err) &#125;)&#125;init()","tags":["React","Webpack","Vue","Electron"]},{"title":"Nginx自学笔记","path":"/2021/05/28/【2021-05-28】Nginx自学笔记/","content":"Ngix这几年太火了，在不久的将来会超过Apache，由于他的底层用epoll，现在多用于服务器端的反向代理和负载均衡 ，强大的并发性能使其基本上没有项目不用他。本篇把 Ngix 的基础配置撸了一遍，记下来以免以后忘了。 安装可查看Nginx官网 连接远程服务器1ssh root@8.134.120.206 输入密码后见到登录了 安装些必要的工具12yum -y install gcc gcc-c++ autoconf pcre-devel make automakeyum -y install wget httpd-tools vim 返回家目创建Nginx主要文件夹123cd ~mkdir nginx-learn &amp;&amp; cd nginx-learnmkdir app backup download logs work app: 放程序源码backup: 备份文件download: 下载文件夹logs: 日志work: 放一些项目文档 安装最新版Nginx需查看Nginx的yum源的版本，运行以下命令： 1yum list | grep nginx yum 源的更新配置，复制Nginx官网这里的配置，我把他粘出来 123456789101112131415[nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true[nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.keymodule_hotfixes=true 1vim /etc/yum.repos.d/nginx.repo 其中 baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ 的 $releasever 我用的是centOS 7的版本，所以我直接改成7，如下： 这次再安装nginx 1234yum install nginxnginx -v# ornginx -V 可以发现更新到最新的nginx版本 查看所有 nginx 目录及配置文件的命令： 1rpm -ql nginx Nginx配置项详解配置项：大部分工作在以下两个文件执行修改：/etc/nginx/nginx.confcd /etc/nginxcat nginx.conf 下面解释一下各配置的作用： 123456789101112131415161718192021222324252627282930313233343536373839user nginx; # 默认用户worker_processes auto; # 进程数，即cpu数error_log /var/log/nginx/error.log notice; # 错误日志pid /var/run/nginx.pid; # 进程events &#123; worker_connections 1024; # 允许最大连接数&#125;http &#123; include /etc/nginx/mime.types; # 文件扩展名的映射表 default_type application/octet-stream; # # 设置日志格式： log_format main &#x27;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#x27; &#x27;$status $body_bytes_sent &quot;$http_referer&quot; &#x27; &#x27;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#x27;; # 访问日志存放位置 access_log /var/log/nginx/access.log main; # 开启默认传输模式 sendfile on; # 减少网络报文数量 #tcp_nopush on; # 超时时间 keepalive_timeout 65; # 开启压缩 #gzip on; # 子配置项 include /etc/nginx/conf.d/*.conf;&#125; 12cd conf.d/vim default.conf 12345678910111213141516171819202122232425262728293031323334353637383940414243server &#123; listen 80; # 监听端口号 server_name localhost; #access_log &#x2F;var&#x2F;log&#x2F;nginx&#x2F;host.access.log main; location &#x2F; &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; index index.html index.htm; &#125; #error_page 404 &#x2F;404.html; # redirect server error pages to the static page &#x2F;50x.html # error_page 500 502 503 504 &#x2F;50x.html; location &#x3D; &#x2F;50x.html &#123; root &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html; &#125; # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ &#123; # proxy_pass http:&#x2F;&#x2F;127.0.0.1; #&#125; # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ &#123; # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME &#x2F;scripts$fastcgi_script_name; # include fastcgi_params; #&#125; # deny access to .htaccess files, if Apache&#39;s document root # concurs with nginx&#39;s one # #location ~ &#x2F;\\.ht &#123; # deny all; #&#125;&#125; 网站根目录我们改动一点根目录的内容： 1vim /usr/share/nginx/html/index.html 运行Nginx开启1nginx 关闭123456# 正常关停nginx -s quit# 几种强制关停nginx -s stopkillall nginx 重载每次改完配置文件后，需要重载nginx，运行一下命令： 1nginx -s reload Linux通用命令执行开启，关闭和重载当然，也可以用Linux的通用命令进行关停或重启： 12345678# 或 Linux通用命令：systemctl start nginx.service# Linux通用命令关停：systemctl stop nginx.service# 重启：systemctl restart nginx.service 查看进程通过查看nginx所有进程确认其已经运行： 1ps aux | grep nginx 查看所有开启的端口号1netstat -tlnp 配置一个404页面，修改一个配置如下： 1vim /etc/nginx/conf.d/default.conf 增加一行，改成这样： 做一个404页面： 1vim /usr/share/nginx/html/404_error.html 写完页面后，地址栏随便输入一地址会发现出现了404页面： 也可以重定向到其他页面，如： 1vim /etc/nginx/conf.d/default.conf 权限控制禁止某些ip不能访问1vim /etc/nginx/conf.d/default.conf 在default.conf加上 deny 113.65.137.13; ，如下，禁止了我本机不可以访问 如果要禁止某一网段的IP不能访问，则写：deny 113.65.137.13/200; ，表示 13 到 200 的所有IP号都不能访问 allow 允许哪些IP可以访问 注意！！！default.conf 文件是从上往下执行，如 deny all; 写在 allow 113.65.137.13;之前，那么113.65.137.13仍不能访问 再次在页面打开，就会发现不能访问页面，出现403页面： 精确匹配路径访问权限 在 location 配置某些路径允许哪些IP 进行访问，添加如下： 都是正则匹配，除了路径，还可匹配不能访问的文件，如 .php 结尾的文件 123456789location =/img &#123; allow all;&#125;location =/admin &#123; deny all;&#125;location ~\\.php$ &#123; deny all;&#125; 虚拟主机配置虚拟主机的好处，可以省钱，一台物理服务器可划分多个空间，每个独立空间可配置独立的虚拟主机，彼此相互隔离，每个虚拟主机可以独立配置web服务 基于端口号配置虚拟主机在 /etc/nginx/conf.d/ 下新建 8001.conf 文件，用于配置 8001 端口的虚拟主机 1vim /etc/nginx/conf.d/8001.conf 基于改虚拟主机配置一个 index.html 文件： 1touch /usr/share/nginx/html/html8001/index.html 写下 1&lt;h1&gt;welcome to port 8001&lt;/h1&gt; 我这里用的是阿里云做演示，所以返回阿里云界面配置8001端口： 基于IP配置虚拟主机同样是改变 8001.conf 文件的 localhost 项的配置 1vim /etc/nginx/conf.d/8001.conf 如： 123456server&#123; listen 80; server_name 192.168.1.200; root /usr/share/nginx/html/html8001; index index.html;&#125; 基于域名配置虚拟主机在阿里云上申请域名，这里不演示，现在 .top 结尾的域名在做促销，起个稍微长点的域名注册只需9元就能注册一年， 我这里注册了 service-learn.top 花了9元 点击域名解析： 输入ip地址，类型选择A类型： 在nginx 配置 1vim /etc/nginx/conf.d/default.conf 将 server_name localhost; 改为 server_name niginx.service-learn.top; 同样的原来的基于端口的虚拟机8001端口也修改：先去阿里云配置解析 nginx2.service-learn.top 地址 1vim /etc/nginx/conf.d/8001.conf 将 server_name localhost; 改为 server_name nginx2.service-learn.top;，改后如下： 123456server&#123; listen 80; server_name nginx2.service-learn.top; root /usr/share/nginx/html/html8001; index index.html;&#125; 反向代理正向代理（Proxy）为客户端做的代理服务器，最形象的解释就是，我们平时用vpn翻墙上外网， 反向代理（Reverse Proxy)为服务端做的代理服务，反向代理最大的好处是 安全性，使用反向代理客户端用户只能通过外来网来访问代理服务器，并且用户并不知道自己访问的真实服务器是那一台，可以很好的提供安全保护。在遭受网络攻击时，会被停留在反向代理上，攻击不到我们真实的服务器。 功能性，反向代理的主要用途是为多个服务器提供负债均衡、缓存等功能。负载均衡就是一个网站的内容被部署在若干服务器上，可以把这些机子看成一个集群，那Nginx可以将接收到的客户端请求“均匀地”分配到这个集群中所有的服务器上，从而实现服务器压力的平均分配，也叫负载均衡。 Nginx的反向代理实操这里我们用 8001 的配置来做反向代理，设置也很简单，修改 vim /etc/nginx/conf.d/8001.conf 如下 我们要访问 8.134.120.206:8001 端口的网站，反向代理到 我的博客 这个网站上 1234567server&#123; listen 8001; server_name 8.134.120.206; location / &#123; proxy_pass http://zyzy.info; &#125;&#125; 打开浏览器显示如下，反向代理设置成功： 反向代理其他配置参数proxy_set_header :在将客户端请求发送给后端服务器之前，更改来自客户端的请求头信息。proxy_connect_timeout:配置Nginx与后端代理服务器尝试建立连接的超时时间。proxy_read_timeout : 配置Nginx向后端服务器组发出read请求后，等待相应的超时时间。proxy_send_timeout：配置Nginx向后端服务器组发出write请求后，等待相应的超时时间。proxy_redirect :用于修改后端服务器返回的响应头中的Location和Refresh。 Nginx适配移动端这里和前端的调整页面布局的自适应不是一个概念，现在的移动端适配，是由于不同域名的切换，引起的适配，所以Nginx在这块就能发挥作用，这种通过Nginx的适配，体验效果会更好，包括淘宝京东在内的国内大型网站都是采用Nginx的方案 我们可以打开浏览器打开京东看到这种适配： 我们来做类似的功能： 建立pc和移动端两个文件夹 1mkdir /usr/share/nginx/pc /usr/share/nginx/mobile 分别编辑 vim /usr/share/nginx/mobile/pc/index.html 和 vim /usr/share/nginx/mobile/mobile/index.html，随便写点内容 编辑Nginx设置如下即可 1234567891011server&#123; listen 8001; server_name 8.134.120.206; location / &#123; root /usr/share/nginx/pc; if ($http_user_agent ~* &#x27;Android|webOS|iPhone|BlackBerry&#x27;) &#123; root /usr/share/nginx/mobile; &#125; index index.html; &#125;&#125; 打开浏览器看看效果 Gzip压缩网页的一种压缩技术，经过Gzip压缩过后的网页，会缩小到原来30%的大小 查看一个网站是否有gzip压缩在站长工具 里查看，直接输入域名即可，例如我们查询 8.134.120.206还没配置gzip压缩 Nginx的gzip压缩功能非常丰富，配置也很简单 1vim /etc/nginx/nginx.conf 添加两行配置如下： 12gzip on;gzip_types text/plain application/javascript text/css; 改完后重载Nginx服务，再用站长工具查询可看到","tags":["后端","Nginx","反向代理"]},{"title":"Dart语法自学笔记（二）","path":"/2021/05/26/【2021-05-26】Dart语法自学笔记（二）/","content":"本篇介绍Dart的函数，类，抽象类，接口，泛型及库的使用 命名函数，匿名函数，箭头函数注意！！箭头函数只能写一个语句 12345678910// void 可省略void func () &#123; print(&#x27;hello world&#x27;);&#125;;// 匿名() &#123; print(123); &#125;;// 箭头func2 () =&gt; print(123); 函数的定义及调用123456789101112int sunNum(int n)&#123; var sum = 0; for (var i =1; i&lt;=n; i++) &#123; sum+=i; &#125; return sum;&#125;void main() &#123; print(sumNum(10)); // 55&#125; 可选参数， 默认参数，命名参数 可选参数，用 [] 括起来，且不能指定类型 默认参数，直接等于一个值就是默认参数，可指定类型 123456789String userInfo (String username, [age, String gender=&#x27;m&#x27;] ) &#123; if (age == null ) return &#x27;$username&#x27;; return &#x27;$username, $age, $gender&#x27;;&#125;void main()&#123; print(userInfo(&#x27;没名字&#x27;, 23)); // 没名字, 23, m&#125; 命名参数，和上面两种类似，如果要指定类型，则必须有默认值 123456789yyy (String username, &#123;age, String gender=&#x27;male&#x27;, job=&#x27;programmer&#x27;&#125;) &#123; if (age == null || job == null) return &#x27;$username, 年龄保密, $gender&#x27;; return &#x27;$username, 年龄保密, $gender, $job&#x27;;&#125;void main () &#123; print(yyy(&#x27;张三&#x27;, age:23, gender: &#x27;female&#x27;)); // 张三, 年龄保密, male programmer&#125; 把函数作为参数传参12345678fn1() =&gt; print(&#x27;fn1&#x27;);fn2(fn)&#123; fn();&#125;void main() &#123; fn2(fn1); // fn1&#125; 类和构造函数 dart为单继承语言 类里的同名方法为构造函数，在构造函数生成之前还能执行其他的操作，写在括号和左花括号之间，如下： 123456789101112131415161718class PersonY &#123; String name; int age; // 且构造函数之前还能进行操作 :name=&#x27;构造函数之前生成的name&#x27;, age=999 .用的少 PersonY(String name, int age): name=&#x27;构造函数之前生成的name&#x27;, age=999 &#123; print(&#x27;构造函数生成之前打印的内容:$&#123;this.name&#125;--$&#123;this.age&#125;&#x27;); this.name=name; this.age=age; &#125;&#125;main() &#123; PersonY p2 = new PersonY(&#x27;李四&#x27;, 45); print(p2.name); // 构造函数生成之前打印的内容:构造函数之前生成的name--999 // 李四&#125; 构造函数可以简写 dart构造函数只有一个，但命名构造函数可以写多个： 123456789101112131415161718class PersonZ &#123; String name; int age; // 简写： PersonZ(this.name, this.age); // 命名构造函数：如果有属性，则一定要传入属性维护起来：例如这里的 this.name 和 this.age PersonZ.named(this.name, this.age) &#123; print(&#x27;这是命名构造函数&#x27;); &#125;&#125;main() &#123; // 调用命名构造函数仍要传参： PersonZ pp = new PersonZ.named(&#x27;xxxx&#x27;, 12); print(pp.name); print(pp.age); &#125; 以上执行输出如下： 这是命名构造函数xxxx12 私有属性dart里并没有 public private protected 等关键字，定义私有属性时，必须： 以 _ 为开头的属性 独立为一个文件，并且 import 到 main 方法里执行，才能达到私有属性的效果 12345678910111213141516171819202122class Pet&#123; // 私有属性前加下划线,并且必须写在独立的文件里: String _name; int age; Pet(this._name, this.age); void printInfo() &#123; // 类里可以直接访问私有属性_name, Pet外部则不能 print(&#x27;$&#123;this._name&#125;====$&#123;this.age&#125;&#x27;); &#125; // 私有方法_run void _run()&#123; print(&#x27;私有方法&#x27;); &#125; // 外部访问私有方法: execRun()&#123; this._run(); &#125;&#125; 调用处： 12345678910111213141516// 1. 必须卸载独立的文件里,私有变量才生效:import &#x27;./08-私有属性/Pet.dart&#x27;;void main() &#123; Pet a = new Pet(&#x27;狗&#x27;, 3); /* // print(a._name); 2. 报错,不能直接访问,_name为私有属性,须要定义方法访问 */ // 非私有属性,可以直接访问: print(a.age); // 3 a.printInfo(); // 狗====3 a.execRun(); //间接调用私有方法&#125; 连缀操作符123456789Person p2 = new Person(&#x27;王五&#x27;, 34);p1..name = &#x27;李四&#x27; ..age = 30 ..printInfo();// 相当于// p1.name = &#x27;李四&#x27;;// p1.age = 30;// p1.printInfo(); 继承可利用 vs code 里的快捷方式进行操作，不用自己写： super 关键字1234567891011121314151617181920212223242526272829303132class Person &#123; String name; num age; Person(this.name, this.age); void printInfo() &#123; print(&#x27;父类的printInfo：$&#123;this.name&#125;---$&#123;this.age&#125;&#x27;); &#125;&#125;class Web extends Person &#123; String gender=&#x27;m&#x27;; Web(String name, num age, // String gender 子类自己的属性： String gender) : // super 可用于继承父类的属性： super(name, age) &#123; // 2. 属于该函数自由的构造函数写这里: this.gender = gender; &#125; run()&#123; // super 可用于继承父类的方法： super.printInfo(); print(&#x27;$&#123;this.name&#125;--$&#123;this.age&#125;--$&#123;this.gender&#125;&#x27;); &#125; // 重写父类存在的方法: @override, 用于标示，可省略 @override void printInfo() &#123; print(&#x27;子类重写的方法：$&#123;this.gender&#125;-$&#123;this.name&#125;&#x27;); &#125;&#125; abstract 抽象类 抽象类： 12345678910abstract class Pet &#123; // 抽象方法，不写方法体： eat(); run(); // 抽象类里的普通方法： printInfo()&#123; print(&#x27;抽象类的普通方法&#x27;); &#125;&#125; 抽象方法被继承时均要重写： 12345678910111213class Dog extends Pet &#123; @override eat() &#123; // TODO: implement eat print(&#x27;小狗吃骨头&#x27;); &#125; @override run() &#123; // TODO: implement run print(&#x27;小狗在跑&#x27;); &#125;&#125; implements 接口 dart里没有接口的概念，用抽象类替代 接口继承时，用关键字 implements 下面的例子举连接数据库的抽象类和实例： 1234567891011121314151617181920212223242526272829303132abstract class Db &#123; String uri=&#x27;&#x27;; //数据库连接地址 add(String data); save(); delete();&#125;class Mysql implements Db &#123; @override String uri; Mysql(this.uri); @override add(String data) &#123; // TODO: implement add print(&#x27;这是mysql的add方法:$&#123;data&#125;&#x27;); &#125; @override delete() &#123; // TODO: implement delete return null; &#125; @override save() &#123; // TODO: implement save return null; &#125; &#125; 一个类可 implements 多个接口： 123456789101112131415abstract class A &#123; printA(); &#125;abstract class B &#123; printB(); &#125;class C implements A, B &#123; @override printA() &#123; // TODO: implement printA return null; &#125; @override printB() &#123; // TODO: implement printB return null; &#125;&#125; mixins 混合 dart 特有的特性，因为dart是单继承，mixins 可让其实现实现类似多继承的特性，一个类可 mixins 多个类 实现该特性用 with 关键字 被 mixins 的父类不能有构造函数，如有构造函数，不能被 mixins 1234567891011// D 和 E 没有构造函数：class D &#123; printD()&#123; print(&#x27;D&#x27;); &#125;&#125;class E &#123; printE()&#123; print(&#x27;E&#x27;); &#125;&#125;class F with D, E &#123;&#125;main() &#123; F f = new F(); f.printD(); // D f.printE(); // E&#125; 有构造函数被 mixins的方法：extends 后再 with, 如下例子: 123456789101112131415161718class Person &#123; String name; int age; // 构造函数: Person(this.name, this.age); void printInfo()&#123; print(&#x27;$&#123;this.name&#125;-$&#123;this.age&#125;&#x27;);&#125;&#125;class G &#123; void printG()&#123;print(&#x27;G&#x27;);&#125; &#125;// P 继承自Person, 且混合G: 因Person中有构造函数Person(this.name, this.age); 故不能直接withclass P extends Person with G &#123; P(String name, int age) : super(name, age);&#125;main() &#123; P p = new P(&#x27;呵呵&#x27;,37); p.printInfo(); // 呵呵-37 p.printG(); // G&#125; 泛型泛型即定义传入和返回类型的校验的一种规范 12345678910// 1. 定义一种泛型，返回的是泛型 T，传入的是类型 &lt;T&gt;，T getData &lt;T&gt; (T value)&#123; print(value);&#125;main() &#123; // 2. 调用泛型方法并指定类型： print(getData &lt;String&gt; (&#x27;你好&#x27;)); // 你好 print(getData &lt;int&gt; (123)); // 123&#125; 泛型用于类 1234567891011121314151617181920// &lt;T&gt; 将检验类型作为参数传入class PrintClass &lt;T&gt; &#123; List list = &lt;T&gt;[]; // T 将检验类型作为参数传入 void add(T value) &#123; this.list.add(value); &#125; void printInfo() &#123; for(var i=0; i&lt;this.list.length; i++) &#123; print(this.list[i]); &#125; &#125;&#125;main() &#123; // 调用时须传入检验的类型 &lt;String&gt; PrintClass p = new PrintClass &lt;String&gt; (); p.add(&#x27;xxxxxxx&#x27;); p.printInfo(); // xxxxxxx&#125; 泛型用于接口 123456789101112131415161718192021abstract class Cache &lt;T&gt; &#123; getByKey(String key); void setByKey(String key, T value);&#125;// 3.1 实现:class FileCache &lt;T&gt; implements Cache &lt;T&gt; &#123; @override getByKey(String key) &#123; return null; &#125; @override void setByKey(String key, T value) &#123; print(&#x27;我是文件缓存, 把key=$&#123;key&#125; value=$&#123;value&#125;的数据写入内存中&#x27;); &#125;&#125;main() &#123; MemoryCache m = new MemoryCache &lt;String&gt; (); m.setByKey(&#x27;index&#x27;, &#x27;123&#x27;); // 我是内存缓存, 把key=index value=123的数据写入内存中&#125; 库的使用 系统内置库，如： 1234567891011121314import &#x27;dart:io&#x27;;import &#x27;dart:convert&#x27;;_getDataFromZhihu() async &#123; var httpClient = new HttpClient(); var uri = new Uri.http(&#x27;news-at.zhihu.com&#x27;, &#x27;/api/3/stories/latest&#x27;); var request = await httpClient.getUrl(uri); var response = await request.close(); return await response.transform(utf8.decoder).join(&#x27; &#x27;);&#125;main(List&lt;String&gt; args) async &#123; var result = await _getDataFromZhihu(); print(result);&#125; 第三方包管理系统pub，官网在这里，功能类似npm的网站，这里举例 http 库的使用 引入，在根目录下写下一个pubspec.yaml 文件，类似 package.json 写下你需要安装的库的版本，如下，可以在这里拷贝其版本号 123456name: xxxdescription: A new flutter module.environment: sdk: &#x27;&gt;=2.10.0 &lt;3.0.0&#x27;dependencies: http: ^0.13.3 执行安装 方法一，在pubspec.yaml 文件写好 dependencies，再执行如下： 1dart pub get 方法二，直接执行以下命令，安装最新版本 1dart pub add http_parser 使用 pub 库是以 package 开头： 1import &#x27;package:http/http.dart&#x27; as http;","tags":["Dart","flutter"]},{"title":"Dart语法自学笔记（一）","path":"/2021/05/25/【2021-05-25】Dart语法自学笔记（一）/","content":"flutter框架从19年开始就火了，主要用于跨端解决方案，一套代码可以覆盖ios，Android和Web，据说法执行效率很高，因去掉了像React Native那样的转译层，直接作用于底层，那必须学起来。 flutter其framework层面调用的是Dart，一新的静态语言，和js炒鸡像，本文从着重讲解Dart的基础语法，包括基础数据解构，常用api及循环，不罗列所有基础语法点，只挑一些有特点演示。 本文的示例代码，放在这个 仓库，本文阐述了 01-06 的代码 安装 Dart官网上有命令行的安装方法，我用win平台，可以直接从这里下载一个SDK安装包，直接下一步下一步安装完成。 安装完成后可以在命令行检验版本是否安装成功： C:\\WINDOWS\\System32&gt;dart –versionDart SDK version: 2.13.0 (stable) (Wed May 12 12:45:49 2021 +0200) on “windows_x64” 我用 vs code 开发，安装 插件 Dart ，Code Runner hello world先来个 hello world，发现和 go 语言语法有点像， 同样是主入口函数 main()&#123;&#125; 主导着整个文件的执行 一个语句完成须强行加 ; 1234// void 可省略void main()&#123; print(&#x27;hello world&#x27;);&#125; 运行 命令行里直接跑 dart &lt;DartDoc&gt;.dart，就可以看到打印的 hello world E:\\study\\code\\2021\\dart-learn&gt;dart 01-hello-world.darthello world 变量 var 常量 const final dart类似 ts 有类型检查功能， 12345String str1 = &#x27;你好&#x27;;print(str1); // 你好int num1 = 123;print(num1); // 123 但 dart 也可自动推断类型，也可以无须声明直接定义，类似 js ： 12345var str = &#x27;hehe&#x27;;print(str); // heheconst e = 2.14;print(e); // 2.14 dart 有一个惰性常量 final，其和普通常量 const 的区别： final 可以只定义，不赋值；const 则不可以 final 只有在运行时才会初始化 例如定义日期，实时生成的，只能用 final 1234final timeNow;timeNow = new DateTime.now();print(timeNow);// 2021-05-24 12:53:04.819814 数据类型dart不像js，不能进行类型自动转换，需要手动进行转换1234print(&#x27;string&#x27; + 1); // 错误// 报错：// Error: A value of type &#x27;int&#x27; can&#x27;t be assigned to a variable of type &#x27;String&#x27;. bool布尔类型为一种单独类型，不同于js，不能转换为0，1 12bool k = true;print(k); // true int double整数类型和浮点类型，没啥好讲的 String 单行字符串。可以单引号&#39; &#39;或双引号&quot; &quot;定义； 换行的字符串。类似 Python ，需用三单引&#39;&#39;&#39; &#39;&#39;&#39; 或 三双引&quot;&quot;&quot; &quot;&quot;&quot;； 占位符用 $，单行或多行字符串均可使用； 123456789String str = &#x27;1223&#x27;;var str2 = &#x27;&#x27;&#x27;line1: heheline2: haha&#x27;&#x27;&#x27;;print(&#x27;$str + $str2&#x27;);print(&#x27;-------------&#x27;);print(str + str2); 结果： 1223 + line1: hehe line2: haha 1223 line1: hehe line2: haha List定义List123456789List l = [&#x27;aaa&#x27;, 3, true];print(l.length); // 3const l2 = [&#x27;vvv&#x27;, &#x27;xx&#x27;];print(&#x27;$l $l2&#x27;); // [aaa, 2, true] [vvv, 5]// 增加元素 .add() 方法：List l3 = &lt;String&gt;[&#x27;foo&#x27;, &#x27;bar&#x27;];l3.add(&#x27;fee&#x27;); // [foo, bar, fee] 创建固定长度List，List.filled(length, 填充的元素)，不能增加数据使用 add()123// &lt;String&gt; 可省略List l5 = List&lt;String&gt;.filled(3, &#x27;&#x27;);print(l5); // [, , ] 常用List方法:将一个现有List反转 .reversed.toList()12345List a = [&#x27;12&#x27;, &#x27;23&#x27;, &#x27;34&#x27;, &#x27;45&#x27;];print(a.reversed);// (45, 34, 23, 12)print(a.reversed.toList());// [45, 34, 23, 12] 替换元素 fillRange(开始, 结束, 替换的元素) 插入 insert(插入位置，插入元素) insertAll(插入位置，插入多个元素)123456789List l = [&#x27;12&#x27;, &#x27;23&#x27;, &#x27;34&#x27;, &#x27;45&#x27;];l.fillRange(1,3, &#x27;c&#x27;);print(l); // [12, c, c, 45] l.insert(3, &#x27;单个元素&#x27;);print(l); // [12, c, c, 单个元素, 45]l.insertAll(2, [&#x27;元素1&#x27;, &#x27;元素2&#x27;]);print(l); // [12, c, 元素1, 元素2, c, 单个元素, 45] List ——&gt; String： .join()；String ——&gt; List：.split()1234567891011List a = [12, &#x27;CC&#x27;, &#x27;zengjia&#x27;, &#x27;hehe&#x27;, &#x27;haha&#x27;, &#x27;CC&#x27;, 67];var b = a.join(&#x27;-&#x27;);print(b);// 12-CC-zengjia-hehe-haha-CC-67print(b is String);// truevar c = b.split(&#x27;-&#x27;);print(c);// [12, CC, zengjia, hehe, haha, CC, 67]print(c is List);// true Set和 js 的 Set 类似 最主要的功能就是去除数组重复内容 没有顺序且不能重复的集合，所以不能通过索引去获取值 12345List l = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];Set ss = new Set();ss.addAll(l);print(ss); // &#123;a, b, c&#125;print(ss.toList()); // [a, b, c] Map类似 js 的obj，定义Map两种方法： 12345var p = &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;:20&#125;;print(p); // &#123;name: zhangsan, age: 20&#125;var p2 = new Map();print(p2); // &#123;&#125; 注意！Map 不能用点 . 运算，只能用属性选择器 [] 1print(p[&#x27;age&#x27;]); // 20 keys.toList() values.toList() 让键或值变成数组12345678Map p = &#123;&#x27;name&#x27;: &#x27;zhangsan&#x27;, &#x27;age&#x27;:20&#125;;print(person.keys.toList()); // [name, age]print(person.values.toList());// [xxx, 20]print(person.entries);// (MapEntry(name: xxx), MapEntry(age: 20)) is 关键字判断类型1234567String str = &#x27;1223&#x27;;if (str is String) print(&#x27;string类型&#x27;);else if(str is int) print(&#x27;int类型&#x27;);else print(&#x27;其他&#x27;);// string类型 可迭代数据的通用方法拼接 .addAll()注意：List 和 Map 拼接可在原来的基础上拼接，其内存指向不变，Set 拼接则需重新 new 一个对象 12345678910111213141516171819// List 拼接：List a = [&#x27;12&#x27;, &#x27;23&#x27;, &#x27;34&#x27;, &#x27;45&#x27;];a.addAll([&#x27;67&#x27;,&#x27;89&#x27;]);print(a);// [12, 23, 34, 45, 67, 89]// Set 拼接：List l = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;];Set ss = new Set();ss.addAll(l);print(ss); // &#123;a, b, c&#125;print(ss.toList()); // [a, b, c]// Map 拼接：Map m = &#123;&#x27;name&#x27;:&#x27;Tom&#x27;,&#x27;Id&#x27;:&#x27;E1001&#x27;&#125;;m.addAll(&#123;&#x27;dept&#x27;:&#x27;HR&#x27;,&#x27;email&#x27;:&#x27;tom@xyz.com&#x27;&#125;);print(m);// &#123;name: Tom, Id: E1001, dept: HR, email: tom@xyz.com&#125; 转换为数组 .toList()见上面提过的例子具有涉及: List， Set 转换为字符串 .toString()List，Set，Map均有此功能 两个特殊运算符dart的运算符，除了这里提到的两种符号，其他和 js 一样 ~/ 和 ~/= 取整符号 ~/，很简单： 1234int a = 12;int b = 5;print(a~/b);// 2 另外，和大多数语言一样，dart里没有三等符号，只有两等 == 是否为空赋值 ??=??= 表示，如果值不为空，则赋值为新值；如果不为空，则用原值； 1234567b??=89;print(b);// 5var c = 45;c ??= 8;print(c);// 45 类型转换 String ——&gt; Number ： int.parse() 和 double.parse()123456789String y = &#x27;123&#x27;;var m = int.parse(y);print(m is int);// trueString u = &#x27;23.345&#x27;;var x = double.parse(u);print(x is double);// true isEmpty 和 isNotEmpty 判断字符串是否为空；isNaN 判断数值是否合法1234567891011var er = &#x27;xxx&#x27;;var xu = 0/0;if(er.isEmpty) print(&#x27;str为空&#x27;); else print(&#x27;str不为空&#x27;);// str不为空if(xu.isNaN)&#123; print(&#x27;xu不合法&#x27;);&#125;else&#123; print(&#x27;xu合法&#x27;);&#125;// xu不合法 循环和 js 相似度达到 95% for， for indart没有 for of 循环，for for in和 js 基本一样的写法 123456789// 例：打印1到9之间所有偶数：for (int i=1; i&lt;=9; i++) &#123; if (i%2 == 0) &#123; print(i); &#125;&#125;// p.s. 如果在同一行写可省略花括号 `&#123;&#125;` for (int i in [1,2,3,4,5,6,7,8,9]) if(i%2 == 0) print(i); 以上均输出： 2468 forEach123456789101112131415161718// 循环Listconst l2 = [2,3];l2.forEach((el) &#123; print(el);&#125;);// 2// 3// 循环MapMap m = &#123;&#x27;a&#x27;:1, &#x27;b&#x27;:2&#125;;m.forEach((key, value) &#123; print(&#x27;$key --- $value&#x27;);&#125;);// a --- 1// b --- 2// 或可写为 箭头函数 =&gt;// m.forEach((key, value) =&gt; print(&#x27;$key --- $value&#x27;)); List， Set 的通用方法: where，any，every一个比较有趣的方法，类似条件语句，用于特定元素的查找和 js 的数组方法的 .some() .every()等方法类似 1234567891011121314151617// ListList l3 = [2,3,6,8];var ll = l3.where((item) =&gt; item &gt;3);print(ll); // (6, 8)print(ll.toList()); // [6, 8]print(l3.any((item) =&gt; item &gt;=3)); // trueprint(l3.every((item) =&gt; item % 2 == 0 || item % 3 == 0 )); // truel3.removeWhere((item) =&gt; item &lt; 7 );print(l3); // [8]// SetSet s2 = &#123;2, 3, 4, 2, 8, 9, 8&#125;;bool ss = s2.any((item) =&gt; item &lt; 1);print(ss); // falseprint(s2.where((item) =&gt; item &gt; 3)); // (4, 8, 9)print(s2.every((item) =&gt; item &lt;= 10)); // true","tags":["Dart","Flutter","跨端"]},{"title":"【2021-05-04】ts在ReactClass和ReactHooks的应用","path":"/2021/05/23/【2021-05-04】TS在ReactClass和ReactHooks中的应用/","content":"对于现行的ES规范，已经具有很好的规范性与可读性，type script虽当下大行其道，其实我觉得意义不算很大，ts最重要的功能就是类型检查，包括 interface, type 等也是一种类型检查，但一不小心就会写成 any script。鉴于将来的项目或者现行的项目可能会用到，这里结合 React Hooks 写个 tsx 版的 demo 自己写的 TypeScript demo，TS基础内容可以翻看该仓库安装新项目，只需带--template typescript参数即可：123create-react-app &lt;app name&gt; --template typescript#or yarn create-react-app &lt;app name&gt; --template typescript 老项目，在原有JSX项目create-react-app基础上增加typescript内容：12345npm install --save typescript @types/node @types/react @types/react-dom @types/jest # or yarn add typescript @types/node @types/react @types/react-dom @types/jest 创建*.d.ts 文件，专门用于各种依赖的声明详细的用法可参考掘金答神这篇文章，我这里简单的说明一下： 外部npm install一个库时: 1declare module &#x27;lodash&#x27; interface 声明 12345interface xxxProps &#123; name: string; age?: number; method(f: string): string;&#125; 初学者的编写利器 —— vs code 中的提示可以利用好 vs code 中自带的提示，例如下面的提示，下面的例子会截图此类提示框： 最外层 index.tsx12345678910111213141516171819import React from &#x27;react&#x27;;import ReactDOM from &#x27;react-dom&#x27;;import App from &#x27;./App&#x27;;// 全局变量，如有：declare global &#123; interface Window &#123; API: any, _store: any &#125;&#125;ReactDOM.render( &lt;React.StrictMode&gt; &lt;App /&gt; &lt;/React.StrictMode&gt;, // HTMLElement 接口： document.getElementById(&#x27;root&#x27;) as HTMLElement); 组件Function 组件1const App: React.FC = () =&gt; null vs code 里的提示： Class 组件123456// 这个没什么好说的，写到烂了export class ClassTS extends React.Component &#123; public render(): React.ReactNode &#123; return null &#125; &#125; propsFunction 组件里的props12345678910111213// 1，直接写：export const TextField: React.FC&lt;&#123; text: string &#125;&gt; = () =&gt; &#123; return &lt;div&gt;&lt;input type=&quot;text&quot;/&gt;&lt;/div&gt;&#125;// 2. 将 &#123; text: string &#125; 独立为接口类：interface Props &#123; text: string&#125;export const TextField: React.FC&lt;Props&gt; = () =&gt; &#123; return &lt;div&gt;&lt;input type=&quot;text&quot;/&gt;&lt;/div&gt;&#125; 其中，接口也可随意扩展及定义子接口，如： 12345678910111213interface Person &#123; firstName: string lastName: string&#125;interface Props &#123; text: string ok?: boolean i?: number fn?: (bob: string) =&gt; string // person: Person&#125; Class 组件里的 props123456789101112131415161718192021// 1，直接写, 两个参数间用逗号或分号隔开均可：export class ClassTS extends React.Component &lt;&#123; text: string, age?: number &#125;&gt; &#123; &#125; // 2. 将props的参数独立为接口类：interface IProps &#123; text: string age?: number&#125;// 3. 顺带一提state，只有interface的写法：interface IState &#123; email: string name: string&#125;export class ClassTS extends React.Component &lt;IProps&gt; &#123; state: IState = &#123; name: &#x27;&#x27;, email: &#x27;&#x27; &#125;&#125; 组件里的函数React特有的类型，React.FormEvent，虚拟DOM把所有原生函数都撸了个遍: 1234handleChange = ( e : React.FormEvent&lt;HTMLInputElement&gt; ) =&gt; &#123; const &#123; name, value &#125; : any = e.target this.setState(&#123; [name]: value &#125;)&#125; 函数组件的 hooksuseState12345678// 或用 | ，不用 ||const [count, setCount] = useState &lt; string | null | &#123; text: string &#125; &gt;(&#123; text: &#x27;hello&#x27; &#125;)// 或 独立为接口：interface TextNode &#123; text: string&#125;const [count, setCount] = useState &lt; number | TextNode &gt;(5) useRef1234// 因为ref的目标是一个input框，所以用 &lt;HTMLInputElement&gt;// 如果打上ref的是&lt;div&gt;&lt;/div&gt;, 则用 &lt;HTMLDivElement&gt;const inputRef = useRef&lt;HTMLInputElement&gt;(null) 另外，handleChange 123456// 如果是Props传过来，并且定义了interface接口，则要注明：interface Props &#123; handleChange: ( event: React.ChangeEvent&lt;HTMLInputElement&gt; ) =&gt; void // 或者如下定义为any，但不建议，因失去了检查的作用： // handleChange: ( event: any ) =&gt; void&#125; useReducer12345678910111213141516171819202122interface Todos &#123; text: string complete: boolean&#125;// type State = Array&lt;Todos&gt;// 或下面这种，更形象化：type State = Todos[]type Actions = &#123; type: &#x27;add&#x27;, text: string &#125; | &#123; type:&#x27;remove&#x27;, idx: number &#125;const TodoReducer = ( state: State, action: Actions ) =&gt; &#123; switch (action.type) &#123; case &#x27;add&#x27;: return [...state, &#123; text: action.text, complete: false &#125;] case &#x27;remove&#x27;: return state.filter((_, i) =&gt; action.idx !== i) default: return state; &#125; &#125;const [todos, dispatch] = useReducer(TodoReducer, []) hooks 的 render props将 hooks 函数 setXXX 作为参数传参，这种props是react独有的，React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt; 123456789101112131415interface Props &#123; children:( count: number, // 将`setCount`作为props进行传参： setCount: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt; // 返回值为React独有的：JSX.Element ) =&gt; JSX.Element | null&#125;export const Counter: React.FC&lt;Props&gt; = (&#123; children &#125;) =&gt; &#123; const [count, setCount] = useState(0) return &lt;div&gt; &#123;children(count, setCount)&#125; &lt;/div&gt;&#125; 另一种，原生的函数在虚拟DOM里的函数： 写的时候 vs code 里的提示：","tags":["React","type script"]},{"title":"Vue2+3自学笔记（一）","path":"/2021/05/19/【2021-05-19】Vue2+3自学笔记（一）/","content":"一直以来，做项目都是用React，最近公司的项目接触到 Vue，这里先捡起多年未碰的 Vue ，写一些demo， 重温一下 Vue2 最简单的用法，并结合掘金的这篇文章，看看 Vue3 的新变化 从 Vue2 开始搬砖，自己写了个TODO List，完整代码在这里，配合Vue官方文档内容，进行本文的阐述 脚手架开始项目安装 1yarn global add @vue/cli 脚手架创建项目并运行： 12vue create &lt;AppName&gt; &amp;&amp; cd &lt;AppName&gt;vue run serve import 后仍要声明组件由于vue是经过实例化的，属性都绑定在this上，以this作为中转，所以 import 后仍要在 component 中声明一次，否则报错： 123456789&lt;script&gt;import Header from &#x27;./components/Header&#x27;export default &#123; components: &#123; Header, &#125;,&#125;&lt;/script&gt; props 属性可以声明数组或对象声明对象时类似ts的类型检验 123456789 props: [&#x27;text&#x27;, &#x27;color&#x27;, &#x27;title&#x27;, &#x27;showAddTask&#x27;]// or props: &#123; text: String, color: String, title: String, showAddTask: Boolean &#125;, 插值表达式插值表达式其值可来自自身文件的 data 属性，也可来自 props 属性 12345678910&lt;button :style=&quot;&#123; background: color &#125;&quot; class=&quot;btn&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/button&gt; props: &#123; text: String &#125;, // or data: &#123; text: &#x27;hehe&#x27; &#125; 还有两个特殊的插值表达式 v-text 用于显示字符串： 123&lt;p v-text=&quot;data&quot;&gt;&lt;/p&gt;data: &#123; text: &#x27;我是要显示的信息&#x27; &#125; v-html 用于显示带HTML的文本： 123&lt;div v-html=&quot;data&quot;&gt;&lt;/div&gt;data: `&lt;a&gt;1111111111&lt;/a&gt;` 实际上，v-html 编译后长这样：123&lt;div&gt; &lt;a&gt;1111111111&lt;/a&gt;&lt;/div&gt; 数值绑定 v-bind: 或简写 :用于绑定样式： 123&lt;button v-bind:style=&quot;&#123; background: color &#125;&quot; class=&quot;btn&quot;&gt;x&lt;/button&gt;&lt;!-- 或简写为 --&gt;&lt;button :style=&quot;&#123; background: color &#125;&quot; class=&quot;btn&quot;&gt;x&lt;/button&gt; 事件绑定 v-on: 或简写 @12345678&lt;button @click=&quot;onClick()&quot; &gt;&#123;&#123; text &#125;&#125;&lt;/button&gt;// 需在 `methods` 里定义绑定事件：methods: &#123; onClick() &#123; // ... &#125;&#125; 还有动态参数的缩写(v2.6.0+)，类似属性选择器，eventName 方法名可动态传入，摘自官网： 1&lt;a @[eventName]=&quot;doSomething&quot;&gt; ... &lt;/a&gt; 循环 v-for 基础打法——用于数组，这里用在了组件 &lt;Task :task=&quot;task&quot; /&gt; 上， 必须绑定key 值， 和 React 一样，由于虚拟DOM Diff算法的原因，key不能用数组下标，必须是不重复的字符串： 123&lt;div v-for=&quot;task in tasks&quot; :key=&quot;task.id&quot;&gt; &lt;Task :task=&quot;task&quot; /&gt;&lt;/div&gt; 还可用于对象obj： 12345678910111213&lt;ul id=&quot;v-for-object&quot; class=&quot;demo&quot;&gt; &lt;li v-for=&quot;value in object&quot;&gt; &#123;&#123; value &#125;&#125; &lt;/li&gt;&lt;/ul&gt;data: &#123; object: &#123; title: &#x27;How to do lists in Vue&#x27;, author: &#x27;Jane Doe&#x27;, publishedAt: &#x27;2016-04-10&#x27; &#125;&#125; 显示为： How to do lists in Vue Jane Doe 2016-04-10 obj也可以用键值对解构显示，他还有第三个参数 index 123&lt;div v-for=&quot;(value, name, index) in object&quot;&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; name &#125;&#125;: &#123;&#123; value &#125;&#125;&lt;/div&gt; 显示为： 0.title:How to do lists in Vue 1.name:Jane Doe 2.value:2016-04-10 你也可以用 of 替代 in 作为分隔符，因为它更接近 JavaScript 迭代器的语法： 1&lt;div v-for=&quot;item of items&quot;&gt;&lt;/div&gt; 事件派发 $emit 与监听 :项目中我们最常用的数据流 子 ——&gt; 父 的方式就是 $emit ——&gt; @ ，如： 发射处，将id也一起发出， $emit(&#39;函数名&#39;, 发射的参数)，其中，发射的参数可以如下，一个简单的id1234&lt;div v-for=&quot;task of tasks&quot; :key=&quot;task.id&quot;&gt; &lt;Task :task=&quot;task&quot; @delete-task=&quot;$emit(&#x27;delete-task&#x27;, task.id)&quot; /&gt;&lt;/div&gt;&lt;script&gt; script 里也要注册该事件：1emits: [&#x27;delete-task&#x27;,], @ 接收该 emit 出来的事件，并命名： 1&lt;Task :task=&quot;task&quot; @delete-task=&quot;$emit(&#x27;delete-task&#x27;, task.id)&quot; /&gt; 在 script 里绑定 deleteTask(id)&#123;&#125; 事件，要注意，这里的 id 即为 $emit 传过来的第二个参数 1234567methods: &#123; deleteTask(id) &#123; if (confirm(&#x27;r u sure?&#x27;)) this.tasks = this.tasks.filter( task =&gt; task.id !== id ) &#125;, ...&#125; 双向数据绑定 v-model 这个是Vue框架的精华所在，抄袭Ng的，在输入处用 v-model 绑定： 123456789&lt;!-- form表单绑定 onSubmit 事件 --&gt;&lt;form class=&quot;add-form&quot; @submit=&quot;onSubmit&quot;&gt; &lt;!-- 搜集输入 --&gt; &lt;input type=&quot;text&quot; name=&quot;text&quot; placeholder=&quot;Add Task&quot; v-model=&quot;text&quot; &gt; &lt;!-- 提交按钮 --&gt; &lt;input type=&quot;submit&quot; value=&quot;Save Task&quot; class=&quot;btn btn-block&quot;&gt;&lt;/form&gt; script 里绑定 onSubmit(e) 事件 12345678910111213141516171819onSubmit(e) &#123; e.preventDefault() if (!this.text) &#123; alert(&#x27;Pls add a task&#x27;) return &#125; const newTask = &#123; id: Math.floor(Math.random() * 100000), text: this.text, day: this.day, reminder: this.reminder &#125; this.$emit(&#x27;add-task&#x27;, newTask) this.text = &#x27;&#x27; this.day = &#x27;&#x27; this.reminder = false&#125;","tags":["Vue"]},{"title":"标签模板（Tagged Template)——ES知识点补漏系列（2）","path":"/2021/05/12/【2021-05-12】标签模板（Tagged-Template-——ES知识点补漏系列（2）/","content":"![](https://cdn.jsdelivr.net/gh/ys558/my-blog-imgs@0.31/articles/标签模板（Tagged Template)——ES知识点补漏系列（2）/cover.jpg) 字符串模板相信大家用的挺多了，这里不赘述，今天解锁字符串模板的另一个功能，标签模板（Tagged Template） 可作为传参用标签模板可用于传参，就行普通函数一样接收参数，请看示例代码： 12345678910const custom = (strings, ...placeholder) =&gt; &#123; console.log(strings) console.log(placeholder)&#125;const firstName = &#x27;呵呵&#x27;const hobby = &#x27;点赞&#x27;// 调用时改为标签模板传参，不用普通函数的()传参custom`my name is $&#123;firstName&#125;, my hobby is $&#123;hobby&#125;` 直接在控制台执行后，会发现结果如下： 12[ &#x27;my name is &#x27;, &#x27;, my hobby is &#x27;, &#x27;&#x27; ][ &#x27;呵呵&#x27;, &#x27;点赞&#x27; ] 我们发现标签模板实际上是一种特殊函数，接收两个参数 @第一个参数 ： 除了${}以外的部分字符串部分@第二个参数 ： ${}里面的部分，可以用解构…接收所有${}的参数，否则则按形参一个个按顺序传入 实际作用下面，我们就这种特殊函数的实际作用举2个例子 给特定文本添加样式标签模板被发明出来的最主要目的就是拼接HTML字符串的，下面我举2个例子： 用于一段文字中添加HTML样式： 12345const a = (arr, ...placeholder) =&gt; arr.reduce((prev, cur, i) =&gt; prev + `&lt;span class=&quot;addColor&quot;&gt;$&#123;placeholder[i-1]&#125;&lt;/span&gt;`+ cur)console.log(a`my name is $&#123;firstName&#125;, my hobby is $&#123;hobby&#125;`)// my name is &lt;span class=&quot;addColor&quot;&gt;呵呵&lt;/span&gt;, my hobby is &lt;span class=&quot;addColor&quot;&gt;点赞&lt;/span&gt; 用于校验HTML里的字符串，防止用户进行XSS攻击 12345678910111213141516171819202122function filterMsg(data) &#123; let ret = data[0] // 直接利用 function 的 arguments 参数进行拼接： for (let i = 1; i &lt; arguments.length; i++) &#123; const arg = String(arguments[i]) ret += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;) ret += data[i] &#125; return ret&#125;// 用户输入：const userInput = &#x27;&lt;script&gt;alert(&quot;123&quot;)&lt;/script&gt;&#x27;// 调用处：const safeMsg = filterMsg`&lt;div&gt;$&#123;userInput&#125; has been send&lt;/div&gt;`console.log(safeMsg)// 输出：// &lt;div&gt;&amp;lt;script&amp;gt;alert(&quot;123&quot;)&amp;lt;/script&amp;gt; has been send&lt;/div&gt;","tags":["ES"]},{"title":"Symbol的理解——ES知识点补漏系列（1）","path":"/2021/05/11/【2021-05-11】Symbol的理解——ES知识点补漏系列（1）/","content":"对于 Symbol 的理解，一直比较陌生，只知道他是 ES6 的语法规范，具体概念，可参考阮一峰老师的 Symbol 文章。这里我就自己的理解写，不讲概念，写一个容易理解的demo，介绍 Symbol 的作用。 传统obj key值的痛点一个亿万富豪，有几个儿子和女儿，还有一私生子，如果此时，我们直接这样定义这个亿万富豪： 12345let billionaire = &#123; son: [&#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27;,], daughter: [&#x27;daughter1&#x27;, &#x27;daughter2&#x27;], son: &#x27;bastard&#x27;&#125; 在控制台我们会发现，私生子bastard 会直接覆盖掉前面的son，这显然是不合适的 于是 Symbol 作为ES里原始的数据类型的作用就出现了 利用 Symbol 添加私生子, 解决痛点正确的做法应该如下，先定义了儿子和女儿们： 1234let billionaire = &#123; son: [&#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27;,], daughter: [&#x27;daughter1&#x27;, &#x27;daughter2&#x27;]&#125; 把私生子 son: &#39;bastard&#39; 单独抽出来，用 Symbol 定义，以下有3种定义方法： 1234567891011121314const son = Symbol(&#x27;son&#x27;)// 1.billionaire[son] = &#x27;bastard&#x27;// 2.let billionaire = &#123; son: [&#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27;,], daughter: [&#x27;daughter1&#x27;, &#x27;daughter2&#x27;], [son] : &#x27;bastard&#x27;&#125;// 3. Object.defineProperty(billionaire, son, &#123; value: &#x27;bastard&#x27; &#125;) 至此，Symbol 的作用很明确了， 由于 JS 的 obj key值为字符串，为了避免 JS 的 obj 中属性名字的冲突而产生 私生子身份神秘，普通new，. 等方法对其无效，只有亿万富翁自己知道由于 Symbol 是原始类型，没有构造函数，不能使用 new 关键字 也不能用 . 运算将其点出来： 私生子的身份确认如何得到保障？作为亿万富豪的私生子，只有亿万富豪自己一个人知道其身份，所以，我们用普通方法是找不到这个私生子的： 而私生子有独特的方法能得到确认，Symbol 为我们提供了几种方法 Object.getOwnPropertySymbols()1234const querySon = Object.getOwnPropertySymbols(billionaire)console.log(querySon)// [Symbol(son)] 多个私生子亿万富豪也可能有不止一个私生子，比如和 ‘知己小秘’ 生了一个私生子，和 ‘灵魂伴侣’ 又生了一个私生子，此时我们可以用 Symbol.for() 定义: 123456const bastard1 = Symbol.for(&#x27;知己小秘&#x27;)billionaire[bastard1] = &#x27;知己小秘儿子1&#x27;const bastard2 = Symbol.for(&#x27;灵魂伴侣&#x27;)billionaire[bastard2] = &#x27;灵魂伴侣儿子1&#x27;console.log(billionaire) 123456&#123; son: [ &#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27; ], daughter: [ &#x27;daughter1&#x27;, &#x27;daughter2&#x27; ], [Symbol(知己小秘)]: &#x27;知己小秘儿子1&#x27;, [Symbol(灵魂伴侣)]: &#x27;灵魂伴侣儿子1&#x27;&#125; Symbol key值同名时，其 value 也能被覆盖掉如果 ‘灵魂伴侣’ 又生多了一个私生子 ‘灵魂伴侣儿子2’ ，会出现什么情况？ 1234const bastard3 = Symbol.for(&#x27;灵魂伴侣&#x27;)billionaire[bastard3] = &#x27;灵魂伴侣儿子2&#x27;console.log(billionaire) 直接打印出来，会发现 value 值 ‘灵魂伴侣儿子2’ 覆盖掉了 ‘灵魂伴侣儿子1’ 123456&#123; son: [ &#x27;son1&#x27;, &#x27;son2&#x27;, &#x27;son3&#x27; ], daughter: [ &#x27;daughter1&#x27;, &#x27;daughter2&#x27; ], [Symbol(知己小秘)]: &#x27;知己小秘儿子1&#x27;, [Symbol(灵魂伴侣)]: &#x27;灵魂伴侣儿子2&#x27;&#125; bastard2 和 bastard3 都是Symbol值，它们都是由同样参数的 Symbol.for 方法生成的key，所以实际上是仍是同一个值: 12console.log(bastard2 === bastard3)// true 查询所有儿女，包括私生子的Key值：Reflect.ownKeys()会以一个数组返回所有 Key 值，包括 Symbol Key 12console.log(Reflect.ownKeys(billionaire))// [ &#x27;son&#x27;, &#x27;daughter&#x27;, Symbol(知己小秘), Symbol(灵魂伴侣) ] Symbol.for() 和 Symbol() 生成的Key值有何不同Symbol.for() 会被登记在全局环境中供搜索，而 Symbol() 就不会，我们改动私生子为 Symbol() 生成，如： 12345678910const bastard1 = Symbol.for(&#x27;知己小秘&#x27;)billionaire[bastard1] = &#x27;知己小秘儿子1&#x27;const bastard2 = Symbol(&#x27;灵魂伴侣&#x27;)billionaire[bastard2] = &#x27;灵魂伴侣儿子1&#x27;console.log(bastard1, Symbol.keyFor(bastard1))console.log(bastard2, Symbol.keyFor(bastard2))// Symbol(知己小秘) 知己小秘// Symbol(灵魂伴侣) undefined 换句话说，Symbol.for() 每次生成前，会检查全局环境中是否存在该Key；Symbol() 则不会，每次调用会每次都生成 12345console.log(Symbol.for(&#x27;a&#x27;) === Symbol.for(&#x27;a&#x27;))// trueconsole.log(Symbol(&#x27;a&#x27;) === Symbol(&#x27;a&#x27;))// false","tags":["ES"]},{"title":"脱离脚手架webpack配制React+typescript项目（二）","path":"/2021/05/08/【2021-05-04】脱离脚手架webpack配制React-typescript项目（二）/","content":"这节会着重介绍TS的配置，这个是对应的 repo 安装jsx 语法里已支持了 TS, 要先安装以下两个库: 1yarn add @types/react @types/react-dom React TS的三种方案1. awesome-typescript-loader 方案 这种不建议, 因为该插件作者已经很久不更新了, 且有些检查不全面 2. ts-loader + fork-ts-checker-webpack-plugin 方案 webpack 编译会通过本地的 typescript , 所以本地必须安装 typescript, 本地 typescript 会调用 tsconfig.json 文件 每次文件改动时, ts-loader 都会进行转移和类型检查, 当文件多时, 速度会变慢 fork-ts-checker-webpack-plugin, 利用该插件开辟一个单独的线程去执行类型检查, 会提高 webpack 的编译速度. 该插件有最低安装要求: Node.js 6.11.5，webpack 4，TypeScript 2.1 和可选的 ESLint 6（其本身要求最低 Node.js 8.10.0） 先安装上述lib 1yarn add -D typescript ts-loader fork-ts-checker-webpack-plugin tsconfig.json 文件配置最主要是以下两项配置： 123456789&#123; &quot;compilerOptions&quot;: &#123; &quot;jsx&quot;: &quot;preserve&quot;, &quot;moduleResolution&quot;: &quot;node&quot;, // &quot;module&quot;: &quot;ESNEXT&quot;, &quot;target&quot;: &quot;es6&quot;, // &quot;esModuleInterop&quot;: true &#125;,&#125; jsx 参数有3个，分别是&#39;react&#39;，&#39;preserve&#39;，&#39;react-native&#39; &#39;react&#39; 模式下，ts 会将 tsx 编译成 jsx 后再将 jsx 编译成 js &#39;preserve&#39; 和 &#39;react-native&#39; 模式下：TS 会将 tsx 编译成 jsx 后，不再将 jsx 编译成 js，保留 jsx 。保留 jsx 时，就需要在webpack.config.js - module - ts-loader 的前面加上 babel-loader 去处理 jsx语法 &quot;moduleResolution&quot; 须配置为 &quot;node&quot;， 否则会报错如下 webpack.config.js 文件配置1234567891011121314151617181920212223242526272829303132333435const ForkTsCheckerWebpackPlugin = require(&#x27;fork-ts-checker-webpack-plugin&#x27;)module.export = &#123; ... module: &#123; rules: [ &#123; test: /\\.(jsx?)$/, exclude: /node_modules/, loader: &#x27;babel-loader&#x27;, options: &#123; cacheDirectory: true, cacheCompression: false &#125; &#125;, &#123; test: /\\.(tsx?)$/, exclude: /node_modules/, use: [ &#x27;babel-loader&#x27;, // 上面的 tsconfig.json 的 compilerOptions.jsx 值为 preserve，这里加上 abel-loader 转译 jsx &#123; loader: &#x27;ts-loader&#x27;, options: &#123; // disable type checker - we will use it in fork plugin transpileOnly: true, &#125;&#125; ]&#125;, ... ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;./src/index.html&quot;, inject: true, &#125;), // fork 一个进程进行检查： new ForkTsCheckerWebpackPlugin() ], &#125; 3. @babel/preset-typescript 方案 比较轻的方案, 直接通过 babel-loader 的插件进行转译, 本地无须安装 typescript , 因此不会去做类型检查 在 tsconfig.json 里配置后在控制台提示语法错误, 但不做强制性检查, 如果写法不严格, 项目也不会编译不通过 这种方案相比起上一种方案少了类型检查, 如果还想做类型检查, 须进行额外本地安装typescript , 且进行额外即配置, 运行 tsc 的命令 1yarn add -D @babel/preset-typescript babel.config.js 里增加该插件: 12345const presets = [ ... &#x27;@babel/preset-typescript&#x27; ... ] webpack.config.js 里相应的 module - rules 要做相应改动: 123rules: [ &#123; test: /\\.(jsx?|tsx?)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125;,] 以上配置, 就能顺利的写出 ts 语法了, 如:app.tsx 123456789101112131415161718192021import React, &#123; Component, FC &#125; from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;interface aProps &#123; data: string&#125;const A: React.FC&lt;aProps&gt; = (&#123;data&#125;) =&gt; &#123; return &lt;div&gt; &#123;data&#125; &lt;/div&gt;&#125;export default class App extends Component &#123; render() &#123; return &lt;div&gt; &lt;A data=&#x27;data from App&#x27; /&gt; &lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) 额外多加监测tsc编译 本地应额外安装 typescript 语法功能： 1yarn add -D typescript 直接 tsc --watch 监听运行 也可以 script 里增加一个命令专门用于监听： 123&#123; &quot;ts-chk&quot;: &quot;tsc --watch&quot;&#125; tsconfig.json 12345678910&#123; &quot;compilerOptions&quot;: &#123; // 不生成编译文件，只做类型检查： &quot;noEmit&quot;: true, // js模块导入方式不做ts的检查： &quot;esModuleInterop&quot;: true, // 使其辨认jsx语法，需重启tsc监听： &quot;jsx&quot;: &quot;preserve&quot;, &#125;&#125; 其中，&quot;esModuleInterop&quot;: true 是由于TS的模块导入方式和JS不同，如果去掉会报以下错误： 按照其提示的错误 TS的导入规则，要改成这样，这显然不符合平时的习惯， 12import * as React from &#x27;react&#x27;import * as ReactDOM from &#x27;react-dom&#x27; 关于模块导入方式可以参考知乎的这篇文章","tags":["React","Webpack","Babel","type script"]},{"title":"脱离脚手架webpack配制React+typescript项目（一）","path":"/2021/05/04/【2021-05-04】脱离脚手架webpack配制React+typescript项目（一）/","content":"如题。以前配过，但没直接支持ts的，这次复习一遍记录下来，webpack 这东西，在项目开始时整一次后经常就很少碰了，更要动手记录下来。 初始化项目1yarn init -y 基础安装配置 webpack 1yarn add webpack webpack-cli@3* -D babel 用于处理ES6+的代码转换 1yarn add -D @babel/core @babel/preset-env babel-loader 配置 less 、 sass 或 postcss 等样式预处理语言，这里三个都给他配上：autoprefixer 可以自动在样式中添加浏览器厂商前缀，避免手动处理样式兼容问题 123456# lessyarn add -D css-loader less less-loader style-loader# sass# postcss 配置处理 HTML 插件 1yarn add -D html-webpack-plugin 配置热更新插件 1yarn add -D webpack-dev-server 新建 src/app.js， webpack.config.js， src/index.html 1mkdir src &amp;&amp; touch src/app.js &amp;&amp; touch webpack.config.js 支持react的配置基础： 1yarn add react-dom react 支持各种语法：@babel/preset-react —— 支持 jsx 语法@babel/plugin-proposal-class-properties —— 支持 class 语法@babel/plugin-proposal-decorators —— 支持装饰器语法 1yarn add -D @babel/preset-react @babel/plugin-proposal-class-properties @babel/plugin-proposal-decorators babel 配置原来的 .babelrc 仅适用于简单单个包的静态配置， babel7+ 版本采用 babel.config.js，可以静态编译 node_modules 我们建议使用babel.config.js格式。babel本身正在使用它。 对于大型项目，babel官方还是建议采用 babel.config.js 文件进行配置，因为 .babelrc 是从每一个文件向上查找配置的，babel.config.js则不会 1touch babel.config.js 编写如下： 1234567891011121314module.exports = function (api) &#123; api.cache(true) const presets = [ [ &#x27;@babel/preset-env&#x27;, &#123; modules: false &#125; ], &#x27;@babel/preset-react&#x27;, ] const plugins = [ [&#x27;@babel/plugin-proposal-decorators&#x27;, &#123; legacy: true &#125;], [&#x27;@babel/plugin-proposal-class-properties&#x27;, &#123; loose: true &#125;] ] return &#123; presets, plugins &#125;&#125; 官方文档 webpack.config.js基础配制配置如下： 12345678910111213141516171819202122232425262728const path = require(&#x27;path&#x27;)const HtmlWebpackPlugin = require(&#x27;html-webpack-plugin&#x27;)module.exports = &#123; entry: &#x27;./src/app.js&#x27;, output: &#123; path: path.resolve(__dirname, &#x27;dist&#x27;), filename: &#x27;bundle.js&#x27;, library: &#x27;ReactByWebpack&#x27;, libraryTarget: &#x27;umd&#x27; &#125;, module: &#123; rules: [ &#123; test: /\\.(jsx?)$/, exclude: /node_modules/, use: [&#x27;babel-loader&#x27;] &#125;, &#123; test: /\\.less$/, exclude: /node_modules/, use: [&#x27;style-loader&#x27;, &#x27;css-loader&#x27;, &#x27;less-loader&#x27;]&#125; ] &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: &quot;./src/index.html&quot;, &#125;) ], devServer: &#123; contentBase: &#x27;./dist&#x27;, port: 8888, compress: true &#125;&#125; 错误解决 ：webpack4 和 webpack-cli4 发生冲突1234567891011121314151617181920212223242526yarn run v1.22.10$ webpack-dev-serverinternal/modules/cjs/loader.js:883 throw err; ^Error: Cannot find module &#x27;webpack-cli/bin/config-yargs&#x27;Require stack:- E:\\study\\code\\tech-blog-code\\2021\\11-webpack-react-ts-config ode_modules\\webpack-dev-server\\bin\\webpack-dev-server.js at Function.Module._resolveFilename (internal/modules/cjs/loader.js:880:15) at Function.Module._load (internal/modules/cjs/loader.js:725:27) at Module.require (internal/modules/cjs/loader.js:952:19) at require (internal/modules/cjs/helpers.js:88:18) at Object.&lt;anonymous&gt; (E:\\study\\code\\tech-blog-code\\2021\\11-webpack-react-ts-config ode_modules\\webpack-dev-server\\bin\\webpack-dev-server.js:65:1) at Module._compile (internal/modules/cjs/loader.js:1063:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:1092:10) at Module.load (internal/modules/cjs/loader.js:928:32) at Function.Module._load (internal/modules/cjs/loader.js:769:14) at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12) &#123; code: &#x27;MODULE_NOT_FOUND&#x27;, requireStack: [ &#x27;E:\\\\study\\\\code\\\\tech-blog-code\\\\2021\\\\11-webpack-react-ts-config\\ ode_modules\\\\webpack-dev-server\\\\bin\\\\webpack-dev-server.js&#x27; ]&#125;error Command failed with exit code 1.info Visit https://yarnpkg.com/en/docs/cli/run for documentation about this command. 解决办法：从 webpack repo issue #1948 里可以找到答案: If you upgrade webpack to 5. *, and webpack cli to 4. *, an error &gt; will be reported: Error: Cannot find module ‘webpack-cli/bin/config-yargs’ Temporary solution:Back off webpack cli to version 3. * for example: “webpack-cli”: “^ 3.3.12” 须要把 webpack-cli 降回3及以下版本 12yarn remove webpack-cliyarn add -D webpack-cli@3 配置入口文件1mkdir src &amp;&amp; touch src/app.js &amp;&amp; touch src/index.html app.js12345678910111213import React, &#123; Component &#125; from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;const A = () =&gt; 123export default class App extends Component &#123; render() &#123; return &lt;div&gt; &lt;A/&gt; &lt;/div&gt; &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.getElementById(&#x27;root&#x27;)) index.html123456789&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&#x27;root&#x27;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 运行添加 script 如下 1234&quot;scripts&quot;: &#123; &quot;dev&quot;: &quot;webpack-dev-server&quot;, &quot;build&quot;: &quot;webpack --mode=production&quot;&#125;, 至此，普通的 React 项目已配置成功，可以尽情写 jsx 了，下一节会继续加上TS配置","tags":["React","Webpack","Babel"]},{"title":"通过ReactHooks直接操作api神库：ReactQuery","path":"/2021/04/26/【2021-04-26】通过ReactHooks直接操作api神库：ReactQuery/","content":"React Query 是一个以react hooks为基础进行异步获取，缓存和更改数据的库，react query仓库文档原文描述： Hooks for fetching, caching and updating asynchronous data in React 换言之，是一个异步处理数据的库。这么重要而且好用的库当然要收入囊中，把他学起来，本篇着重介绍整个项目的构建过程。p.s 该篇的后端服务用这篇 配置的服务端 前端基础服务搭建初始化项目: 1npx create-react-app client &amp;&amp; cd client 安装依赖并运行:其中 react-hook-from @rebass/forms @rebass/preset styled-components react-loader-spinner 均为样式组件 12yarn add react-query react-router-dom react-hook-from @rebass/forms @rebass/preset styled-components react-loader-spinneryarn start 修改src/client.js 文件如下: QueryClientProvider文档 12345678910111213141516171819202122232425262728import React from &#x27;react&#x27;import ReactDOM from &#x27;react-dom&#x27;import &quot;react-loader-spinner/dist/loader/css/react-spinner-loader.css&quot;import App from &#x27;./App&#x27;import &#123; BrowserRouter &#125; from &quot;react-router-dom&quot;import &#123; ThemeProvider &#125; from &quot;styled-components&quot;import preset from &quot;@rebass/preset&quot;// 核心部分: react-queryimport &#123; QueryClientProvider, QueryClient &#125; from &quot;react-query&quot;// 实例化queryClientconst queryClient = new QueryClient()ReactDOM.render( &#123;/* React严格模式，官方文档： https://react.html.cn/docs/strict-mode.html */&#125; &lt;React.StrictMode&gt; &#123;/* QueryClientProvider 可作为全局对象注入，类似 react-redux */&#125; &lt;QueryClientProvider client=&#123;queryClient&#125;&gt; &#123;/* 样式组件： */&#125; &lt;ThemeProvider theme=&#123;preset&#125;&gt; &lt;BrowserRouter&gt; &lt;App /&gt; &lt;/BrowserRouter&gt; &lt;/ThemeProvider&gt; &lt;/QueryClientProvider&gt; &lt;/React.StrictMode&gt;, document.getElementById(&#x27;root&#x27;)) 基础路由模块及基础架构：src/App.js 利用 &#39;react-router-dom&#39; 作为路由的管理器，也是react常见的结构模式： 修改src/App.js文件如下: 12345678910111213141516import &#123; Switch, Route &#125; from &#x27;react-router-dom&#x27;import &#123; BooksList &#125; from &#x27;./BookList&#x27;import &#123; CreateBook &#125; from &#x27;./CreateBook&#x27;import &#123; UpdateBook &#125; from &#x27;./UpdateBook&#x27;function App() &#123; return &lt;&gt; &lt;Switch&gt; &lt;Route path=&#x27;/update-book/:id&#x27;&gt;&lt;UpdateBook/&gt;&lt;/Route&gt; &lt;Route path=&#x27;/create-book&#x27;&gt;&lt;CreateBook /&gt;&lt;/Route&gt; &lt;Route path=&#x27;/&#x27;&gt;&lt;BooksList /&gt;&lt;/Route&gt; &lt;/Switch&gt; &lt;/&gt;&#125;export default App; 获取所有图书创建 src/BookList/index.js 和 src/BookList/BookList.jsx ： src/BookList/index.js: 1export * from &#x27;./BooksList&#x27; src/BookList/BookList.jsx: 123export const BooksList = () =&gt; &#123; return null&#125; 创建图书创建 src/BookList/index.js 和 src/BookList/BookList.jsx : src/CreateBook/index.js: 1export * from &#x27;./CreateBook&#x27; src/CreateBook/CreateBook.jsx: 12345678910export const CreateBook = () =&gt; &#123; return null&#125;``` ### 更新图书 创建 `src/BookList/index.js` 和 `src/BookList/BookList.jsx` : `src/UpdateBook/index.js`:```jsexport * from &#x27;./UpdateBook&#x27; src/UpdateBook/UpdateBook.jsx: 123export const UpdateBook = () =&gt; &#123; return null&#125; 基本结构：1234567891011src |_App.js |_BookList | |_index.js | |_BookList.jsx |_CreateBook | |_CreateBook.jsx | |_index.js |_UpdateBook |_UpdateBook.jsx |_index.js 添加导航栏样式src/shared/NavBar.jsx: 12345678910111213141516171819202122import &#123; Flex, Box, Link as StyledLink, Image &#125; from &#x27;rebass/styled-components&#x27;import &#123; Link &#125; from &#x27;react-router-dom&#x27;import &#123; Container &#125; from &#x27;./Container&#x27;import logo from &#x27;./logo.svg&#x27;export const NavBar = () =&gt; &#123; return &lt;Flex bg=&quot;black&quot; color=&quot;white&quot; justifyContent=&quot;center&quot;&gt; &lt;Container&gt; &lt;Flex px=&#123;2&#125; width=&#x27;100%&#x27; alignItems=&#x27;center&#x27;&gt; &lt;Image size=&#123;20&#125; src=&#123;logo&#125; /&gt; &lt;Link component=&#123;StyledLink&#125; variant=&#x27;nav&#x27; to=&#x27;/&#x27;&gt; React Query CRUD &lt;/Link&gt; &lt;Box mx=&quot;auto&quot;/&gt; &lt;Link component=&#123;StyledLink&#125; variant=&#x27;nav&#x27; to=&#x27;/create-book&#x27;&gt; + Add new book &lt;/Link&gt; &lt;/Flex&gt; &lt;/Container&gt; &lt;/Flex&gt;&#125; src/shared/Container.jsx : 1234567import &#123; Box &#125; from &#x27;rebass/styled-components&#x27;export const Container = (&#123;children&#125;) =&gt; &#123; return &lt;Box sx=&#123;&#123; width: &quot;100%&quot;, maxWidth: 1024, mx: &quot;auto&quot; &#125;&#125;&gt; &#123;children&#125; &lt;/Box&gt;&#125; 返回 src/App.js 把导航栏加上: 123import &#123; NavBar &#125; from &#x27;./shared/NavBar&#x27;&lt;NavBar/&gt; 创建 api.js 接口文件获取并数据：配制文件 .env路径必须在根目录 1REACT_APP_SERVER &#x3D; http:&#x2F;&#x2F;localhost:4800 src/api.js12345export const getAllBooks = async () =&gt; &#123; const response = await fetch(`$&#123;process.env.REACT_APP_SERVER&#125;/books`) if (!response.ok) throw new Error(&#x27;something wrong&#x27;) return response.json()&#125; 【 useQuery 】 应用 —— src/BookList.jsx 中查询所有图书123456789101112131415161718192021222324252627import &#123; useQuery &#125; from &#x27;react-query&#x27;import &#123; Flex &#125; from &#x27;rebass&#x27;import &#123; getAllBooks &#125; from &#x27;../api&#x27;import &#123; Container &#125; from &#x27;../shared/Container&#x27;import Loader from &#x27;react-loader-spinner&#x27;export const BooksList = () =&gt; &#123; // useQuery已经准备好了各种状态，直接调用即可： const &#123; data, error, isLoading, isError &#125; = useQuery(&#x27;books&#x27;, getAllBooks) if (isLoading) return &lt;Container&gt; &lt;Flex&gt; &lt;Loader type=&#x27;ThreeDots&#x27; color=&#x27;#ccc&#x27; height=&#123;30&#125; /&gt; &lt;/Flex&gt; &lt;/Container&gt; if (isError) return &lt;span&gt; Error: &#123;error.message&#125; &lt;/span&gt; return &lt;Container&gt; &lt;Flex flexDirection=&#x27;column&#x27; alignItems=&#x27;center&#x27;&gt; &#123; data.map((&#123;author, title, id&#125;) =&gt; &lt;div key=&#123;id&#125;&gt; &#123;author&#125; - &#123;title&#125; &lt;/div&gt; )&#125; &lt;/Flex&gt; &lt;/Container&gt;&#125; 此时界面可看到效果： 每条记录单独抽离做模块 src\\BookList\\BookItem.jsx123456789101112131415import &#123; Flex, Text, Button, Link as StyledLink &#125; from &#x27;rebass/styled-components&#x27;import &#123; Link &#125; from &#x27;react-router-dom&#x27;export const BookItem = (&#123; author, title, id &#125;) =&gt; &#123; return &lt;Flex p=&#123;3&#125; width=&quot;100%&quot; alignItems=&#x27;center&#x27;&gt; &lt;Link component=&#123;StyledLink&#125; to=&#123;`/update-book/$&#123;id&#125;`&#125; mr=&quot;auto&quot;&gt; &#123; title &#125; &lt;/Link&gt; &lt;Text&gt;&#123;author&#125;&lt;/Text&gt; &lt;Button ml=&quot;3&quot;&gt; remove &lt;/Button&gt; &lt;/Flex&gt;&#125; 从 src\\BookList\\BookList.jsx 导入并取代具体记录的位置12345import &#123; BookItem &#125; from &#x27;./BookItem&#x27;data.map((&#123;author, title, id&#125;) =&gt; &lt;BookItem author=&#123;author&#125; title=&#123;title&#125; id=&#123;id&#125; key=&#123;id&#125;/&gt;) 看看页面的效果： 【 useMutation 】和【 queryClient 】 的应用 —— 删除图书在 src\\api.js 增加删除接口：1234567export const removeBook = async id =&gt; &#123; const response = await fetch(`$&#123;process.env.REACT_APP_API_SERVER&#125;/books/$&#123;id&#125;`, &#123; method: &#x27;DELETE&#x27; &#125;) if (!response.ok) throw new Error(response.json().message) return true&#125; 为删除图书修改界面并在 src\\BookList\\BookList.jsx 里增加相应的 useMutation 和 queryClient 的写法： 1234567891011121314import &#123; removeBook &#125; from &#x27;../api&#x27;const queryClient = useQueryClient()// 将 removeBook 直接传入 useMutationconst &#123; mutateAsync, isLoading &#125; = useMutation(removeBook)const remove = async () =&gt; &#123; await mutateAsync(id) queryClient.invalidateQueries(&#x27;books&#x27;)&#125;&lt;Button ml=&quot;3&quot; onClick=&#123;remove&#125;&gt; &#123; isLoading ? &lt;Loader type=&#x27;ThreeDots&#x27; color=&#x27;#fff&#x27; height=&#123;10&#125; /&gt;: &#x27;Remove&#x27; &#125;&lt;/Button&gt; queryClient.invalidateQueries() 用于清除缓存并刷新页面： 来自中文官方文档的解释： 可以智能地将查询标记为过时的，并使之可用重新获取数据， 简言之，queryClient.invalidateQueries(&#39;books&#39;) 可清除旧 ‘books’ 的显示缓存，并直接刷新最新的 ‘books’ 接口数据，如果不加，页面就不会刷新，需要手动刷新 变更一本图书信息src\\api.js 增加获取一本书的接口：12345678export const getBook = async (&#123; queryKey &#125;) =&gt; &#123; // useQuery 传过来的参数： const [_key, &#123; id &#125;] = queryKey const response = await fetch(`$&#123;process.env.REACT_APP_API_SERVER&#125;/books/$&#123;id&#125;`) if (!response.ok) throw new Error(response.json().message) return response.json()&#125; src\\api.js 增加 updateBook 接口：123456789101112export const updateBook = async (&#123; id, ...data &#125;) =&gt; &#123; const response = await fetch(`$&#123;process.env.REACT_APP_API_SERVER&#125;/books/$&#123;id&#125;`, &#123; method: &#x27;PUT&#x27;, headers: &#123; &#x27;Content-Type&#x27; : &#x27;application/json&#x27; &#125;, body: JSON.stringify(data) &#125;) if (!response.ok) throw new Error(response.json().message) return response.json()&#125; 新建 src\\shared\\BookForm.jsx 用做更新图书的输入界面：12345678910111213141516171819202122232425import &#123; Box, Button &#125; from &#x27;rebass/styled-components&#x27;import &#123; Label, Input &#125; from &#x27;@rebass/forms&#x27;import &#123; useForm &#125; from &#x27;react-hook-form&#x27;import Loader from &#x27;react-loader-spinner&#x27;export const BookForm = (&#123; defaultValues, onFormSubmit, isLoading &#125;) =&gt; &#123; const &#123; register, handleSubmit &#125; = useForm(&#123; defaultValues &#125;) const onSubmit = handleSubmit( data =&gt; &#123; onFormSubmit(data) &#125;) return &lt;form onSubmit=&#123;onSubmit&#125;&gt; &lt;Box sx=&#123;&#123; marginBottom : 3 &#125;&#125;&gt; &lt;Label htmlFor=&quot;title&quot;&gt;Title&lt;/Label&gt; &lt;Input ref=&#123;register&#125; id=&#x27;title&#x27; name=&#x27;title&#x27; type=&#x27;text&#x27; /&gt; &lt;/Box&gt; &lt;Box sx=&#123;&#123; marginBottom : 3 &#125;&#125;&gt; &lt;Label htmlFor=&#x27;author&#x27;&gt;Author&lt;/Label&gt; &lt;Input ref=&#123;register&#125; id=&#x27;author&#x27; name=&#x27;author&#x27; type=&#x27;text&#x27; /&gt; &lt;/Box&gt; &lt;Button&gt; &#123; isLoading ? &lt;Loader type=&#x27;ThreeDots&#x27; color=&#x27;#fff&#x27; height=&#123;10&#125; /&gt; : &#x27;Submit&#x27; &#125; &lt;/Button&gt; &lt;/form&gt;&#125; src\\UpdateBook\\UpdateBook.jsx 更改如下： 12345678910111213141516171819202122232425262728293031323334353637383940import Loader from &quot;react-loader-spinner&quot;import &#123; useMutation, useQuery &#125; from &quot;react-query&quot;import &#123; useHistory, useParams &#125; from &quot;react-router-dom&quot;import &#123; Box, Flex, Heading &#125; from &quot;rebass/styled-components&quot;import &#123; getBook, updateBook &#125; from &quot;../api&quot;import &#123; BookForm, Container &#125; from &quot;../shared&quot;export const UpdateBook = () =&gt; &#123; const &#123; id &#125; = useParams() const history = useHistory() // 获取单本书的接口： const &#123; data, error, isLoading, isError &#125; = useQuery([&#x27;book&#x27;, &#123;id&#125;], getBook) // 更改单本书 useMutation const &#123; mutateAsync, isLoading: isMutating &#125; = useMutation(updateBook) // 将数据传给后端： const onFormSubmit = async data =&gt; &#123; await mutateAsync(&#123; ...data, id &#125;) history.push(&#x27;/&#x27;) &#125; if ( isLoading ) return &lt;Container&gt; &lt;Flex&gt; &lt;Loader type=&#x27;ThreeDots&#x27; color=&#x27;#ccc&#x27; height=&#123;30&#125; /&gt; &lt;/Flex&gt; &lt;/Container&gt; if ( isError ) return &lt;Container&gt; &lt;Flex py=&#x27;5&#x27; justifyContent=&#x27;center&#x27;&gt; Error: &#123;error.message&#125; &lt;/Flex&gt; &lt;/Container&gt; return &lt;Container&gt; &lt;Box sx=&#123;&#123; py: 3 &#125;&#125;&gt; &lt;Heading sx=&#123;&#123; marginBottom: 3 &#125;&#125;&gt;Update Book&lt;/Heading&gt; &lt;BookForm defaultValues=&#123;data&#125; onFormSubmit=&#123;onFormSubmit&#125; isLoading=&#123;isMutating&#125; /&gt; &lt;/Box&gt; &lt;/Container&gt;&#125; 新建 src\\shared\\index.js 将所有共用组件导出： 123export * from &#x27;./Container&#x27;export * from &#x27;./BookForm&#x27;export * from &#x27;./NavBar&#x27; 看看页面的效果： 新建一本图书src\\api.js 里添加1234567891011export const createBook = async (data) =&gt; &#123; const response = await fetch(`$&#123;process.env.REACT_APP_API_SERVER&#125;/books/`, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;, body: JSON.stringify(data) &#125;) if (!response.ok) throw new Error(response.json().message) return response.json()&#125; 更改创建图书界面 src\\CreateBook.jsx 如下：12345678910111213141516171819202122import &#123; useMutation &#125; from &quot;react-query&quot;import &#123; useHistory &#125; from &quot;react-router-dom&quot;import &#123; Box, Heading &#125; from &quot;rebass&quot;import &#123; createBook &#125; from &quot;../api&quot;import &#123; BookForm, Container, &#125; from &#x27;../shared&#x27;export const CreateBook = () =&gt; &#123; const history = useHistory() const &#123; mutateAsync, isLoading &#125; = useMutation(createBook) const onFormSubmit = async data =&gt; &#123; await mutateAsync(data) history.push(&#x27;/&#x27;) &#125; return &lt;Container&gt; &lt;Box sx=&#123;&#123; py: 3 &#125;&#125;&gt; &lt;Heading sx=&#123;&#123; marginBottom: 3 &#125;&#125;&gt;Create New Book&lt;/Heading&gt; &lt;BookForm onFormSubmit=&#123;onFormSubmit&#125; isLoading=&#123;isLoading&#125; /&gt; &lt;/Box&gt; &lt;/Container&gt;&#125; 看看页面的效果：","tags":["React Query"]},{"title":"SwaggerUI通过swagger-jsdoc在node里的应用和配置","path":"/2021/04/25/【2021-04-25】SwaggerUI通过swagger-jsdoc在node里的应用和配置/","content":"SwaggerUI，在Java里应该是常用工具，能根据api文件自动生成网页版的api文档界面，感觉挺有意思的，其实他支持各种语言，本篇分享一下在node里的简单配置方法，顺手搭建了个简单的服务。（p.s. 本篇后续有续篇，利用本篇的服务，介绍一下前端的状态管理组件React Query的玩法，配合本篇搭建的服务使用。） 基本架构初始化项目，安装依赖: 123npm init -yyarn add express lowdb morgan nanoid cors swagger-jsdoc swagger-ui-expresstouch index.js index.js 如下： 12345678910111213141516171819202122232425const express = require(&quot;express&quot;);const cors = require(&quot;cors&quot;);const morgan = require(&quot;morgan&quot;);const low = require(&quot;lowdb&quot;);const PORT = process.env.PORT || 4800const FileSync = require(&quot;lowdb/adapters/FileSync&quot;)// 用 db.json 文件充当数据库: const adapter = new FileSync(&quot;db.json&quot;)const db = low(adapter)db.defaults(&#123; books: [] &#125;).write()const app = express()app.db = dbapp.use(cors())app.use(express.json())app.use(morgan(&quot;dev&quot;))app.listen(PORT, () =&gt; console.log(`the server run on port $&#123;PORT&#125;`)) 试着运行一下，会发现生成了一个 db.json 文件，总体目录如下： server |__node_modules/ |__db.json |__index.js |__package.json |__yarn.lock 建立路由1mkdir route &amp;&amp; cd route &amp;&amp; touch books.js books.js 如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445const express = require(&quot;express&quot;);const router = express.Router()const &#123; nanoid &#125; = require(&quot;nanoid&quot;);const idLength = 8router.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const books = req.app.db.get(&#x27;books&#x27;) res.send(books)&#125;)router.get(&#x27;/:id&#x27;, (req, res) =&gt; &#123; const book = req.app.db.get(&#x27;books&#x27;).find(&#123; id: req.params.id &#125;).value() if (!book) res.send(404) res.send(book)&#125;)router.post(&#x27;/&#x27;, (req, res) =&gt; &#123; try &#123; const book = &#123; id: nanoid(idLength), ...req.body &#125; req.app.db.get(&#x27;books&#x27;).push(book).write() res.send(book) &#125;catch (error) &#123; return res.status(500).send(error) &#125;&#125;)router.put(&#x27;/:id&#x27;, (req, res) =&gt; &#123; try &#123; req.app.db.get(&#x27;books&#x27;).find(&#123; id: req.params.id &#125;).assign(req.body).write() res.send(req.app.db.get(&#x27;books&#x27;)).find(&#123;id: req.params.id&#125;) &#125;catch (error) &#123; return res.status(500).send(error) &#125;&#125;)router.delete(&#x27;/:id&#x27;, (req, res) =&gt; &#123; req.app.db.get(&#x27;books&#x27;).remove(&#123; id: req.params.id &#125;).write() res.sendStatus(200)&#125;)module.exports = router 应用SwaggerUI:在 index.js 里引用 SwaggerUI，添加如下配置： 12345678910111213141516171819202122const swaggerUI = require(&quot;swagger-ui-express&quot;);const swaggerJsDoc = require(&quot;swagger-jsdoc&quot;);const booksRouter = require(&quot;./route/books&quot;);const specs = swaggerJsDoc(&#123; definition: &#123; // 必须参数，不填则没有权限，填的话也只支持 3.0.n openapi: &quot;3.0.0&quot;, // 一些描述，可选： info: &#123; title: &quot;Library API&quot;, version: &quot;1.0.0&quot;, description: &quot;A simple Express Library API&quot; &#125;, servers: [&#123; url: &quot;http://localhost:4800&quot;&#125;], &#125;, apis: [&quot;./route/*.js&quot;]&#125;)app.use(&quot;/api-docs&quot;, swaggerUI.serve, swaggerUI.setup(specs))app.use(&#x27;/books&#x27;, booksRouter) 可在界面看到： 自动生成api文档页面：参照其文档，比较有意思的是swagger-jsdoc，他将多行注释里的api配置转换为页面的文档配置，我们将 route/books.js 改写为以下格式： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181/** * @swagger * components: * schemas: * Book: * type: object * required: * - title * - author * properties: * id: * type: string * description: The auto-generated id of the book * title: * type: string * description: The book title * author: * type: string * description: The book author * example: * id: d5fE_asz * title: The New Turing Omnibus * author: Alexander K. Dewdney *//** * @swagger * tags: * name: Books * description: The books managing API *//** * @swagger * /books: * get: * summary: Returns the list of all the books * tags: [Books] * responses: * 200: * description: The list of the books * content: * application/json: * schema: * type: array * items: * $ref: &#x27;#/components/schemas/Book&#x27; */router.get(&#x27;/&#x27;, (req, res) =&gt; &#123; const books = req.app.db.get(&#x27;books&#x27;) res.send(books)&#125;)/** * @swagger * /books/&#123;id&#125;: * get: * summary: Get the book by id * tags: [Books] * parameters: * - in: path * name: id * schema: * type: string * required: true * description: The book id * responses: * 200: * description: The book description by id * contents: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; * 404: * description: The book was not found */router.get(&#x27;/:id&#x27;, (req, res) =&gt; &#123; const book = req.app.db.get(&#x27;books&#x27;).find(&#123; id: req.params.id &#125;).value() if (!book) res.send(404) res.send(book)&#125;)/** * @swagger * /books: * post: * summary: Create a new book * tags: [Books] * requestBody: * required: true * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; * responses: * 200: * description: The book was successfully created * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; * 500: * description: Server Error */router.post(&#x27;/&#x27;, (req, res) =&gt; &#123; try &#123; const book = &#123; id: nanoid(idLength), ...req.body &#125; req.app.db.get(&#x27;books&#x27;).push(book).write() res.send(book) &#125;catch (error) &#123; return res.status(500).send(error) &#125;&#125;)/** * @swagger * /books/&#123;id&#125;: * put: * summary: Update the book by the id * tags: [Books] * parameters: * - in: path * name: id * schema: * type: string * required: true * description: The book id * requestBody: * required: true * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; * responses: * 200: * description: The Book was updated * content: * application/json: * schema: * $ref: &#x27;#/components/schemas/Book&#x27; */router.put(&#x27;/:id&#x27;, (req, res) =&gt; &#123; try &#123; req.app.db.get(&#x27;books&#x27;).find(&#123; id: req.params.id &#125;).assign(req.body).write() res.send(req.app.db.get(&#x27;books&#x27;)).find(&#123;id: req.params.id&#125;) &#125;catch (error) &#123; return res.status(500).send(error) &#125;&#125;)/** * @swagger * /books/&#123;id&#125;: * delete: * summary: Update the book by the id * tags: [Books] * parameters: * - in: path * name: id * schema: * type: string * required: true * description: The book id * responses: * 200: * description: The Book was deleted * 404: * description: The Book was not found */router.delete(&#x27;/:id&#x27;, (req, res) =&gt; &#123; req.app.db.get(&#x27;books&#x27;).remove(&#123; id: req.params.id &#125;).write() res.sendStatus(200)&#125;)module.exports = router 重跑服务，可以发现以下界面： swagger-jsdoc 是通过 openapi 的3.0版本进行的改动，传统的 openapi 是通过独立的 json 文件对 swagger进行配置，不在本篇讨论范围，感兴趣的可以看看这篇国外的demo","tags":["Swagger UI","后端","Nodejs","swagger-jsdoc"]},{"title":"无限滚动和懒加载通过IntersectionObserver和React_Hooks实现","path":"/2021/04/23/【2021-04-23】无限滚动和懒加载通过IntersectionObserver和React_Hooks实现/","content":"用React Hooks做项目有一段时间了，炒鸡喜欢，这里结合 IntersectionObserver 原生js api及各种hooks，做个简单的无限滚动+懒加载页面，关于 IntersectionObserver， 阮大神的这篇博客文章里有非常详尽的描述（p.s. data用到数据接口需科学上网） 基础架构 用 create-react-app 构建项目后装 axios，App.js修改如下，页面呈现如下简单效果，即在输入框输入某一书籍关键字时，会出现对应所有的书籍列表： 1234567891011const App = () =&gt; &#123; return &lt;div&gt; &lt;input type=&quot;text&quot;/&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;div&gt;Error&lt;/div&gt; &lt;/div&gt;&#125; 自定义 custom hooks 作为异步请求数据：根据hooks习惯，名字用use开头： 1234567891011121314151617181920import &#123; useState, useRef, useCallback &#125; from &#x27;react&#x27;/** * @params * input 输入框输入需要查询的字段 * pageNum 页码，如果页面一页展示不玩，会持续添加pageNum*/export const useBookSearch = (query, pageNum) =&gt; &#123; useEffect(() =&gt; &#123; axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://openlibrary.org/search.json&#x27;, params: &#123; q: query, page: pageNum &#125;, &#125;).then(res =&gt; &#123; // 远程获取数据，暂时控制台打印： console.log(res.data) &#125;) &#125;, [query, pageNum]) return null&#125; 在 App.js 里引入自定义hooks 123456789101112const App = () =&gt; &#123; useBookSearch(query, pageNum) return &lt;div&gt; &lt;input type=&quot;text&quot;/&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;div&gt;Error&lt;/div&gt; &lt;/div&gt;&#125; 实现动态效果 继续改造 App.js query 和 pageNum两个参数需要在本页进行变动，于是加入 useState 钩子 1234567891011121314151617181920212223import &#123; useState, useRef, useCallback &#125; from &#x27;react&#x27;const App = () =&gt; &#123; const [query, setInput] = useState(&#x27;&#x27;) const [pageNum, setPageNum] = useState(1) const handleSearch = e =&gt; &#123; setInput(e.target.value) // 重新输入查询字段后，页数重新设置为1： pageNum(1) &#125; useBookSearch(query, pageNum) return &lt;div&gt; &lt;input type=&quot;text&quot; onChange=&#123;handleSearch&#125;/&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Title&lt;/div&gt; &lt;div&gt;Loading...&lt;/div&gt; &lt;div&gt;Error&lt;/div&gt; &lt;/div&gt;&#125; query 通过输入框改变，传递给 useBookSearch(query, pageNum)，控制台能看到请求回来的数据，如下演示，但这种请求是实时的，即每输入一个字符就会请求一次，会浪费性能，必须优化 useBookSearch 优化请求性能： axios 有个参数 CancelToken，可取消重复请求，做如下改动： 123456789101112131415161718192021useEffect(() =&gt; &#123; setLoading(true) setError(false) // 定义取消变量 let cancel axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://openlibrary.org/search.json&#x27;, params: &#123; q: query, page: pageNum &#125;, // 执行取消变量： cancelToken: new axios.CancelToken(c =&gt; cancel = c) &#125;).then(res =&gt; console.log(res.data) ).catch(e =&gt; &#123; if (axios.isCancel(e)) return setError(true) &#125;) // 最后，useEffect里必须删除new出来的实例 return () =&gt; cancel()&#125;, [query, pageNum]) 改造完成后，继续重新尝试： 页面UI实现： 针对界面实现的丰富，我们对 useBookSearch 函数继续做改造，分别增加以下状态： loading : 读取 error : 获取数据错误 hasMore : 判断是否还有数据 books : 获取到的所有书籍的数据 12345678910111213141516171819202122232425262728293031323334353637383940414243const useBookSearch = (query, pageNum) =&gt; &#123; const [loading, setLoading] = useState(true) const [error, setError] = useState([]) const [books, setBooks] = useState([]) const [hasMore, setHasMore] = useState(false) useEffect(() =&gt; &#123; setLoading(true) setError(false) let cancel axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://openlibrary.org/search.json&#x27;, params: &#123; q: query, page: pageNum &#125;, cancelToken: new axios.CancelToken(c =&gt; cancel = c) &#125;) .then(res =&gt; &#123; // 将后面请求回来books加入现有数组中：用Set去重： setBooks(prevBooks =&gt; &#123; return [...new Set([...prevBooks, ...res.data.docs.map(b =&gt; b.title)])] &#125;) // 每次只能显示满屏的数据，如果请求的数据没显示完 setHasMore(res.data.docs.length &gt; 0) // 则把loading显示为false setLoading(false) &#125;) .catch(e =&gt; &#123; if (axios.isCancel(e)) return // 设置错误： setError(true) &#125;) return () =&gt; cancel() &#125;, [query, pageNum]) // 每次改变 useEffect(() =&gt; &#123; setBooks([]) &#125;, [query]) // 将上面的状态一概导出，给App函数用： return &#123; loading, error, books, hasMore &#125;&#125; 改造主页面的 App 组件: 123456789101112131415161718192021222324import &#123; useState &#125; from &#x27;react&#x27;const App = () =&gt; &#123; const [query, setInput] = useState(&#x27;&#x27;) const [pageNum, setPageNum] = useState(1) // 将状态从useBookNameSearch解构出来： const &#123; books, hasMore, loading, error &#125; = useBookSearch(query, setPageNum) const handleSearch = e =&gt; &#123; setInput(e.target.value) pageNum(1) &#125; return ( &lt;&gt; &lt;input type=&quot;text&quot; onChange=&#123;handleSearch&#125;/&gt; &#123; books.map((book, index) =&gt; &lt;div key=&#123;book&#125;&gt;&#123;book&#125;&lt;/div&gt;)&#125; &lt;div&gt;&#123; loading &amp;&amp; &#x27;Loading...&#x27; &#125;&lt;/div&gt; &lt;div&gt;&#123; error &amp;&amp; &#x27;Error&#x27; &#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App; 最后，继续做翻页的部分，我们要实现的效果是，滚动到页面最下面，则自动触发loading和翻页，在 App 里用到useRef 钩子，检测到滚动到最后一行 用到 useCallback 钩子，具有缓存作用，依赖改变才重新渲染。 用到 IntersectionObserver api, 第一个参数为回调函数，其 entries 为检测到的触发的点 12345678910111213const last = useRef()const lastRecordRef = useCallback( node =&gt; &#123; if (loading) return if (observer.current) observer.current.disconnect() observer.current = new IntersectionObserver(entries =&gt; &#123; // entries[0].isIntersecting检测可见页面内是否需要调用新的数据： if( entries[0].isIntersecting &amp;&amp; hasMore ) &#123; setPageNum(prevPageNumber =&gt; prevPageNumber + 1) &#125; &#125;) // 检测是否最后一个节点node if (node) observer.current.observe(node)&#125;, [loading, hasMore] 控制台打印了entries[0].isIntersecting，当出现Loading状态时，该值为true, 单当完成加载后为false，如下： 贴出完整代码： App.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344import useBookSearch from &#x27;./useBookSearch&#x27;import &#123; useState, useRef, useCallback &#125; from &#x27;react&#x27;function App() &#123; const [query, setQuery] = useState(&#x27;&#x27;) const [pageNumber, setPageNumber] = useState(1) const &#123; books, hasMore, loading, error &#125; = useBookSearch(query, pageNumber) const observer = useRef() const lastBookElementRef = useCallback(node =&gt; &#123; if (loading) return if (observer.current) observer.current.disconnect() observer.current = new IntersectionObserver(entries =&gt; &#123; // detected is it the last one: if( entries[0].isIntersecting &amp;&amp; hasMore ) &#123; setPageNumber(prevPageNumber =&gt; prevPageNumber + 1) &#125; &#125;) if (node) observer.current.observe(node) &#125;, [loading, hasMore]) const handleSearch = e =&gt; &#123; setQuery(e.target.value) setPageNumber(1) &#125; return ( &lt;&gt; &lt;input type=&quot;text&quot; onChange=&#123;handleSearch&#125;/&gt; &#123; books.map( (book, index) =&gt; &#123; if (books.length === index + 1) &#123; return &lt;div ref=&#123;lastBookElementRef&#125; key=&#123;book&#125;&gt;&#123;book&#125;&lt;/div&gt; &#125;else&#123; return &lt;div key=&#123;book&#125;&gt;&#123;book&#125;&lt;/div&gt; &#125; &#125;)&#125; &lt;div&gt;&#123; loading &amp;&amp; &#x27;Loading...&#x27; &#125;&lt;/div&gt; &lt;div&gt;&#123; error &amp;&amp; &#x27;Error&#x27; &#125;&lt;/div&gt; &lt;/&gt; );&#125;export default App; useBookSearch 独立成一个文件 12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123; useEffect, useState &#125; from &#x27;react&#x27;import axios from &#x27;axios&#x27;const useBookSearch = (query, pageNumber) =&gt; &#123; const [loading, setLoading] = useState(true) const [error, setError] = useState([]) const [books, setBooks] = useState([]) const [hasMore, setHasMore] = useState(false) useEffect(() =&gt; &#123; setLoading(true) setError(false) let cancel axios(&#123; method: &#x27;GET&#x27;, url: &#x27;http://openlibrary.org/search.json&#x27;, params: &#123; q: query, page: pageNumber &#125;, cancelToken: new axios.CancelToken(c =&gt; cancel = c) &#125;) .then(res =&gt; &#123; setBooks(prevBooks =&gt; &#123; return [...new Set([...prevBooks, ...res.data.docs.map(b =&gt; b.title)])] &#125;) setHasMore(res.data.docs.length &gt; 0) setLoading(false) &#125;) .catch(e =&gt; &#123; if (axios.isCancel(e)) return setError(true) &#125;) return () =&gt; cancel() &#125;, [query, pageNumber]) useEffect(() =&gt; &#123; setBooks([]) &#125;, [query]) return &#123; loading, error, books, hasMore &#125;&#125;export default useBookSearch","tags":["React","React Hooks","IntersectionObserver"]},{"title":"发现一免费CDN，我用来存该站的图","path":"/2021/04/22/【2021-04-22】发现一免费CDN，我用来存该站的图/","content":"先上网址：https://www.jsdelivr.com/?docs=gh 说说我遇到的痛点，该站采用hexo生成，在网上搜了一圈，建议用hexo-asset-image工具，但_post文件夹里会多出一个文件夹专门用于存储图片，且该工具还有一点bug，虽然最后也解决了，但总有点不爽。思前想后，还是新建一个放图片的git repo最省事，如果直接贴仓库，可能速度有点慢，于是就得找CDN了。 CDN （Content Delivery Network/Content Distribution Network）内容分发网络。是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、影片、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。 选择了GitHub版本，操作如下： 首先，新建一个GitHub仓库：例如我自己的图片的仓库： https://github.com/ys558/my-blog-imgs 将你要放网络的图片推到你自己仓库 关键的一步：给仓库版本打标签，两个方法：方法一、命令行, 例如： 1git tag -a v1.4 -m &quot;my version 1.4&quot; 命令行更详细的操作可参考这里 方法二、推完图片后，直接在你github图片仓库上操作： 将你放图片链接的位置替换为 jsdelivr 举例的CDN格式即可，以我头像的图片举例，用GitHub的格式为： 1https://cdn.jsdelivr.net/gh/user/repo@version/file 替换为： 1https://cdn.jsdelivr.net/gh/ys558/my-blog-imgs@0.17/avatar/宇航员.svg","tags":["CDN"]},{"title":"GraphQL学习","path":"/2021/04/20/【2021-04-20】GraphQL学习/","content":"去年自学了GraphQL，这里重新整理一下笔记。国内使用GraphQL的项目毕竟还不多，这里写个demo，做个小小的探索。 GraphQL是facebook发明的一套API查询语言，支持多种语言，这里用js演示，官网有详细的说明比起传统的后端API整合 GraphQL为你的API数据提供了一种完整且易于理解的描述。（GraphQL provides a complete and understandable description of the data in your API） 以上是官网对GraphQL的解释，利用GraphQL可以按需取字段给前端利用，不必取到不需要的字段，见下图解释： GraphQL则可以精确查找想要的字段，效率显著提高： 下面，结合自己写的demo：https://github.com/ys558/tech-blog-code/tree/master/2020/04-graphql-learn 完成以下完成本篇博客： 一、HelloWorld 将项目拉下来后，cd到对应目录下，用npm install或yarn安装依赖，运行npm run hello 或 yarn hello，先从 01helloworld.js 文件跑起，浏览器运行http://localhost:5000/左边输入框输入123query &#123; message&#125; 注意，这种是GraphQL特有的查询语法 点击运行，( 或快捷键 ctrl+enter ) 后，右边会显示： 01helloworld.js解析： graphqlHTTP 为 express-graphql 库解构的实例1const &#123; graphqlHTTP &#125; = require(&#x27;express-graphql&#x27;) GraphQL自带图形化界面且友好，，只需在实例 graphqlHTTP 中设置graphiql: true即可：1app.use(&#x27;/&#x27;, graphqlHTTP(&#123; schema, graphiql: true &#125;)) 在query实例中，fields 字段用于设置查询条件，是回调函数， fields 函数返回的东西用 resolve 函数接收其返回结果，接收结果也为回调函数 在接收结果中，可以规定其返回类型 type，其值为 Scalar Type (标量类型)1234567891011const schema = new GraphQLSchema(&#123; query: new GraphQLObjectType(&#123; name: &#x27;helloWorld&#x27;, fields: () =&gt; (&#123; message: &#123; type: GraphQLString, resolve: () =&gt; &#x27;Hello World&#x27; &#125; &#125;) &#125;)&#125;) 二、基础操作 运行npm run ds2 或 yarn ds2，浏览器跑 http://localhost:5000/books， 123456&#123; books &#123; id name &#125;&#125; 输入以上条件，通过 books 字段查询其对应的 id, name 后运行，可以查询出以下结果： 02base.js 解析： books查询出来的为一数组，其标量 定义为 GraphQLList1234567891011121314151617181920212223const RootQueryType = new GraphQLObjectType(&#123; name: &#x27;Query&#x27;, description: &#x27;Root Query&#x27;, fields: () =&gt; (&#123; /* 第一个 books 是命名，也可叫 aaa，如果改 aaa 则 在 query 条件改为： aaa &#123; books &#123; id name &#125; &#125; */ books: &#123; // BookType as params pass to RootQueryType type: new GraphQLList(BookType), description: &#x27;List of all books&#x27;, // 这里的 books 对应实际的 books 数组， // 要查询数组 books里的东西： resolve: () =&gt; books &#125; &#125;)&#125;) BookType 独立为标量GraphQLObjectType的实例化，由于其为最后一层数据，无需向下深挖，所以resolve 方法不需要 GraphQLNonNull 表示该字段为必须字段12345678const BookType = new GraphQLObjectType(&#123; name: &#x27;Book&#x27;, description: &#x27;this is represents a book written by an author&#x27;, fields: () =&gt; (&#123; id: &#123; type: GraphQLNonNull(GraphQLInt) &#125;, name: &#123; type: GraphQLNonNull(GraphQLString) &#125;, &#125;)&#125;) 三、通过书籍查询对应作者（一对一关系查询）及作者查询对应的书籍信息（一对多查询） 跑 03listQuery.js 文件，输入 12345678&#123; authors &#123; books &#123; id name &#125; &#125;&#125; 可以得到结果： 解析03listQuery.js ： 可以按照上面的方法继续丰富查询，建立一个模拟数据 author ，内容如下： 12345const authors = [ &#123; id: 1, name: &#x27;J. K. Rowling&#x27;&#125;, &#123; id: 2, name: &#x27;J. R. R. Tolkien&#x27;&#125;, &#123; id: 3, name: &#x27;Brent Weeks&#x27;&#125;,] 同样的，建立两个实例查询对应信息：resolve 部分对应相应的数据 123456789101112&#123; books: &#123; type: new GraphQLList(BookType), description: &#x27;List of all books&#x27;, resolve: () =&gt; books &#125;, authors: &#123; type: new GraphQLList(AuthorType), description: &#x27;List of all Authors&#x27;, resolve: () =&gt; authors &#125;&#125; 根据上面的字段名字books 和 authors 创建对应的查询实例： books实例里，id, name, authorId 均是 books 对象里的，可直接查出， author字段在 author 数组里 books 数据有关联的是authorId，用js的数组方法.find()去找 books &lt;–&gt; authors 是一对一的关系，AuthorType本身就是GraphQLObjectType 标量，可直接使用 12345678910111213141516const BookType = new GraphQLObjectType(&#123; name: &#x27;Book&#x27;, description: &#x27;this is represents a book written by an author&#x27;, fields: () =&gt; (&#123; id: &#123; type: GraphQLNonNull(GraphQLInt) &#125;, name: &#123; type: GraphQLNonNull(GraphQLString) &#125;, authorId: &#123; type: GraphQLNonNull(GraphQLInt)&#125;, author: &#123; type: AuthorType, // query book by authorId resolve: book =&gt; &#123; return authors.find( author =&gt; author.id === book.authorId ) &#125; &#125; &#125;)&#125;) authors实例也是同样道理 authors &lt;–&gt; books 是一对多的关系，BookType实例要装入GraphQLList标量中 123456789101112131415const AuthorType = new GraphQLObjectType(&#123; name: &#x27;Author&#x27;, description: &#x27;this is represents a author of a book&#x27;, fields: () =&gt; (&#123; id: &#123; type: GraphQLNonNull(GraphQLInt) &#125;, name: &#123; type: GraphQLNonNull(GraphQLString) &#125;, // query author by book&#x27;s id books: &#123; type: new GraphQLList(BookType), resolve: author =&gt; &#123; return books.filter(book =&gt; book.authorId === author.id) &#125; &#125; &#125;)&#125;) 四、通过书籍id查询书本信息 运行04singleQuery.js，输入以下查询条件： 12345678&#123; book(id: 4) &#123; name author &#123; name &#125; &#125;&#125; 执行结果如下： 输入以下条件 12345678&#123; book(id: 4) &#123; name author &#123; name &#125; &#125;&#125; 执行结果如下： 04singleQuery.js解析： 从以上的查询条件 book(id: 4) 可看出，通过传参id查询具体书籍信息，这里的id就体现在args参数上： args 在 resolve 函数里处于第二个参数的位置1234567book: &#123; type: BookType, description: &#x27;A Single Book&#x27;, // must query this book by params of book id: args: &#123; id: &#123; type: GraphQLInt &#125; &#125;, resolve: ( parent, args ) =&gt; books.find( book =&gt; book.id === args.id )&#125;, 同样的， author也可以按照传入authorId查询得到：1234567author: &#123; type: AuthorType, description: &#x27;A Single Author&#x27;, // query an author by params of author id: args: &#123; id: &#123; type: GraphQLInt &#125; &#125;, resolve: ( parent, args ) =&gt; authors.find( author =&gt; author.id === args.id )&#125;, 用 author(id) 查询结果： 五、修改数据（MutationType） 运行yarn ds5，浏览器输入： 123456mutation &#123; addBook(name: &quot;new book&quot;, authorId: 1) &#123; id name &#125;&#125; 可以看到增加单本书成功： 输入： 12345mutation &#123; addAuthor(name: &quot;new author&quot;) &#123; name &#125;&#125; 可以看到增加一个作者成功： 点击右上角的 &lt; Docs，可以发现该文件的Mutation函数，其中!意为必要字段： 05mutationType.js解析： 想要实现 Mutation Type 须在GraphQLSchema实例里添加mutation类型：1234const Schema = new GraphQLSchema(&#123; query: RootQueryType, mutation: RootMutationType&#125;) 和普通的 Query Type 类似，只不过 Mutation Type 在 resolve 里直接对数据进行改动而已：123456789101112131415161718192021222324252627fields: () =&gt; (&#123; addBook: &#123; type: BookType, description: &#x27;Add a book&#x27;, args: &#123; name: &#123; type: GraphQLNonNull(GraphQLString) &#125;, authorId: &#123; type: GraphQLNonNull(GraphQLInt) &#125; &#125;, resolve: ( parent, args ) =&gt; &#123; const book = &#123; id: books.length + 1, name: args.name, authorId: args.authorId &#125; books.push(book) return book &#125; &#125;, addAuthor: &#123; type: AuthorType, description: &#x27;Add a author&#x27;, args: &#123; name: &#123; type: GraphQLNonNull(GraphQLString) &#125; &#125;, resolve: ( parent, args ) =&gt; &#123; const author = &#123; id: authors.length + 1, name: args.name &#125; authors.push(author) return author &#125; &#125;,&#125;)","tags":["GraphQL"]},{"title":"Github Page建站心得及所踩的坑","path":"/2021/04/19/【2021-04-19】GithubPage建站心得及所踩的坑/","content":"最近想用 github.io 建立我的个人博客站点，具体步骤我参考了知乎上的一篇文章，里面写的够清楚了，下面就建站时碰到的坑写的不完全总结，估计以后陆续增加 ys558.github.io改为自己的域名去阿里云申请一个自己的域名后绑定原理的ys558.github.io域名，步骤： 登陆阿里云的万网，挑一个喜欢便宜的域名注册，我的域名 zyzy.info 一年只花21元，注册完成后选择个人站点，顺便也就开通了阿里云账号，如其他域名服务商，如申请.me结尾的个人网站，应该去GoDaddy等 依次进入右上角的 控制台 =&gt; 运维管理 选项卡下找到 域名 标签 =&gt; 点击 解析，如下： =&gt; 点击添加记录， 在 记录值 处填下ys558.github.io，如下，点击确定。这样就把你github.io上的页面绑定了购买的域名下 用ping 也可查询到新绑定的域名网址IP： 按以下命令在自己的github仓库中添加CNAME文件，其中填入购买的域名。或者可以在仓库的settings中设置Custom Domain设置好自己的域名，github会自动添加CNAME文件。 12touch CNAMEecho &#x27;zyzy.info&#x27;&gt; CNAME 图片显示错误：！！！该方法也是在网上搜索得到，虽可行，但解析中文路径时经常会出错，后来还是转用CDN，把图片全部移到另一个repo，推荐用CDN的方法，具体操作办法看我另一篇文章 需要安装一个图片路径转换的插件，这个插件名字是 hexo-asset-image 123npm i hexo-asset-image --save# oryarn add hexo-asset-image --save _config.yml文件，修改下述内容，用 hexo n &lt;博客文章名字&gt; 生成新博客时，会生成一个对应的文件夹，将图片放入该文件夹引用即可： 1post_asset_folder: true 修改博客目录下node_modules\\hexo-asset-image\\index.js (hexo文件有bug) 证书错误，不是私密连接Github建站好之后，经常会碰到打开页面浏览器显示不是私密链接的情况，搜来搜去，说是GitHub的SSL证书不稳定，不知道是不是墙的原因。 有两个方法可以解决：一是申请 cloudfare 的免费证书，二是自己买证书，两种方法都介绍以下 方法一： 某宝买证书去某宝买了证书，（p.s. 不差钱也可以直接买阿里云的证书，两年2000多），证书是有有效期的，我买的那家证书一年80元，两年140元，5年300元。选个自己能接受，不太贵的价格即可。一般销量高的店家都有教你怎么配置，我这里把其配置记录了下来： 1. 在 Github Page 上取消勾选 Enforce HTTPS 服务位置如下图： 2. 将买到的证书在阿里云上设置如下图顺序设置便可完成： 方法二：蹭 cloudfare 的免费证书1. 申请个 cloudfare 账号，并添加DNScloudfare 我的cloudfare是以前注册的，忘了一步步截图，但有中文界面跟着提示操作即可，不会很难，注册完成后，在以下界面操作： 找到github的ipv4的地址为以下几个，也不知道访问时会分配到哪个ip，索性A类地址全部添加上，像阿里云以下，把 CHAME 类地址也添加上，如下： 2. 返回阿里云添加 cloudfare 申请的DNS服务器 Github Page 更新自己的域名 点击仓库 ys558.github.io 里的 Settings 点击左侧的 Pages 在 Custom domain 里输入自己配置好DNS的域名 点击 Save, 则会自动检查域名是否可用","tags":["Hexo","Github Page"]}]