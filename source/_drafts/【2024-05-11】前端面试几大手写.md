---
title: 前端面试几大手写
date: 2024-05-11 10:00:00
tags:
  - 面试
  - 前端
cover: https://cdn.jsdelivr.net/gh/ys558/my-blog-imgs@1.55/articles/Vue3学习/cover.png
---

包括`Promise`，数据解构这里复习一下，我会过程化一步步拆解

<!-- more -->

## `Promise`

这个是重中之重，我们来一步步拆解

### 1. 实现 `new` 关键字及构造函数初始化

```js
// 1. 实现 new 关键字及构造函数初始化
class MyPromise {
  // 2. 定义构造函数及 executor
  constructor(executor) {
    // 3. 定义MyPromise里的两个回调函数，暂且用控制台打印占位
    const resolve = (result) => {
      console.log("执行了", result);
    };
    const reject = (result) => {
      console.log("错误", result);
    };

    // 4. 执行 executor
    executor(resolve, reject);
  }
}

// ---------- 测试代码 ----------
const p = new MyPromise((resolve, reject) => {
  resolve("success");
  reject("error");
});
// 执行了 success
// 错误 error
```

### 2. 定义状态`state`、原因`result`

这一节来定义 `MyPromise` 调用时的两个函数，resolve 和 reject。

- promise 有三种状态：pending、fulfilled、rejected，可以将其定义在类外边
- 这三中状态是 pending -> fulfilled 或 pending -> rejected 且不可逆，意味着，如果同时写了 resolve 和 reject，在回调函数里，resolve 在前，则执行 resolve，reject 则不执行
- 在 `MyPromise` 顶层，定义 `state` 和 `result`，在 `constructor` 中的 resolve 和 reject 函数中实现状态切换
- constructor 中，执行 `executor`，传入 `resolve` 和 `reject`，`executor` 中执行 `resolve` 和 `reject`，实现状态切换

```js
// 1. 添加状态：
const PENDING = "pending";
const FULFILLED = "fulfilled";
const REJECTED = "rejected";

class MyPromise {
  // 1. 初始化状态：
  state = PENDING;
  // 2. 初始化原因;
  result = undefined;

  constructor(executor) {
    // 3. 改状态： pending -> fulfilled
    const resolve = (result) => {
      // 4. pending -> fulfilled 是不可逆状态，所以加判断，如果不为 pending 则跳出执行
      if (this.state !== PENDING) return;
      this.state = FULFILLED;
      this.result = result;
    };
    // 3. 改状态： pending -> rejected
    const reject = (result) => {
      // 4. pending -> rejected 状态不可逆
      if (this.state !== PENDING) return;
      this.state = REJECTED;
      this.result = result;
    };

    executor(resolve, reject);
  }
}
```

运行测试代码：
我们可以看到，同时摆了两个回调函数，但是只会执行前面的函数：

```js
const p = new MyPromise((resolve, reject) => {
  resolve("成功");
  reject("失败");
});
// 只执行了 resolve，实现了状态不可逆
console.log(p.state); // fulfilled
console.log(p.result); // 成功
```

或者：

```js
const p = new MyPromise((resolve, reject) => {
  reject("失败");
  resolve("成功");
});
// 只执行了 reject，实现了状态不可逆
console.log(p.state); // rejected
console.log(p.result); // 失败
```

### 3. `then()`

接下来写 then 方法，我们知道 then 方法里有两个参数

- 第一个参数是成功回调，第二个参数是失败回调，那么我们先写一个简单的 then 方法，先添加测试代码：
- 执行 MyPromise 的 resolve 方法，则

```js
p.then(
  (res) => {
    console.log("success", res);
  },
  (err) => {
    console.log("error", err);
  }
);
```

- 判断 onFulfilled 接着再在类里添加 then 方法，其中，关于[传入的 onFulfilled 和 onRejected 参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise/then#%E8%AF%AD%E6%B3%95) 如果传入的不是函数，我们可以从官网中找到他不是函数时的判断：

```js
  then(onFulfilled, onRejected) {
    // 1. 判断传进的参数 resolve("成功"); reject("出错了");是否为函数：
    onFulfilled = typeof onFulfilled === "function" ? onF ulfilled : value => value;
    onRejected = typeof onRejected === "function" ? onRejected : err => {throw err};

    if (this.state === FULFILLED) {
      onFulfilled(this.result)
    }else if (this.state === REJECTED) {
      onRejected(this.result)
    }
  }
```

### 4. 解决异步调用及多次调用

上面的 `then()`还没解决在 promise 里写异步调用的问题和多次调用，比如这样：

```js
const p = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    resolve("成功");
    // reject("失败");
  }, 1000);
});
p.then(
  (res) => {
    console.log("then1", res);
  },
  (err) => {
    console.log("error1", err);
  }
);
p.then(
  (res) => {
    console.log("then2", res);
  },
  (err) => {
    console.log("error2", err);
  }
);
```

这牵扯到我们上面的代码没有处理 Pending 状态的逻辑，因为异步的代码不可能马上执行，中间肯定会存在 pending 状态
所以我们要做的是：

- 让我们的 Promise 增加处理 Pending 的逻辑
- 正如我们测试代码所示，在 setTimeout 中执行 resolve，中间隔了 1 秒，那么 `onFulfilled` 和 `onRejected` 函数必须有一个存放的容器

定义私有容器

```js
class MyPromise {
  ...
  // 增加私有容器变量，存放 resovle 和 reject 函数
  #handlers = [];

  ...
}
```

在 `then()` 方法里增加处理默认状态 pending 的逻辑，将外部传进来的 `onFulfilled` (对应外部调用的 resolve) 和 `onRejected` (对应外部调用的 reject) 函数存放到容器里

```js
else {
  // 在 `then()` 方法里增加一个默认逻辑的判断：
  this.#handlers.push({ onFulfilled, onRejected })
}
```

在 setTimeout 1 秒过完后，需要执行对应的 resovle 或 reject 函数，则需要改动 constructor 里 resolve 或 reject 函数的逻辑，增加

```js
const resolve = (result) => {
  if (this.state !== PENDING) return;
  this.state = FULFILLED;
  this.result = result;
  // 遍历 #handlers 数组，执行 onFulfilled 函数
  this.#handlers.forEach(({ onFulfilled }) => {
    onFulfilled(this.result);
  });
};
const reject = (result) => {
  if (this.state !== PENDING) return;
  this.state = REJECTED;
  this.result = result;
  // 遍历 #handlers 数组，执行 onRejected 函数
  this.#handlers.forEach(({ onRejected }) => {
    onRejected(this.result);
  });
};
```

### 5. 将`then()`的执行结果变为异步任务

#### 测试异步任务

当我们执行一个真实的 Promise 时，`then()` 方法的执行结果是异步的。如何验证其是异步呢？比如下面的代码：

```js
console.log(1);
const p = new Promise((res, reject) => {
  res("success");
});
p.then((res) => {
  console.log(res);
});
console.log(2);
// 1
// 2
// success
```

执行结果是：1，2，success，而不是 1，success，2。就证明了 then()是异步任务。

回到我自己写的 `MyPromise` 代码，我们发现 then 是同步的，输出结果是 1 success 2，而不是 1 2 success。

```js
console.log(1);
const p = new MyPromise((resolve, reject) => {
  resolve("成功");
});
// console.log(p.state) // fulfilled
// console.log(p.result) // 成功
p.then(
  (res) => {
    console.log(res);
  },
  (err) => {
    console.log(err);
  }
);
console.log(2);
// 1
// success
// 2
```

所以 `then()` 需要改造为异步

#### 封装独立的异步函数

这里我们选定了 `quequeueMicrotask` (微任务)，`MutationObserver` (宏任务，只能用于浏览器里)，`setTimeout` (宏任务)作为封装的对象

```js
const runAsyncTask = (cb) => {
  // 这个是检查当前环境是不是浏览器：
  if (typeof queueMicrotask === "function") {
    queueMicrotask(cb);
  } else if (typeof MutationObserver === "function") {
    const obs = new MutationObserver(cb);
    const div = document.createElement("div");
    obs.observe(div, {
      childList: true,
    });
    div.innerHTML = "test";
  } else {
    // setTimeout 兜底
    setTimeout(cb, 0);
  }
};
```

接着，我们对 `then()` 方法进行改造：

```js
then(onFulfilled, onRejected) {
  // 1. 判断传进的参数 resolve("成功"); reject("出错了");是否为函数：
  onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value;
  onRejected = typeof onRejected === "function" ? onRejected : err => {throw err};


  if (this.state === FULFILLED) {
    runAsyncTask(() => onFulfilled(this.result))
  }else if (this.state === REJECTED) {
    runAsyncTask(() => onRejected(this.result))
  }else {
    // 2. 保存回调函数：
    this.#handlers.push({
      onFulfilled: () => runAsyncTask(() => onFulfilled(this.result)),
      onRejected: () => runAsyncTask(() => onRejected(this.result))
    })
  }
}
```

可以发现测试代码可以执行正确的异步顺序：

```js
console.log(1);
const p = new MyPromise((resolve, reject) => {
  resolve("成功");
});
p.then(
  (res) => {
    console.log("then", res);
  },
  (err) => {
    console.log("error", err);
  }
);
console.log(2);
// 1
// 2
// then 成功
```

#### then() 的链式调用 `resolve` (`fulfilled`) 函数处理

.then() 函数是可以无限链式调用下去的，例如下面的测试代码：

```js
const p = new MyPromise((resolve, reject) => {
  resolve("成功");
});

p.then((res) => {
  console.log("then1", res);
  throw "throw err";
  return 88;
}).then(
  (res) => {
    console.log("then2", res);
  },
  (err) => {
    console.log("err2", err);
  }
);
// then1 成功
// then2 88
// err2 88
```

- 第一个 `then()` 里 `return 88;` 会跑到后续的 `then()` 中的第一个回调函数执行，因为 `then()` 返回的是一个新的 `Promise` 对象，
- 第一个 `then()` 里抛出异常，或者在第一个函数直接 `throw` 抛出异常，会跑到后续的 `catch()` 中的第二个函数执行，因为 `then()` 返回的是一个新的 `Promise` 对象，

到这一步为止，我们的代码还没实现链式调用，上面的代码我们会报错，所以继续完善我们的 `.then()` 函数

- `then()` 里必须返回一个新的 `MyPromise` 对象，

```js
then() {
  ...
  const nextMyPromise = new MyPromise((resolve, reject) => {
  }

  ...
  return nextMyPromise
}
```

这样处理后，我们第二个 `then()` 至少运行时不会报错了，接着处理测试代码里的 **`return 88`**

- 把`then()` 里 if-else 那段逻辑放进来 nextMyPromise 的第一个回调函数里，再用 `resolve()` 把结果传给下一个 `then()` 的回调函数。这里确实挺烧脑。如下：

```js
then(onFulfilled, onRejected) {
  //...

  const nextMyPromise = new MyPromise((res, rej) => {
    if (this.state === FULFILLED) {
      runAsyncTask(() => {
        const nextResolve = onFulfilled(this.result)
        res(nextResolve)
      })
    }else if (this.state === REJECTED) {
      runAsyncTask(() => onRejected(this.result))
    }else {
      // 2. 保存回调函数：
      this.#handlers.push({
        onFulfilled: () => runAsyncTask(() => onFulfilled(this.result)),
        onRejected: () => runAsyncTask(() => onRejected(this.result))
      })
    }
  })

  return nextMyPromise
}
```

最后我们处理测试代码里第一个 `.then()` 里的 `throw "throw err";`

- 抛出异常，必须用 try-catch 套在 `if (this.state === FULFILLED) {` 的分支里，再将 catch 到的 error 传给第二个 `.then()` 的 `onRejected`，即第二个函数里：

```js
then(onFulfilled, onRejected) {
  // 1. 判断传进的参数 resolve("成功"); reject("出错了");是否为函数：
  onFulfilled = typeof onFulfilled === "function" ? onFulfilled : value => value;
  onRejected = typeof onRejected === "function" ? onRejected : err => {throw err};

  return new MyPromise((res, rej) => {
    if (this.state === FULFILLED) {
      runAsyncTask(() => {
        try {
          const nextResolve = onFulfilled(this.result)
          res(nextResolve)
        }catch (e) {
          rej(e)
        }
      })
    }else if (this.state === REJECTED) {
      runAsyncTask(() => onRejected(this.result))
    }else {
      // 2. 保存回调函数：
      this.#handlers.push({
        onFulfilled: () => runAsyncTask(() => onFulfilled(this.result)),
        onRejected: () => runAsyncTask(() => onRejected(this.result))
      })
    }
  })
}
```

#### then() 里返一个 Promise

继续完善测试代码：

```js

```
